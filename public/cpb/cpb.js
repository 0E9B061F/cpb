
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function compute_slots(slots) {
        const result = {};
        for (const key in slots) {
            result[key] = true;
        }
        return result;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty$1() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }
    class HtmlTag {
        constructor() {
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    function hasContext(key) {
        return get_current_component().$$.context.has(key);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.3' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /* src/LinkMark.svelte generated by Svelte v3.44.3 */

    const file$_ = "src/LinkMark.svelte";

    function create_fragment$1K(ctx) {
    	let svg;
    	let circle;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			attr_dev(circle, "cx", "3");
    			attr_dev(circle, "cy", "3");
    			attr_dev(circle, "r", "2.5");
    			add_location(circle, file$_, 4, 2, 94);
    			attr_dev(svg, "class", "mark");
    			attr_dev(svg, "viewBox", "0 0 6 6");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$_, 3, 0, 20);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, circle);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1K($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LinkMark', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LinkMark> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class LinkMark extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1K, create_fragment$1K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LinkMark",
    			options,
    			id: create_fragment$1K.name
    		});
    	}
    }

    var syskey = "CPB";
    var proto$1 = "http";
    var domain$1 = "localhost";
    var port = 3000;
    var defns = "main";
    var defapi = "api";
    var deftitle = "Home";
    var deflogin = "login";
    var defregister = "register";
    var defuser = "user";
    var deftest = "test";
    var defsearch = "search";
    var fade$1 = 500;
    var fadein = 2500;
    var homekey = "~";
    var title$1 = "CPB";
    var searchDefaults = {
    	sz: 25,
    	inf: [
    		"title",
    		"body"
    	],
    	inh: false,
    	pg: 1
    };
    var historyDefaults = {
    	sz: 25,
    	pg: 1
    };
    var minResults = 5;
    var maxResults = 50;
    var readSpeed = 200;
    var singleuser$1 = false;
    var defaults$1 = {
    	syskey: syskey,
    	proto: proto$1,
    	domain: domain$1,
    	port: port,
    	defns: defns,
    	defapi: defapi,
    	deftitle: deftitle,
    	deflogin: deflogin,
    	defregister: defregister,
    	defuser: defuser,
    	deftest: deftest,
    	defsearch: defsearch,
    	fade: fade$1,
    	fadein: fadein,
    	homekey: homekey,
    	title: title$1,
    	searchDefaults: searchDefaults,
    	historyDefaults: historyDefaults,
    	minResults: minResults,
    	maxResults: maxResults,
    	readSpeed: readSpeed,
    	singleuser: singleuser$1
    };

    var fade = 500;
    var title = "0x2764";
    var singleuser = false;
    var user = {
    	fade: fade,
    	title: title,
    	singleuser: singleuser
    };

    var rc = Object.assign({}, defaults$1, user);

    const hex = '[a-fA-F0-9]';
    const gold = 1.618033988749894;

    const isuu =s=> {
      if (typeof(s) != 'string') return false
      return !!s.match(`^${hex}{8}-(${hex}{4}-){3}${hex}{12}$`)
    };

    const mkq =o=> {
      const kvp = Object.entries(o).filter(p=> {
        return p[1] !== undefined && p[1] !== null
      }).map(p=> {
        if (p[1] === true) return p[0]
        else return `${p[0]}=${p[1]}`
      }).join('&');
      return kvp.length ? `?${kvp}` : ''
    };
    const rq =(q,tr={})=> {
      if (q[0] != '?') throw new Error('invalid query')
      q = q.slice(1);
      const o = {};
      q.split('&').forEach(kv=> {
        kv = kv.split('=');
        if (kv.length > 1) {
          o[kv[0]] = kv[1];
        } else {
          o[kv[0]] = true;
        }
      });
      Object.keys(o).forEach(k=> {
        if (tr[k]) o[k] = tr[k](o[k]);
        else if (typeof(o[k]) == 'string') {
          if (o[k].match(/^\d+$/)) o[k] = parseInt(o[k]);
          else if (o[k].indexOf(',') > -1) o[k] = o[k].split(',');
        }
      });
      return o
    };

    const mask =(o,m)=> {
      const r = {};
      Object.keys(m).forEach(k=> {
        if (o[k]) r[k] = o[k];
        else if (m[k] !== undefined) r[k] = m[k];
      });
      return r
    };

    const grs =(c, s=[1])=> {
      if (c - 1 > 0) return grs(c-1, [...s, s[s.length-1] * gold])
      else return s
    };
    const grf =(f, ...a)=> {
      const s = grs(...a);
      const m = s[0];
      return s.map(x=> ((x - m) * f) + m)
    };
    const gild =(...n)=> {
      return n.map(x=> x * gold)
    };

    const tag =(ns, t)=> {
      if (!t) return `${ns}:`
      else if (ns == rc.defns) return `${t}`
      else return `${ns}:${t}`
    };
    const denst =nst=> {
      const out = {};
      const nt = nst.split(':');
      if (nt.length > 1) {
        out.space = nt[0];
        if (nt[1]) out.title = nt[1];
      } else {
        out.space = rc.defns;
        out.title = nt[0];
      }
      return out
    };

    const rint =(min, max)=> {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min + 1)) + min
    };

    const sample =a=> a[rint(0,a.length-1)];

    var util = { isuu, grs, grf, gold, gild, rq, mkq, mask, tag, denst, rint, sample };

    /* src/Link.svelte generated by Svelte v3.44.3 */

    const { Object: Object_1$6 } = globals;
    const file$Z = "src/Link.svelte";

    // (276:0) {:else}
    function create_else_block_1$5(ctx) {
    	let a;
    	let t;
    	let current_block_type_index;
    	let if_block1;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*marked*/ ctx[4] && create_if_block_5$5(ctx);
    	const if_block_creators = [create_if_block_4$8, create_else_block_2$1];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$$slots*/ ctx[20].default) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (if_block0) if_block0.c();
    			t = space();
    			if_block1.c();
    			attr_dev(a, "href", /*href*/ ctx[6]);
    			attr_dev(a, "title", /*rinfo*/ ctx[9]);
    			attr_dev(a, "class", /*cls*/ ctx[8]);
    			add_location(a, file$Z, 276, 2, 6718);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if (if_block0) if_block0.m(a, null);
    			append_dev(a, t);
    			if_blocks[current_block_type_index].m(a, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", prevent_default(/*clicked*/ ctx[19]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*marked*/ ctx[4]) {
    				if (if_block0) {
    					if (dirty[0] & /*marked*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5$5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(a, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(a, null);
    			}

    			if (!current || dirty[0] & /*href*/ 64) {
    				attr_dev(a, "href", /*href*/ ctx[6]);
    			}

    			if (!current || dirty[0] & /*rinfo*/ 512) {
    				attr_dev(a, "title", /*rinfo*/ ctx[9]);
    			}

    			if (!current || dirty[0] & /*cls*/ 256) {
    				attr_dev(a, "class", /*cls*/ ctx[8]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (if_block0) if_block0.d();
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$5.name,
    		type: "else",
    		source: "(276:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (267:0) {#if disable || nolink || (current && !global)}
    function create_if_block_1$v(ctx) {
    	let span;
    	let t;
    	let current_block_type_index;
    	let if_block1;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*marked*/ ctx[4] && create_if_block_3$g(ctx);
    	const if_block_creators = [create_if_block_2$l, create_else_block$s];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$$slots*/ ctx[20].default) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (if_block0) if_block0.c();
    			t = space();
    			if_block1.c();
    			attr_dev(span, "class", /*cls*/ ctx[8]);
    			attr_dev(span, "title", /*rinfo*/ ctx[9]);
    			add_location(span, file$Z, 267, 2, 6532);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if (if_block0) if_block0.m(span, null);
    			append_dev(span, t);
    			if_blocks[current_block_type_index].m(span, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*clicked*/ ctx[19], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*marked*/ ctx[4]) {
    				if (if_block0) {
    					if (dirty[0] & /*marked*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$g(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(span, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(span, null);
    			}

    			if (!current || dirty[0] & /*cls*/ 256) {
    				attr_dev(span, "class", /*cls*/ ctx[8]);
    			}

    			if (!current || dirty[0] & /*rinfo*/ 512) {
    				attr_dev(span, "title", /*rinfo*/ ctx[9]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (if_block0) if_block0.d();
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$v.name,
    		type: "if",
    		source: "(267:0) {#if disable || nolink || (current && !global)}",
    		ctx
    	});

    	return block;
    }

    // (278:4) {#if marked}
    function create_if_block_5$5(ctx) {
    	let linkmark;
    	let current;
    	linkmark = new LinkMark({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(linkmark.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(linkmark, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linkmark.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linkmark.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(linkmark, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$5.name,
    		type: "if",
    		source: "(278:4) {#if marked}",
    		ctx
    	});

    	return block;
    }

    // (281:4) {:else}
    function create_else_block_2$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*text*/ ctx[7]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*text*/ 128) set_data_dev(t, /*text*/ ctx[7]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(281:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (279:4) {#if $$slots.default}
    function create_if_block_4$8(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[46].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[45], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[45], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$8.name,
    		type: "if",
    		source: "(279:4) {#if $$slots.default}",
    		ctx
    	});

    	return block;
    }

    // (269:4) {#if marked}
    function create_if_block_3$g(ctx) {
    	let linkmark;
    	let current;
    	linkmark = new LinkMark({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(linkmark.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(linkmark, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linkmark.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linkmark.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(linkmark, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$g.name,
    		type: "if",
    		source: "(269:4) {#if marked}",
    		ctx
    	});

    	return block;
    }

    // (272:4) {:else}
    function create_else_block$s(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*text*/ ctx[7]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*text*/ 128) set_data_dev(t, /*text*/ ctx[7]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$s.name,
    		type: "else",
    		source: "(272:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (270:4) {#if $$slots.default}
    function create_if_block_2$l(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[46].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[45], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 16384)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[45],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[45])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[45], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$l.name,
    		type: "if",
    		source: "(270:4) {#if $$slots.default}",
    		ctx
    	});

    	return block;
    }

    // (286:0) {#if dbg}
    function create_if_block$W(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*href*/ ctx[6]);
    			add_location(span, file$Z, 285, 9, 6925);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*href*/ 64) set_data_dev(t, /*href*/ ctx[6]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$W.name,
    		type: "if",
    		source: "(286:0) {#if dbg}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1J(ctx) {
    	let current_block_type_index;
    	let if_block0;
    	let t;
    	let if_block1_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$v, create_else_block_1$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*disable*/ ctx[3] || /*nolink*/ ctx[2] || /*current*/ ctx[0] && !/*global*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = /*dbg*/ ctx[5] && create_if_block$W(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(t.parentNode, t);
    			}

    			if (/*dbg*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$W(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1J($$self, $$props, $$invalidate) {
    	let $linkmap;
    	let $path;
    	let $loc;
    	let $rc;
    	let $session;
    	let $haslogin;
    	let $trail;
    	let $links;
    	let $gs;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Link', slots, ['default']);
    	const $$slots = compute_slots(slots);
    	const gs = getContext('gs');
    	validate_store(gs, 'gs');
    	component_subscribe($$self, gs, value => $$invalidate(54, $gs = value));
    	const rc = getContext('rc');
    	validate_store(rc, 'rc');
    	component_subscribe($$self, rc, value => $$invalidate(49, $rc = value));
    	const trail = getContext('trail');
    	validate_store(trail, 'trail');
    	component_subscribe($$self, trail, value => $$invalidate(52, $trail = value));
    	const path = getContext('path');
    	validate_store(path, 'path');
    	component_subscribe($$self, path, value => $$invalidate(43, $path = value));
    	const links = getContext('links');
    	validate_store(links, 'links');
    	component_subscribe($$self, links, value => $$invalidate(53, $links = value));
    	const linkmap = getContext('linkmap');
    	validate_store(linkmap, 'linkmap');
    	component_subscribe($$self, linkmap, value => $$invalidate(42, $linkmap = value));
    	const loading = getContext('loading');
    	const haslogin = getContext('haslogin');
    	validate_store(haslogin, 'haslogin');
    	component_subscribe($$self, haslogin, value => $$invalidate(51, $haslogin = value));
    	const session = getContext('session');
    	validate_store(session, 'session');
    	component_subscribe($$self, session, value => $$invalidate(50, $session = value));
    	const loc = getContext('loc');
    	validate_store(loc, 'loc');
    	component_subscribe($$self, loc, value => $$invalidate(44, $loc = value));
    	const reload = getContext('reload');
    	let { nst = null } = $$props;
    	let { space = null } = $$props;
    	let { title = null } = $$props;
    	let { uuid = null } = $$props;
    	let { cmd = null } = $$props;
    	let { sub = null } = $$props;
    	let { opt = null } = $$props;
    	let { self = false } = $$props;
    	let { bounce = false } = $$props;
    	let { first = null } = $$props;
    	let { cond = null } = $$props;
    	let { does = null } = $$props;
    	let { global = false } = $$props;
    	let { nored = false } = $$props;
    	let { nolink = false } = $$props;
    	let { disable = false } = $$props;
    	let { silent = null } = $$props;
    	let { marked = false } = $$props;
    	let { c = [] } = $$props;
    	let { current = false } = $$props;
    	let { info = null } = $$props;
    	let { dbg = false } = $$props;
    	let href;
    	let ident;
    	let text;
    	let reddable = false;
    	let scratch = { sub: [], opt: {} };
    	let special = false;
    	let cls = '';
    	let rinfo = '';
    	let registered;
    	let { addr = href } = $$props;

    	const goto = p => {
    		if (does) does();

    		if (!nolink) {
    			if (!current) $gs.goto(href); else reload();
    		}
    	};

    	const nav = () => {
    		if (first) first().then(r => goto()); else goto();
    	};

    	const clicked = () => {
    		if (disable || current && !global) return;

    		if (cond) cond().then(r => {
    			if (r) nav();
    		}); else nav();
    	};

    	const register = () => {
    		if (!reddable && registered || !ident && registered) deregister(); else {
    			if (reddable && registered != ident) {
    				if (registered) {
    					deregister();
    				}

    				registered = ident;
    				set_store_value(links, $links = [...$links, ident], $links);
    			}
    		}
    	};

    	const deregister = () => {
    		if (!registered) return;
    		const n = $links.indexOf(registered);
    		if (n < 0) return;
    		$links.splice(n, 1);
    		registered = null;
    		links.set($links);
    	};

    	// foo
    	// main:foo
    	// main:
    	const parsenst = () => {
    		if (nst) {
    			const nt = nst.split(':');

    			if (nt.length > 1) {
    				scratch.space = nt[0];
    				if (nt[1]) scratch.title = nt[1];
    			} else {
    				scratch.space = $rc.defns;
    				scratch.title = nt[0];
    			}
    		}
    	};

    	const trace = () => {
    		return $trail[1] || bounce || '/';
    	};

    	const follow = () => {
    		scratch.space = $loc.namespace;
    		scratch.title = $loc.title;
    		scratch.uuid = $loc.uuid;
    		scratch.sub = $loc.sub;
    		scratch.cmd = $loc.cmd;
    		scratch.opt = $loc.opt;
    	};

    	const preload = () => {
    		if (space) scratch.space = space;
    		if (title) scratch.title = title;
    		if (uuid) scratch.uuid = uuid;

    		if (sub) {
    			if (Array.isArray(sub)) scratch.sub = sub; else if (typeof sub == 'string') scratch.sub = sub.split('/'); else scratch.sub = [sub];
    		}

    		if (cmd) scratch.cmd = cmd;
    		if (opt) scratch.opt = Object.assign({}, scratch.opt, opt);
    	};

    	const mkhref = () => {
    		if (bounce) {
    			$$invalidate(6, href = trace());
    			return;
    		}

    		scratch = { sub: [], opt: {} };
    		$$invalidate(41, special = false);
    		if (self) follow();
    		preload();
    		parsenst();
    		mkident();
    		if (scratch.space == $rc.syskey) $$invalidate(41, special = true);

    		if (nolink) $$invalidate(6, href = null); else if (scratch.uuid) {
    			const u = scratch.uuid.toUpperCase();
    			$$invalidate(6, href = `/${u}`);
    			$$invalidate(9, rinfo = u);
    		} else if (scratch.space == $rc.syskey && scratch.title == 'user') {
    			$$invalidate(9, rinfo = `User:`);

    			if (scratch.sub[0]) {
    				$$invalidate(6, href = `/~${scratch.sub[0]}`);
    				$$invalidate(9, rinfo = `${rinfo} ${scratch.sub[0]}`);

    				if (!!$haslogin && scratch.sub[0] == $session.val.handle) {
    					$$invalidate(9, rinfo = `${rinfo} (you)`);
    				}
    			} else if (!!$haslogin) {
    				$$invalidate(6, href = `/~${$session.val.handle}`);
    				$$invalidate(9, rinfo = `${rinfo} ${$session.val.handle} (you)`);
    			} else {
    				$$invalidate(6, href = '/~');
    				$$invalidate(9, rinfo = `${rinfo} you`);
    			}
    		} else if (scratch.title) {
    			const sp = scratch.space || $rc.defns;
    			$$invalidate(6, href = `/${sp}/${scratch.title}`);
    			$$invalidate(9, rinfo = util.tag(sp, scratch.title));
    		} else if (scratch.space) {
    			$$invalidate(6, href = `/${scratch.space}`);
    			$$invalidate(9, rinfo = util.tag(scratch.space));
    		} else {
    			$$invalidate(6, href = `/`);
    			$$invalidate(9, rinfo = rc.title);
    		}

    		if (scratch.space == $rc.syskey) $$invalidate(6, href = [href, ...scratch.sub].join('/'));

    		if (scratch.opt) {
    			$$invalidate(6, href = `${href}${util.mkq(scratch.opt)}`);

    			if (scratch.space != $rc.syskey) {
    				if (scratch.opt.history) $$invalidate(9, rinfo = `(HISTORY) ${rinfo}`); else if (scratch.opt.edit) $$invalidate(9, rinfo = `(EDIT) ${rinfo}`);
    			}
    		}

    		if (scratch.cmd) $$invalidate(6, href = `${href}#${scratch.cmd}`);
    		$$invalidate(0, current = $path == href);
    		if (info) $$invalidate(9, rinfo = info);
    		if (current && !global) $$invalidate(9, rinfo = `${rinfo} (current)`);
    		$$invalidate(21, addr = href);
    	};

    	const mkident = () => {
    		if (scratch.uuid) {
    			$$invalidate(39, ident = scratch.uuid);
    			$$invalidate(7, text = scratch.uuid);
    		} else if (scratch.title) {
    			$$invalidate(39, ident = `${scratch.space}:${scratch.title}`);
    			$$invalidate(7, text = scratch.title);
    		} else if (scratch.space) {
    			$$invalidate(39, ident = scratch.space);
    			$$invalidate(7, text = `#${scratch.space}`);
    		} else {
    			$$invalidate(39, ident = null);
    			$$invalidate(7, text = 'BUTTON');
    		}

    		register();
    	};

    	const mkcls = () => {
    		const cc = [...c, 'cpblink'];
    		if (reddable && !!$linkmap.val && !!$linkmap.val[ident]) cc.push('missing');
    		if (silent) cc.push('silent');
    		if (disable) cc.push('disabled-link');
    		if (nolink) cc.push('nolink');
    		if (!global && current) cc.push('current-link');
    		$$invalidate(8, cls = cc.join(' '));
    	};

    	const trigger = () => clicked();
    	onDestroy(() => deregister());

    	const writable_props = [
    		'nst',
    		'space',
    		'title',
    		'uuid',
    		'cmd',
    		'sub',
    		'opt',
    		'self',
    		'bounce',
    		'first',
    		'cond',
    		'does',
    		'global',
    		'nored',
    		'nolink',
    		'disable',
    		'silent',
    		'marked',
    		'c',
    		'current',
    		'info',
    		'dbg',
    		'addr'
    	];

    	Object_1$6.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Link> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('nst' in $$props) $$invalidate(22, nst = $$props.nst);
    		if ('space' in $$props) $$invalidate(23, space = $$props.space);
    		if ('title' in $$props) $$invalidate(24, title = $$props.title);
    		if ('uuid' in $$props) $$invalidate(25, uuid = $$props.uuid);
    		if ('cmd' in $$props) $$invalidate(26, cmd = $$props.cmd);
    		if ('sub' in $$props) $$invalidate(27, sub = $$props.sub);
    		if ('opt' in $$props) $$invalidate(28, opt = $$props.opt);
    		if ('self' in $$props) $$invalidate(29, self = $$props.self);
    		if ('bounce' in $$props) $$invalidate(30, bounce = $$props.bounce);
    		if ('first' in $$props) $$invalidate(31, first = $$props.first);
    		if ('cond' in $$props) $$invalidate(32, cond = $$props.cond);
    		if ('does' in $$props) $$invalidate(33, does = $$props.does);
    		if ('global' in $$props) $$invalidate(1, global = $$props.global);
    		if ('nored' in $$props) $$invalidate(34, nored = $$props.nored);
    		if ('nolink' in $$props) $$invalidate(2, nolink = $$props.nolink);
    		if ('disable' in $$props) $$invalidate(3, disable = $$props.disable);
    		if ('silent' in $$props) $$invalidate(35, silent = $$props.silent);
    		if ('marked' in $$props) $$invalidate(4, marked = $$props.marked);
    		if ('c' in $$props) $$invalidate(36, c = $$props.c);
    		if ('current' in $$props) $$invalidate(0, current = $$props.current);
    		if ('info' in $$props) $$invalidate(37, info = $$props.info);
    		if ('dbg' in $$props) $$invalidate(5, dbg = $$props.dbg);
    		if ('addr' in $$props) $$invalidate(21, addr = $$props.addr);
    		if ('$$scope' in $$props) $$invalidate(45, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		LinkMark,
    		getContext,
    		onDestroy,
    		gs,
    		rc,
    		trail,
    		path,
    		links,
    		linkmap,
    		loading,
    		haslogin,
    		session,
    		loc,
    		reload,
    		util,
    		nst,
    		space,
    		title,
    		uuid,
    		cmd,
    		sub,
    		opt,
    		self,
    		bounce,
    		first,
    		cond,
    		does,
    		global,
    		nored,
    		nolink,
    		disable,
    		silent,
    		marked,
    		c,
    		current,
    		info,
    		dbg,
    		href,
    		ident,
    		text,
    		reddable,
    		scratch,
    		special,
    		cls,
    		rinfo,
    		registered,
    		addr,
    		goto,
    		nav,
    		clicked,
    		register,
    		deregister,
    		parsenst,
    		trace,
    		follow,
    		preload,
    		mkhref,
    		mkident,
    		mkcls,
    		trigger,
    		$linkmap,
    		$path,
    		$loc,
    		$rc,
    		$session,
    		$haslogin,
    		$trail,
    		$links,
    		$gs
    	});

    	$$self.$inject_state = $$props => {
    		if ('nst' in $$props) $$invalidate(22, nst = $$props.nst);
    		if ('space' in $$props) $$invalidate(23, space = $$props.space);
    		if ('title' in $$props) $$invalidate(24, title = $$props.title);
    		if ('uuid' in $$props) $$invalidate(25, uuid = $$props.uuid);
    		if ('cmd' in $$props) $$invalidate(26, cmd = $$props.cmd);
    		if ('sub' in $$props) $$invalidate(27, sub = $$props.sub);
    		if ('opt' in $$props) $$invalidate(28, opt = $$props.opt);
    		if ('self' in $$props) $$invalidate(29, self = $$props.self);
    		if ('bounce' in $$props) $$invalidate(30, bounce = $$props.bounce);
    		if ('first' in $$props) $$invalidate(31, first = $$props.first);
    		if ('cond' in $$props) $$invalidate(32, cond = $$props.cond);
    		if ('does' in $$props) $$invalidate(33, does = $$props.does);
    		if ('global' in $$props) $$invalidate(1, global = $$props.global);
    		if ('nored' in $$props) $$invalidate(34, nored = $$props.nored);
    		if ('nolink' in $$props) $$invalidate(2, nolink = $$props.nolink);
    		if ('disable' in $$props) $$invalidate(3, disable = $$props.disable);
    		if ('silent' in $$props) $$invalidate(35, silent = $$props.silent);
    		if ('marked' in $$props) $$invalidate(4, marked = $$props.marked);
    		if ('c' in $$props) $$invalidate(36, c = $$props.c);
    		if ('current' in $$props) $$invalidate(0, current = $$props.current);
    		if ('info' in $$props) $$invalidate(37, info = $$props.info);
    		if ('dbg' in $$props) $$invalidate(5, dbg = $$props.dbg);
    		if ('href' in $$props) $$invalidate(6, href = $$props.href);
    		if ('ident' in $$props) $$invalidate(39, ident = $$props.ident);
    		if ('text' in $$props) $$invalidate(7, text = $$props.text);
    		if ('reddable' in $$props) $$invalidate(40, reddable = $$props.reddable);
    		if ('scratch' in $$props) scratch = $$props.scratch;
    		if ('special' in $$props) $$invalidate(41, special = $$props.special);
    		if ('cls' in $$props) $$invalidate(8, cls = $$props.cls);
    		if ('rinfo' in $$props) $$invalidate(9, rinfo = $$props.rinfo);
    		if ('registered' in $$props) registered = $$props.registered;
    		if ('addr' in $$props) $$invalidate(21, addr = $$props.addr);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*self, space, title, uuid, cmd, sub, opt, global, nolink, disable, bounce, nst*/ 2143289358 | $$self.$$.dirty[1] & /*$loc*/ 8192) {
    			if (self) {
    				mkhref();
    			} else {
    				mkhref();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*href*/ 64 | $$self.$$.dirty[1] & /*$path*/ 4096) {
    			$$invalidate(0, current = $path == href);
    		}

    		if ($$self.$$.dirty[0] & /*nolink, bounce, self, global, current*/ 1610612743 | $$self.$$.dirty[1] & /*special, silent, nored*/ 1048) {
    			if (!special && !nolink && !bounce && !self && !global && !silent && !current && !nored) {
    				$$invalidate(40, reddable = true);
    			} else {
    				$$invalidate(40, reddable = false);
    			}
    		}

    		if ($$self.$$.dirty[1] & /*ident, reddable*/ 768) {
    			register();
    		}

    		if ($$self.$$.dirty[0] & /*disable, nolink, current*/ 13 | $$self.$$.dirty[1] & /*reddable, silent, $linkmap, ident*/ 2832) {
    			mkcls(reddable, silent, disable, nolink, current, !!$linkmap.val && !!$linkmap.val[ident]);
    		}
    	};

    	return [
    		current,
    		global,
    		nolink,
    		disable,
    		marked,
    		dbg,
    		href,
    		text,
    		cls,
    		rinfo,
    		gs,
    		rc,
    		trail,
    		path,
    		links,
    		linkmap,
    		haslogin,
    		session,
    		loc,
    		clicked,
    		$$slots,
    		addr,
    		nst,
    		space,
    		title,
    		uuid,
    		cmd,
    		sub,
    		opt,
    		self,
    		bounce,
    		first,
    		cond,
    		does,
    		nored,
    		silent,
    		c,
    		info,
    		trigger,
    		ident,
    		reddable,
    		special,
    		$linkmap,
    		$path,
    		$loc,
    		$$scope,
    		slots
    	];
    }

    class Link$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$1J,
    			create_fragment$1J,
    			safe_not_equal,
    			{
    				nst: 22,
    				space: 23,
    				title: 24,
    				uuid: 25,
    				cmd: 26,
    				sub: 27,
    				opt: 28,
    				self: 29,
    				bounce: 30,
    				first: 31,
    				cond: 32,
    				does: 33,
    				global: 1,
    				nored: 34,
    				nolink: 2,
    				disable: 3,
    				silent: 35,
    				marked: 4,
    				c: 36,
    				current: 0,
    				info: 37,
    				dbg: 5,
    				addr: 21,
    				trigger: 38
    			},
    			null,
    			[-1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Link",
    			options,
    			id: create_fragment$1J.name
    		});
    	}

    	get nst() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nst(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get space() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set space(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get uuid() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set uuid(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cmd() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cmd(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sub() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sub(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opt() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opt(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get self() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set self(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bounce() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bounce(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get first() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set first(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cond() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cond(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get does() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set does(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get global() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set global(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nored() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nored(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nolink() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nolink(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disable() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disable(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get silent() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set silent(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get marked() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set marked(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get c() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set c(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get current() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set current(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get info() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set info(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dbg() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dbg(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addr() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addr(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trigger() {
    		return this.$$.ctx[38];
    	}

    	set trigger(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/FB.svelte generated by Svelte v3.44.3 */

    const { Object: Object_1$5 } = globals;
    const file$Y = "src/FB.svelte";

    // (125:0) {:else}
    function create_else_block$r(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[37].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[40], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", /*cf*/ ctx[4]);
    			attr_dev(div, "style", /*css*/ ctx[5]);
    			add_location(div, file$Y, 125, 2, 2811);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[39](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[40],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[40])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[40], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty[0] & /*cf*/ 16) {
    				attr_dev(div, "class", /*cf*/ ctx[4]);
    			}

    			if (!current || dirty[0] & /*css*/ 32) {
    				attr_dev(div, "style", /*css*/ ctx[5]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[39](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$r.name,
    		type: "else",
    		source: "(125:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (119:0) {#if vc || ve}
    function create_if_block$V(ctx) {
    	let fb;
    	let updating_element;
    	let current;

    	function fb_element_binding(value) {
    		/*fb_element_binding*/ ctx[38](value);
    	}

    	let fb_props = {
    		expand: /*expand*/ ctx[0],
    		vert: true,
    		center: /*vc*/ ctx[2],
    		end: /*ve*/ ctx[3],
    		style: /*css*/ ctx[5],
    		$$slots: { default: [create_default_slot$17] },
    		$$scope: { ctx }
    	};

    	if (/*element*/ ctx[1] !== void 0) {
    		fb_props.element = /*element*/ ctx[1];
    	}

    	fb = new FB({ props: fb_props, $$inline: true });
    	binding_callbacks.push(() => bind(fb, 'element', fb_element_binding));

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};
    			if (dirty[0] & /*expand*/ 1) fb_changes.expand = /*expand*/ ctx[0];
    			if (dirty[0] & /*vc*/ 4) fb_changes.center = /*vc*/ ctx[2];
    			if (dirty[0] & /*ve*/ 8) fb_changes.end = /*ve*/ ctx[3];
    			if (dirty[0] & /*css*/ 32) fb_changes.style = /*css*/ ctx[5];

    			if (dirty[0] & /*cf*/ 16 | dirty[1] & /*$$scope*/ 512) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty[0] & /*element*/ 2) {
    				updating_element = true;
    				fb_changes.element = /*element*/ ctx[1];
    				add_flush_callback(() => updating_element = false);
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$V.name,
    		type: "if",
    		source: "(119:0) {#if vc || ve}",
    		ctx
    	});

    	return block;
    }

    // (120:2) <svelte:self {expand} vert center={vc} end={ve} bind:element={element} style={css}>
    function create_default_slot$17(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[37].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[40], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", /*cf*/ ctx[4]);
    			add_location(div, file$Y, 120, 4, 2736);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[40],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[40])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[40], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty[0] & /*cf*/ 16) {
    				attr_dev(div, "class", /*cf*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$17.name,
    		type: "slot",
    		source: "(120:2) <svelte:self {expand} vert center={vc} end={ve} bind:element={element} style={css}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1I(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$V, create_else_block$r];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*vc*/ ctx[2] || /*ve*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1I($$self, $$props, $$invalidate) {
    	let css;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FB', slots, ['default']);
    	let { c = [] } = $$props;
    	let { expand = false } = $$props;
    	let { solid = false } = $$props;
    	let { exo = false } = $$props;
    	let { vert = false } = $$props;
    	let { leaf = false } = $$props;
    	let { form = false } = $$props;
    	let { flip = false } = $$props;
    	let { zero = false } = $$props;
    	let { center = false } = $$props;
    	let { between = false } = $$props;
    	let { around = false } = $$props;
    	let { hide = false } = $$props;
    	let { ghost = false } = $$props;
    	let { w = null } = $$props;
    	let { wr = null } = $$props;
    	let { spacer = null } = $$props;
    	let { line = false } = $$props;
    	let { grid = false } = $$props;
    	let { end = false } = $$props;
    	let { just = false } = $$props;
    	let { fw = false } = $$props;
    	let { lw = false } = $$props;
    	let { rel = false } = $$props;
    	let { abs = false } = $$props;
    	let { wrap = false } = $$props;
    	let { title = false } = $$props;
    	let { mono = false } = $$props;
    	let { reverse = false } = $$props;
    	let { flex = false } = $$props;
    	let { vc = false } = $$props;
    	let { ve = false } = $$props;
    	let { style = {} } = $$props;
    	let cf = '';
    	let cc;
    	let { element = null } = $$props;

    	const writable_props = [
    		'c',
    		'expand',
    		'solid',
    		'exo',
    		'vert',
    		'leaf',
    		'form',
    		'flip',
    		'zero',
    		'center',
    		'between',
    		'around',
    		'hide',
    		'ghost',
    		'w',
    		'wr',
    		'spacer',
    		'line',
    		'grid',
    		'end',
    		'just',
    		'fw',
    		'lw',
    		'rel',
    		'abs',
    		'wrap',
    		'title',
    		'mono',
    		'reverse',
    		'flex',
    		'vc',
    		've',
    		'style',
    		'element'
    	];

    	Object_1$5.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FB> was created with unknown prop '${key}'`);
    	});

    	function fb_element_binding(value) {
    		element = value;
    		$$invalidate(1, element);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(1, element);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('c' in $$props) $$invalidate(7, c = $$props.c);
    		if ('expand' in $$props) $$invalidate(0, expand = $$props.expand);
    		if ('solid' in $$props) $$invalidate(6, solid = $$props.solid);
    		if ('exo' in $$props) $$invalidate(8, exo = $$props.exo);
    		if ('vert' in $$props) $$invalidate(9, vert = $$props.vert);
    		if ('leaf' in $$props) $$invalidate(10, leaf = $$props.leaf);
    		if ('form' in $$props) $$invalidate(11, form = $$props.form);
    		if ('flip' in $$props) $$invalidate(12, flip = $$props.flip);
    		if ('zero' in $$props) $$invalidate(13, zero = $$props.zero);
    		if ('center' in $$props) $$invalidate(14, center = $$props.center);
    		if ('between' in $$props) $$invalidate(15, between = $$props.between);
    		if ('around' in $$props) $$invalidate(16, around = $$props.around);
    		if ('hide' in $$props) $$invalidate(17, hide = $$props.hide);
    		if ('ghost' in $$props) $$invalidate(18, ghost = $$props.ghost);
    		if ('w' in $$props) $$invalidate(19, w = $$props.w);
    		if ('wr' in $$props) $$invalidate(20, wr = $$props.wr);
    		if ('spacer' in $$props) $$invalidate(21, spacer = $$props.spacer);
    		if ('line' in $$props) $$invalidate(22, line = $$props.line);
    		if ('grid' in $$props) $$invalidate(23, grid = $$props.grid);
    		if ('end' in $$props) $$invalidate(24, end = $$props.end);
    		if ('just' in $$props) $$invalidate(25, just = $$props.just);
    		if ('fw' in $$props) $$invalidate(26, fw = $$props.fw);
    		if ('lw' in $$props) $$invalidate(27, lw = $$props.lw);
    		if ('rel' in $$props) $$invalidate(28, rel = $$props.rel);
    		if ('abs' in $$props) $$invalidate(29, abs = $$props.abs);
    		if ('wrap' in $$props) $$invalidate(30, wrap = $$props.wrap);
    		if ('title' in $$props) $$invalidate(31, title = $$props.title);
    		if ('mono' in $$props) $$invalidate(32, mono = $$props.mono);
    		if ('reverse' in $$props) $$invalidate(33, reverse = $$props.reverse);
    		if ('flex' in $$props) $$invalidate(34, flex = $$props.flex);
    		if ('vc' in $$props) $$invalidate(2, vc = $$props.vc);
    		if ('ve' in $$props) $$invalidate(3, ve = $$props.ve);
    		if ('style' in $$props) $$invalidate(35, style = $$props.style);
    		if ('element' in $$props) $$invalidate(1, element = $$props.element);
    		if ('$$scope' in $$props) $$invalidate(40, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		c,
    		expand,
    		solid,
    		exo,
    		vert,
    		leaf,
    		form,
    		flip,
    		zero,
    		center,
    		between,
    		around,
    		hide,
    		ghost,
    		w,
    		wr,
    		spacer,
    		line,
    		grid,
    		end,
    		just,
    		fw,
    		lw,
    		rel,
    		abs,
    		wrap,
    		title,
    		mono,
    		reverse,
    		flex,
    		vc,
    		ve,
    		style,
    		cf,
    		cc,
    		element,
    		css
    	});

    	$$self.$inject_state = $$props => {
    		if ('c' in $$props) $$invalidate(7, c = $$props.c);
    		if ('expand' in $$props) $$invalidate(0, expand = $$props.expand);
    		if ('solid' in $$props) $$invalidate(6, solid = $$props.solid);
    		if ('exo' in $$props) $$invalidate(8, exo = $$props.exo);
    		if ('vert' in $$props) $$invalidate(9, vert = $$props.vert);
    		if ('leaf' in $$props) $$invalidate(10, leaf = $$props.leaf);
    		if ('form' in $$props) $$invalidate(11, form = $$props.form);
    		if ('flip' in $$props) $$invalidate(12, flip = $$props.flip);
    		if ('zero' in $$props) $$invalidate(13, zero = $$props.zero);
    		if ('center' in $$props) $$invalidate(14, center = $$props.center);
    		if ('between' in $$props) $$invalidate(15, between = $$props.between);
    		if ('around' in $$props) $$invalidate(16, around = $$props.around);
    		if ('hide' in $$props) $$invalidate(17, hide = $$props.hide);
    		if ('ghost' in $$props) $$invalidate(18, ghost = $$props.ghost);
    		if ('w' in $$props) $$invalidate(19, w = $$props.w);
    		if ('wr' in $$props) $$invalidate(20, wr = $$props.wr);
    		if ('spacer' in $$props) $$invalidate(21, spacer = $$props.spacer);
    		if ('line' in $$props) $$invalidate(22, line = $$props.line);
    		if ('grid' in $$props) $$invalidate(23, grid = $$props.grid);
    		if ('end' in $$props) $$invalidate(24, end = $$props.end);
    		if ('just' in $$props) $$invalidate(25, just = $$props.just);
    		if ('fw' in $$props) $$invalidate(26, fw = $$props.fw);
    		if ('lw' in $$props) $$invalidate(27, lw = $$props.lw);
    		if ('rel' in $$props) $$invalidate(28, rel = $$props.rel);
    		if ('abs' in $$props) $$invalidate(29, abs = $$props.abs);
    		if ('wrap' in $$props) $$invalidate(30, wrap = $$props.wrap);
    		if ('title' in $$props) $$invalidate(31, title = $$props.title);
    		if ('mono' in $$props) $$invalidate(32, mono = $$props.mono);
    		if ('reverse' in $$props) $$invalidate(33, reverse = $$props.reverse);
    		if ('flex' in $$props) $$invalidate(34, flex = $$props.flex);
    		if ('vc' in $$props) $$invalidate(2, vc = $$props.vc);
    		if ('ve' in $$props) $$invalidate(3, ve = $$props.ve);
    		if ('style' in $$props) $$invalidate(35, style = $$props.style);
    		if ('cf' in $$props) $$invalidate(4, cf = $$props.cf);
    		if ('cc' in $$props) $$invalidate(36, cc = $$props.cc);
    		if ('element' in $$props) $$invalidate(1, element = $$props.element);
    		if ('css' in $$props) $$invalidate(5, css = $$props.css);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[1] & /*style*/ 16) {
    			$$invalidate(5, css = Object.entries(style).map(p => `${p[0]}: ${p[1]};`).join(''));
    		}

    		if ($$self.$$.dirty[0] & /*exo*/ 256) {
    			if (exo) {
    				$$invalidate(0, expand = true);
    				$$invalidate(6, solid = true);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*c, expand, vc, ve, solid, vert, flip, leaf, form, zero, just, center, between, around, end, hide, ghost, w, wr, fw, lw, spacer, rel, abs, wrap, line, grid*/ 2147483341 | $$self.$$.dirty[1] & /*cc, flex, title, mono, reverse*/ 47) {
    			{
    				$$invalidate(36, cc = c);
    				if (typeof cc == 'string') $$invalidate(36, cc = cc.split(' '));
    				if (expand && !(vc || ve)) cc.push('fb-expand');
    				if (solid) cc.push('fb-solid');
    				if (flex) cc.push('fb-flex');
    				if (vert) cc.push('fb-vert'); else cc.push('fb-hori');
    				if (flip) cc.push('fb-flip'); else cc.push('fb-norm');
    				if (!leaf) cc.push('fb-box');
    				if (form) cc.push('fb-form');
    				if (zero) cc.push('fb-zero'); else cc.push('fb-grid');

    				if (just) {
    					if (just == 'c') cc.push('fb-center'); else if (just == 'b') cc.push('fb-between'); else if (just == 'a') cc.push('fb-around'); else if (just == 'e') cc.push('fb-end'); else cc.push('fb-start');
    				} else {
    					if (center) cc.push('fb-center'); else if (between) cc.push('fb-between'); else if (around) cc.push('fb-around'); else if (end) cc.push('fb-end'); else cc.push('fb-start');
    				}

    				if (hide) cc.push('hidden');
    				if (ghost) cc.push('ghost');
    				if (w) cc.push(`w${w}`);
    				if (wr) cc.push(`wr${wr}`);
    				if (fw) cc.push(`fw${fw}`);
    				if (lw) cc.push(`lw${lw}`);
    				if (spacer) cc.push(`spacer${spacer}`);
    				if (rel) cc.push('fb-rel');
    				if (abs) cc.push('fb-abs');
    				if (wrap) cc.push('fb-wrap');

    				if (line) {
    					cc.push('fd-line');
    					const n = typeof line != 'string' ? 'n' : line;
    					cc.push(`ln-${n}`);
    				}

    				if (grid) {
    					cc.push('gr');
    					cc.push(`gr${grid}`);
    				}

    				if (title) cc.push('fb-title');
    				if (mono) cc.push('fb-mono');
    				if (reverse) cc.push('fb-reverse');
    				cc.push('flexbox');
    				$$invalidate(4, cf = cc.join(' '));
    			}
    		}
    	};

    	return [
    		expand,
    		element,
    		vc,
    		ve,
    		cf,
    		css,
    		solid,
    		c,
    		exo,
    		vert,
    		leaf,
    		form,
    		flip,
    		zero,
    		center,
    		between,
    		around,
    		hide,
    		ghost,
    		w,
    		wr,
    		spacer,
    		line,
    		grid,
    		end,
    		just,
    		fw,
    		lw,
    		rel,
    		abs,
    		wrap,
    		title,
    		mono,
    		reverse,
    		flex,
    		style,
    		cc,
    		slots,
    		fb_element_binding,
    		div_binding,
    		$$scope
    	];
    }

    class FB extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$1I,
    			create_fragment$1I,
    			safe_not_equal,
    			{
    				c: 7,
    				expand: 0,
    				solid: 6,
    				exo: 8,
    				vert: 9,
    				leaf: 10,
    				form: 11,
    				flip: 12,
    				zero: 13,
    				center: 14,
    				between: 15,
    				around: 16,
    				hide: 17,
    				ghost: 18,
    				w: 19,
    				wr: 20,
    				spacer: 21,
    				line: 22,
    				grid: 23,
    				end: 24,
    				just: 25,
    				fw: 26,
    				lw: 27,
    				rel: 28,
    				abs: 29,
    				wrap: 30,
    				title: 31,
    				mono: 32,
    				reverse: 33,
    				flex: 34,
    				vc: 2,
    				ve: 3,
    				style: 35,
    				element: 1
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FB",
    			options,
    			id: create_fragment$1I.name
    		});
    	}

    	get c() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set c(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expand() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expand(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get solid() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set solid(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get exo() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set exo(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vert() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vert(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get leaf() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set leaf(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get form() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set form(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flip() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flip(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zero() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zero(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get center() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set center(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get between() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set between(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get around() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set around(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hide() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hide(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ghost() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ghost(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get w() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set w(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wr() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wr(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get spacer() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set spacer(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get line() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set line(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get grid() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set grid(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get end() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set end(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get just() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set just(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fw() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fw(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lw() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lw(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rel() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rel(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get abs() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set abs(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrap() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrap(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mono() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mono(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get reverse() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set reverse(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flex() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flex(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vc() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vc(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ve() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ve(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get element() {
    		throw new Error("<FB>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<FB>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/FP.svelte generated by Svelte v3.44.3 */
    const file$X = "src/FP.svelte";

    // (12:2) {#if block}
    function create_if_block$U(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block_1 = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "fp-item");
    			add_location(div, file$X, 11, 13, 247);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block$U.name,
    		type: "if",
    		source: "(12:2) {#if block}",
    		ctx
    	});

    	return block_1;
    }

    // (10:0) <FB {c}>
    function create_default_slot$16(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let if_block_anchor;
    	let current;
    	let if_block = /*block*/ ctx[2] && create_if_block$U(ctx);

    	const block_1 = {
    		c: function create() {
    			div = element("div");
    			t0 = text(/*lab*/ ctx[1]);
    			t1 = text(":");
    			t2 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    			attr_dev(div, "class", "fp-label");
    			add_location(div, file$X, 10, 2, 199);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			insert_dev(target, t2, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*lab*/ 2) set_data_dev(t0, /*lab*/ ctx[1]);

    			if (/*block*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*block*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$U(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t2);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_default_slot$16.name,
    		type: "slot",
    		source: "(10:0) <FB {c}>",
    		ctx
    	});

    	return block_1;
    }

    function create_fragment$1H(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: /*c*/ ctx[0],
    				$$slots: { default: [create_default_slot$16] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block_1 = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*c*/ 1) fb_changes.c = /*c*/ ctx[0];

    			if (dirty & /*$$scope, block, lab*/ 22) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_fragment$1H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block_1;
    }

    function instance$1H($$self, $$props, $$invalidate) {
    	let block;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FP', slots, ['default']);
    	const $$slots = compute_slots(slots);
    	let { lab = '' } = $$props;
    	let { c = [] } = $$props;
    	if (typeof c == 'string') c = c.split(' ');
    	c.push('fp-pair');
    	const writable_props = ['lab', 'c'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FP> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('lab' in $$props) $$invalidate(1, lab = $$props.lab);
    		if ('c' in $$props) $$invalidate(0, c = $$props.c);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ FB, lab, c, block });

    	$$self.$inject_state = $$props => {
    		if ('lab' in $$props) $$invalidate(1, lab = $$props.lab);
    		if ('c' in $$props) $$invalidate(0, c = $$props.c);
    		if ('block' in $$props) $$invalidate(2, block = $$props.block);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$invalidate(2, block = $$slots.default);
    	return [c, lab, block, slots, $$scope];
    }

    class FP extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1H, create_fragment$1H, safe_not_equal, { lab: 1, c: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FP",
    			options,
    			id: create_fragment$1H.name
    		});
    	}

    	get lab() {
    		throw new Error("<FP>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lab(value) {
    		throw new Error("<FP>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get c() {
    		throw new Error("<FP>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set c(value) {
    		throw new Error("<FP>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/PP.svelte generated by Svelte v3.44.3 */
    const file$W = "src/PP.svelte";

    // (25:2) {#if lab}
    function create_if_block$T(ctx) {
    	let div;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(/*lab*/ ctx[0]);
    			t1 = text(":");
    			attr_dev(div, "class", "fp-label");
    			add_location(div, file$W, 24, 11, 586);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*lab*/ 1) set_data_dev(t0, /*lab*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$T.name,
    		type: "if",
    		source: "(25:2) {#if lab}",
    		ctx
    	});

    	return block;
    }

    // (24:0) <FB c={cc}>
    function create_default_slot$15(ctx) {
    	let t0;
    	let div;
    	let t1_value = JSON.stringify(/*val*/ ctx[1]) + "";
    	let t1;
    	let if_block = /*lab*/ ctx[0] && create_if_block$T(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			div = element("div");
    			t1 = text(t1_value);
    			attr_dev(div, "class", "fp-item");
    			add_location(div, file$W, 25, 2, 628);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (/*lab*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$T(ctx);
    					if_block.c();
    					if_block.m(t0.parentNode, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*val*/ 2 && t1_value !== (t1_value = JSON.stringify(/*val*/ ctx[1]) + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$15.name,
    		type: "slot",
    		source: "(24:0) <FB c={cc}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1G(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: /*cc*/ ctx[2],
    				$$slots: { default: [create_default_slot$15] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*cc*/ 4) fb_changes.c = /*cc*/ ctx[2];

    			if (dirty & /*$$scope, val, lab*/ 131) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1G($$self, $$props, $$invalidate) {
    	let state;
    	let cc;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PP', slots, []);
    	let { lab = null } = $$props;
    	let { t = null } = $$props;
    	let { val } = $$props;
    	let { c = [] } = $$props;

    	const type = v => {
    		let t;

    		if (typeof v == 'boolean') t = v ? 'true' : 'false'; else if (v === null) t = 'null'; else if (typeof v == 'string') {
    			if (v.length) t = 'string-full'; else t = 'string-empty';
    		} else t = typeof v;

    		return t;
    	};

    	if (typeof c == 'string') c = c.split(' ');
    	c.push('fp-pair');
    	c.push('fp-cond');
    	const writable_props = ['lab', 't', 'val', 'c'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PP> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('lab' in $$props) $$invalidate(0, lab = $$props.lab);
    		if ('t' in $$props) $$invalidate(4, t = $$props.t);
    		if ('val' in $$props) $$invalidate(1, val = $$props.val);
    		if ('c' in $$props) $$invalidate(3, c = $$props.c);
    	};

    	$$self.$capture_state = () => ({ FB, lab, t, val, c, type, state, cc });

    	$$self.$inject_state = $$props => {
    		if ('lab' in $$props) $$invalidate(0, lab = $$props.lab);
    		if ('t' in $$props) $$invalidate(4, t = $$props.t);
    		if ('val' in $$props) $$invalidate(1, val = $$props.val);
    		if ('c' in $$props) $$invalidate(3, c = $$props.c);
    		if ('state' in $$props) $$invalidate(5, state = $$props.state);
    		if ('cc' in $$props) $$invalidate(2, cc = $$props.cc);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*t, val*/ 18) {
    			$$invalidate(5, state = t ? type(t(val)) : type(val));
    		}

    		if ($$self.$$.dirty & /*c, state*/ 40) {
    			$$invalidate(2, cc = [...c, 'pp-' + state]);
    		}
    	};

    	return [lab, val, cc, c, t, state];
    }

    class PP extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1G, create_fragment$1G, safe_not_equal, { lab: 0, t: 4, val: 1, c: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PP",
    			options,
    			id: create_fragment$1G.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*val*/ ctx[1] === undefined && !('val' in props)) {
    			console.warn("<PP> was created without expected prop 'val'");
    		}
    	}

    	get lab() {
    		throw new Error("<PP>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lab(value) {
    		throw new Error("<PP>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get t() {
    		throw new Error("<PP>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set t(value) {
    		throw new Error("<PP>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get val() {
    		throw new Error("<PP>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set val(value) {
    		throw new Error("<PP>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get c() {
    		throw new Error("<PP>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set c(value) {
    		throw new Error("<PP>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/FR.svelte generated by Svelte v3.44.3 */

    // (12:2) {#if haslab}
    function create_if_block$S(ctx) {
    	let fp;
    	let current;

    	fp = new FP({
    			props: { c: "fp-metalabel", lab: /*lab*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fp_changes = {};
    			if (dirty & /*lab*/ 2) fp_changes.lab = /*lab*/ ctx[1];
    			fp.$set(fp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$S.name,
    		type: "if",
    		source: "(12:2) {#if haslab}",
    		ctx
    	});

    	return block;
    }

    // (11:0) <FB {c}>
    function create_default_slot$14(ctx) {
    	let t;
    	let current;
    	let if_block = /*haslab*/ ctx[2] && create_if_block$S(ctx);
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*haslab*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*haslab*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$S(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$14.name,
    		type: "slot",
    		source: "(11:0) <FB {c}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1F(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: /*c*/ ctx[0],
    				$$slots: { default: [create_default_slot$14] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*c*/ 1) fb_changes.c = /*c*/ ctx[0];

    			if (dirty & /*$$scope, lab, haslab*/ 22) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1F($$self, $$props, $$invalidate) {
    	let haslab;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FR', slots, ['default']);
    	let { lab = '' } = $$props;
    	let { c = [] } = $$props;
    	if (typeof c == 'string') c = c.split(' ');
    	c.push('fp-run');
    	const writable_props = ['lab', 'c'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FR> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('lab' in $$props) $$invalidate(1, lab = $$props.lab);
    		if ('c' in $$props) $$invalidate(0, c = $$props.c);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ FB, FP, lab, c, haslab });

    	$$self.$inject_state = $$props => {
    		if ('lab' in $$props) $$invalidate(1, lab = $$props.lab);
    		if ('c' in $$props) $$invalidate(0, c = $$props.c);
    		if ('haslab' in $$props) $$invalidate(2, haslab = $$props.haslab);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*lab*/ 2) {
    			$$invalidate(2, haslab = typeof lab == 'string' && lab.length);
    		}
    	};

    	return [c, lab, haslab, slots, $$scope];
    }

    class FR extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1F, create_fragment$1F, safe_not_equal, { lab: 1, c: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FR",
    			options,
    			id: create_fragment$1F.name
    		});
    	}

    	get lab() {
    		throw new Error("<FR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lab(value) {
    		throw new Error("<FR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get c() {
    		throw new Error("<FR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set c(value) {
    		throw new Error("<FR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/FT.svelte generated by Svelte v3.44.3 */

    // (8:0) <FB {c}>
    function create_default_slot$13(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$13.name,
    		type: "slot",
    		source: "(8:0) <FB {c}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1E(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: /*c*/ ctx[0],
    				$$slots: { default: [create_default_slot$13] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*c*/ 1) fb_changes.c = /*c*/ ctx[0];

    			if (dirty & /*$$scope*/ 4) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FT', slots, ['default']);
    	let { c = [] } = $$props;
    	if (typeof c == 'string') c = c.split(' ');
    	c.push('fp-table');
    	const writable_props = ['c'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FT> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('c' in $$props) $$invalidate(0, c = $$props.c);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ FB, c });

    	$$self.$inject_state = $$props => {
    		if ('c' in $$props) $$invalidate(0, c = $$props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [c, slots, $$scope];
    }

    class FT extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1E, create_fragment$1E, safe_not_equal, { c: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FT",
    			options,
    			id: create_fragment$1E.name
    		});
    	}

    	get c() {
    		throw new Error("<FT>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set c(value) {
    		throw new Error("<FT>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/LocRO.svelte generated by Svelte v3.44.3 */

    const { Object: Object_1$4 } = globals;

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (17:4) {:else}
    function create_else_block$q(ctx) {
    	let pp;
    	let current;

    	pp = new PP({
    			props: {
    				lab: /*item*/ ctx[2][0],
    				val: /*item*/ ctx[2][1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp_changes = {};
    			if (dirty & /*$loc*/ 1) pp_changes.lab = /*item*/ ctx[2][0];
    			if (dirty & /*$loc*/ 1) pp_changes.val = /*item*/ ctx[2][1];
    			pp.$set(pp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$q.name,
    		type: "else",
    		source: "(17:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (11:4) {#if item[0] == 'opt' && Object.entries(item[1]).length}
    function create_if_block$R(ctx) {
    	let fr;
    	let current;

    	fr = new FR({
    			props: {
    				lab: "opt",
    				$$slots: { default: [create_default_slot_1$G] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fr.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fr, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fr_changes = {};

    			if (dirty & /*$$scope, $loc*/ 257) {
    				fr_changes.$$scope = { dirty, ctx };
    			}

    			fr.$set(fr_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fr.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fr.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fr, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$R.name,
    		type: "if",
    		source: "(11:4) {#if item[0] == 'opt' && Object.entries(item[1]).length}",
    		ctx
    	});

    	return block;
    }

    // (13:6) {#each Object.entries(item[1]) as i}
    function create_each_block_1$6(ctx) {
    	let pp;
    	let current;

    	pp = new PP({
    			props: {
    				lab: /*i*/ ctx[5][0],
    				val: /*i*/ ctx[5][1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp_changes = {};
    			if (dirty & /*$loc*/ 1) pp_changes.lab = /*i*/ ctx[5][0];
    			if (dirty & /*$loc*/ 1) pp_changes.val = /*i*/ ctx[5][1];
    			pp.$set(pp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$6.name,
    		type: "each",
    		source: "(13:6) {#each Object.entries(item[1]) as i}",
    		ctx
    	});

    	return block;
    }

    // (12:6) <FR lab="opt">
    function create_default_slot_1$G(ctx) {
    	let t;
    	let current;
    	let each_value_1 = Object.entries(/*item*/ ctx[2][1]);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Object, $loc*/ 1) {
    				each_value_1 = Object.entries(/*item*/ ctx[2][1]);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$6(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$G.name,
    		type: "slot",
    		source: "(12:6) <FR lab=\\\"opt\\\">",
    		ctx
    	});

    	return block;
    }

    // (10:2) {#each Object.entries($loc) as item}
    function create_each_block$f(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$R, create_else_block$q];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (show_if == null || dirty & /*$loc*/ 1) show_if = !!(/*item*/ ctx[2][0] == 'opt' && Object.entries(/*item*/ ctx[2][1]).length);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(10:2) {#each Object.entries($loc) as item}",
    		ctx
    	});

    	return block;
    }

    // (9:0) <FR lab="loc">
    function create_default_slot$12(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = Object.entries(/*$loc*/ ctx[0]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Object, $loc*/ 1) {
    				each_value = Object.entries(/*$loc*/ ctx[0]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$12.name,
    		type: "slot",
    		source: "(9:0) <FR lab=\\\"loc\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1D(ctx) {
    	let t;
    	let fr;
    	let current;

    	fr = new FR({
    			props: {
    				lab: "loc",
    				$$slots: { default: [create_default_slot$12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = text("c\n\n");
    			create_component(fr.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			mount_component(fr, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fr_changes = {};

    			if (dirty & /*$$scope, $loc*/ 257) {
    				fr_changes.$$scope = { dirty, ctx };
    			}

    			fr.$set(fr_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fr.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fr.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_component(fr, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1D($$self, $$props, $$invalidate) {
    	let $loc;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LocRO', slots, []);
    	const loc = getContext('loc');
    	validate_store(loc, 'loc');
    	component_subscribe($$self, loc, value => $$invalidate(0, $loc = value));
    	const writable_props = [];

    	Object_1$4.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LocRO> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ FP, PP, FR, getContext, loc, $loc });
    	return [$loc, loc];
    }

    class LocRO extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1D, create_fragment$1D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LocRO",
    			options,
    			id: create_fragment$1D.name
    		});
    	}
    }

    /* src/SessRO.svelte generated by Svelte v3.44.3 */

    // (10:0) {#if $hassess}
    function create_if_block$Q(ctx) {
    	let fr;
    	let current;

    	fr = new FR({
    			props: {
    				lab: "session",
    				$$slots: { default: [create_default_slot$11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fr.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fr, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fr_changes = {};

    			if (dirty & /*$$scope, $session*/ 18) {
    				fr_changes.$$scope = { dirty, ctx };
    			}

    			fr.$set(fr_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fr.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fr.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fr, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$Q.name,
    		type: "if",
    		source: "(10:0) {#if $hassess}",
    		ctx
    	});

    	return block;
    }

    // (11:0) <FR lab="session">
    function create_default_slot$11(ctx) {
    	let pp0;
    	let t0;
    	let pp1;
    	let t1;
    	let pp2;
    	let current;

    	pp0 = new PP({
    			props: {
    				lab: "uuid",
    				val: /*$session*/ ctx[1].val.uuid
    			},
    			$$inline: true
    		});

    	pp1 = new PP({
    			props: {
    				lab: "login",
    				val: /*$session*/ ctx[1].val.login
    			},
    			$$inline: true
    		});

    	pp2 = new PP({
    			props: {
    				lab: "handle",
    				val: /*$session*/ ctx[1].val.handle
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp0.$$.fragment);
    			t0 = space();
    			create_component(pp1.$$.fragment);
    			t1 = space();
    			create_component(pp2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(pp1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(pp2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp0_changes = {};
    			if (dirty & /*$session*/ 2) pp0_changes.val = /*$session*/ ctx[1].val.uuid;
    			pp0.$set(pp0_changes);
    			const pp1_changes = {};
    			if (dirty & /*$session*/ 2) pp1_changes.val = /*$session*/ ctx[1].val.login;
    			pp1.$set(pp1_changes);
    			const pp2_changes = {};
    			if (dirty & /*$session*/ 2) pp2_changes.val = /*$session*/ ctx[1].val.handle;
    			pp2.$set(pp2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp0.$$.fragment, local);
    			transition_in(pp1.$$.fragment, local);
    			transition_in(pp2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp0.$$.fragment, local);
    			transition_out(pp1.$$.fragment, local);
    			transition_out(pp2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(pp1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(pp2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$11.name,
    		type: "slot",
    		source: "(11:0) <FR lab=\\\"session\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1C(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$hassess*/ ctx[0] && create_if_block$Q(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$hassess*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$hassess*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$Q(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1C($$self, $$props, $$invalidate) {
    	let $hassess;
    	let $session;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SessRO', slots, []);
    	const hassess = getContext('hassess');
    	validate_store(hassess, 'hassess');
    	component_subscribe($$self, hassess, value => $$invalidate(0, $hassess = value));
    	const session = getContext('session');
    	validate_store(session, 'session');
    	component_subscribe($$self, session, value => $$invalidate(1, $session = value));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SessRO> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		FP,
    		PP,
    		FR,
    		getContext,
    		hassess,
    		session,
    		$hassess,
    		$session
    	});

    	return [$hassess, $session, hassess, session];
    }

    class SessRO extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1C, create_fragment$1C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SessRO",
    			options,
    			id: create_fragment$1C.name
    		});
    	}
    }

    /* src/RespRO.svelte generated by Svelte v3.44.3 */

    // (19:0) {:else}
    function create_else_block$p(ctx) {
    	let pp;
    	let current;

    	pp = new PP({
    			props: { lab: /*lab*/ ctx[0], val: /*r*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp_changes = {};
    			if (dirty & /*lab*/ 1) pp_changes.lab = /*lab*/ ctx[0];
    			if (dirty & /*r*/ 4) pp_changes.val = /*r*/ ctx[2];
    			pp.$set(pp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$p.name,
    		type: "else",
    		source: "(19:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (11:0) {#if h}
    function create_if_block$P(ctx) {
    	let fr;
    	let current;

    	fr = new FR({
    			props: {
    				lab: /*lab*/ ctx[0],
    				$$slots: { default: [create_default_slot$10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fr.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fr, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fr_changes = {};
    			if (dirty & /*lab*/ 1) fr_changes.lab = /*lab*/ ctx[0];

    			if (dirty & /*$$scope, r*/ 12) {
    				fr_changes.$$scope = { dirty, ctx };
    			}

    			fr.$set(fr_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fr.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fr.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fr, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$P.name,
    		type: "if",
    		source: "(11:0) {#if h}",
    		ctx
    	});

    	return block;
    }

    // (14:4) {#if r.msg}
    function create_if_block_1$u(ctx) {
    	let pp;
    	let current;

    	pp = new PP({
    			props: { lab: "msg", val: /*r*/ ctx[2].msg },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp_changes = {};
    			if (dirty & /*r*/ 4) pp_changes.val = /*r*/ ctx[2].msg;
    			pp.$set(pp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$u.name,
    		type: "if",
    		source: "(14:4) {#if r.msg}",
    		ctx
    	});

    	return block;
    }

    // (12:2) <FR {lab}>
    function create_default_slot$10(ctx) {
    	let pp0;
    	let t0;
    	let t1;
    	let pp1;
    	let current;

    	pp0 = new PP({
    			props: {
    				lab: "err",
    				t: func,
    				val: /*r*/ ctx[2].err
    			},
    			$$inline: true
    		});

    	let if_block = /*r*/ ctx[2].msg && create_if_block_1$u(ctx);

    	pp1 = new PP({
    			props: { lab: "val", val: !!/*r*/ ctx[2].val },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp0.$$.fragment);
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(pp1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp0, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(pp1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp0_changes = {};
    			if (dirty & /*r*/ 4) pp0_changes.val = /*r*/ ctx[2].err;
    			pp0.$set(pp0_changes);

    			if (/*r*/ ctx[2].msg) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*r*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$u(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t1.parentNode, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const pp1_changes = {};
    			if (dirty & /*r*/ 4) pp1_changes.val = !!/*r*/ ctx[2].val;
    			pp1.$set(pp1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp0.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(pp1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp0.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(pp1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp0, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(pp1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$10.name,
    		type: "slot",
    		source: "(12:2) <FR {lab}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1B(ctx) {
    	let pp;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	pp = new PP({
    			props: {
    				lab: "has" + /*lab*/ ctx[0],
    				val: /*h*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$P, create_else_block$p];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*h*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			create_component(pp.$$.fragment);
    			t = space();
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp, target, anchor);
    			insert_dev(target, t, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const pp_changes = {};
    			if (dirty & /*lab*/ 1) pp_changes.lab = "has" + /*lab*/ ctx[0];
    			if (dirty & /*h*/ 2) pp_changes.val = /*h*/ ctx[1];
    			pp.$set(pp_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp, detaching);
    			if (detaching) detach_dev(t);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func = v => v == 0;

    function instance$1B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RespRO', slots, []);
    	let { lab } = $$props;
    	let { h } = $$props;
    	let { r } = $$props;
    	const writable_props = ['lab', 'h', 'r'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RespRO> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('lab' in $$props) $$invalidate(0, lab = $$props.lab);
    		if ('h' in $$props) $$invalidate(1, h = $$props.h);
    		if ('r' in $$props) $$invalidate(2, r = $$props.r);
    	};

    	$$self.$capture_state = () => ({ FP, FR, PP, lab, h, r });

    	$$self.$inject_state = $$props => {
    		if ('lab' in $$props) $$invalidate(0, lab = $$props.lab);
    		if ('h' in $$props) $$invalidate(1, h = $$props.h);
    		if ('r' in $$props) $$invalidate(2, r = $$props.r);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [lab, h, r];
    }

    class RespRO extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1B, create_fragment$1B, safe_not_equal, { lab: 0, h: 1, r: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RespRO",
    			options,
    			id: create_fragment$1B.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*lab*/ ctx[0] === undefined && !('lab' in props)) {
    			console.warn("<RespRO> was created without expected prop 'lab'");
    		}

    		if (/*h*/ ctx[1] === undefined && !('h' in props)) {
    			console.warn("<RespRO> was created without expected prop 'h'");
    		}

    		if (/*r*/ ctx[2] === undefined && !('r' in props)) {
    			console.warn("<RespRO> was created without expected prop 'r'");
    		}
    	}

    	get lab() {
    		throw new Error("<RespRO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lab(value) {
    		throw new Error("<RespRO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get h() {
    		throw new Error("<RespRO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set h(value) {
    		throw new Error("<RespRO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get r() {
    		throw new Error("<RespRO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set r(value) {
    		throw new Error("<RespRO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Debugger.svelte generated by Svelte v3.44.3 */

    const { Object: Object_1$3 } = globals;

    function get_each_context_6$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[75] = list[i];
    	return child_ctx;
    }

    function get_each_context_7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[78] = list[i];
    	return child_ctx;
    }

    function get_each_context_5$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[72] = list[i];
    	return child_ctx;
    }

    function get_each_context_4$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[67] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[67] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[64] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[59] = list[i];
    	return child_ctx;
    }

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[59] = list[i];
    	return child_ctx;
    }

    // (46:2) <Link nolink does={()=> go('main')} disable={tab == 'main'}>
    function create_default_slot_19$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("MAIN");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$3.name,
    		type: "slot",
    		source: "(46:2) <Link nolink does={()=> go('main')} disable={tab == 'main'}>",
    		ctx
    	});

    	return block;
    }

    // (47:2) <Link nolink does={()=> go('rc')} disable={tab == 'rc'}>
    function create_default_slot_18$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("RC");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$3.name,
    		type: "slot",
    		source: "(47:2) <Link nolink does={()=> go('rc')} disable={tab == 'rc'}>",
    		ctx
    	});

    	return block;
    }

    // (48:2) <Link nolink does={()=> go('uc')} disable={tab == 'uc'}>
    function create_default_slot_17$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("UC");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$3.name,
    		type: "slot",
    		source: "(48:2) <Link nolink does={()=> go('uc')} disable={tab == 'uc'}>",
    		ctx
    	});

    	return block;
    }

    // (49:2) <Link nolink does={()=> go('state')} disable={tab == 'state'}>
    function create_default_slot_16$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("STATE");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$4.name,
    		type: "slot",
    		source: "(49:2) <Link nolink does={()=> go('state')} disable={tab == 'state'}>",
    		ctx
    	});

    	return block;
    }

    // (50:2) <Link nolink does={()=> go('links')} disable={tab == 'links'}>
    function create_default_slot_15$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("LINKS");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$4.name,
    		type: "slot",
    		source: "(50:2) <Link nolink does={()=> go('links')} disable={tab == 'links'}>",
    		ctx
    	});

    	return block;
    }

    // (51:2) <Link nolink does={()=> go('linkmap')} disable={tab == 'linkmap'}>
    function create_default_slot_14$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("LINKMAP");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$4.name,
    		type: "slot",
    		source: "(51:2) <Link nolink does={()=> go('linkmap')} disable={tab == 'linkmap'}>",
    		ctx
    	});

    	return block;
    }

    // (52:2) <Link nolink does={()=> go('trail')} disable={tab == 'trail'}>
    function create_default_slot_13$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("TRAIL");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$4.name,
    		type: "slot",
    		source: "(52:2) <Link nolink does={()=> go('trail')} disable={tab == 'trail'}>",
    		ctx
    	});

    	return block;
    }

    // (53:2) <Link nolink does={()=> go('page')} disable={tab == 'page'}>
    function create_default_slot_12$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("PAGE");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$4.name,
    		type: "slot",
    		source: "(53:2) <Link nolink does={()=> go('page')} disable={tab == 'page'}>",
    		ctx
    	});

    	return block;
    }

    // (45:0) <FB>
    function create_default_slot_11$6(ctx) {
    	let link0;
    	let t0;
    	let link1;
    	let t1;
    	let link2;
    	let t2;
    	let link3;
    	let t3;
    	let link4;
    	let t4;
    	let link5;
    	let t5;
    	let link6;
    	let t6;
    	let link7;
    	let current;

    	link0 = new Link$1({
    			props: {
    				nolink: true,
    				does: /*func*/ ctx[50],
    				disable: /*tab*/ ctx[0] == 'main',
    				$$slots: { default: [create_default_slot_19$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link$1({
    			props: {
    				nolink: true,
    				does: /*func_1*/ ctx[51],
    				disable: /*tab*/ ctx[0] == 'rc',
    				$$slots: { default: [create_default_slot_18$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link2 = new Link$1({
    			props: {
    				nolink: true,
    				does: /*func_2*/ ctx[52],
    				disable: /*tab*/ ctx[0] == 'uc',
    				$$slots: { default: [create_default_slot_17$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link3 = new Link$1({
    			props: {
    				nolink: true,
    				does: /*func_3*/ ctx[53],
    				disable: /*tab*/ ctx[0] == 'state',
    				$$slots: { default: [create_default_slot_16$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link4 = new Link$1({
    			props: {
    				nolink: true,
    				does: /*func_4*/ ctx[54],
    				disable: /*tab*/ ctx[0] == 'links',
    				$$slots: { default: [create_default_slot_15$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link5 = new Link$1({
    			props: {
    				nolink: true,
    				does: /*func_5*/ ctx[55],
    				disable: /*tab*/ ctx[0] == 'linkmap',
    				$$slots: { default: [create_default_slot_14$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link6 = new Link$1({
    			props: {
    				nolink: true,
    				does: /*func_6*/ ctx[56],
    				disable: /*tab*/ ctx[0] == 'trail',
    				$$slots: { default: [create_default_slot_13$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link7 = new Link$1({
    			props: {
    				nolink: true,
    				does: /*func_7*/ ctx[57],
    				disable: /*tab*/ ctx[0] == 'page',
    				$$slots: { default: [create_default_slot_12$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link0.$$.fragment);
    			t0 = space();
    			create_component(link1.$$.fragment);
    			t1 = space();
    			create_component(link2.$$.fragment);
    			t2 = space();
    			create_component(link3.$$.fragment);
    			t3 = space();
    			create_component(link4.$$.fragment);
    			t4 = space();
    			create_component(link5.$$.fragment);
    			t5 = space();
    			create_component(link6.$$.fragment);
    			t6 = space();
    			create_component(link7.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(link1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(link2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(link3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(link4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(link5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(link6, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(link7, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link0_changes = {};
    			if (dirty[0] & /*tab*/ 1) link0_changes.disable = /*tab*/ ctx[0] == 'main';

    			if (dirty[2] & /*$$scope*/ 524288) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};
    			if (dirty[0] & /*tab*/ 1) link1_changes.disable = /*tab*/ ctx[0] == 'rc';

    			if (dirty[2] & /*$$scope*/ 524288) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    			const link2_changes = {};
    			if (dirty[0] & /*tab*/ 1) link2_changes.disable = /*tab*/ ctx[0] == 'uc';

    			if (dirty[2] & /*$$scope*/ 524288) {
    				link2_changes.$$scope = { dirty, ctx };
    			}

    			link2.$set(link2_changes);
    			const link3_changes = {};
    			if (dirty[0] & /*tab*/ 1) link3_changes.disable = /*tab*/ ctx[0] == 'state';

    			if (dirty[2] & /*$$scope*/ 524288) {
    				link3_changes.$$scope = { dirty, ctx };
    			}

    			link3.$set(link3_changes);
    			const link4_changes = {};
    			if (dirty[0] & /*tab*/ 1) link4_changes.disable = /*tab*/ ctx[0] == 'links';

    			if (dirty[2] & /*$$scope*/ 524288) {
    				link4_changes.$$scope = { dirty, ctx };
    			}

    			link4.$set(link4_changes);
    			const link5_changes = {};
    			if (dirty[0] & /*tab*/ 1) link5_changes.disable = /*tab*/ ctx[0] == 'linkmap';

    			if (dirty[2] & /*$$scope*/ 524288) {
    				link5_changes.$$scope = { dirty, ctx };
    			}

    			link5.$set(link5_changes);
    			const link6_changes = {};
    			if (dirty[0] & /*tab*/ 1) link6_changes.disable = /*tab*/ ctx[0] == 'trail';

    			if (dirty[2] & /*$$scope*/ 524288) {
    				link6_changes.$$scope = { dirty, ctx };
    			}

    			link6.$set(link6_changes);
    			const link7_changes = {};
    			if (dirty[0] & /*tab*/ 1) link7_changes.disable = /*tab*/ ctx[0] == 'page';

    			if (dirty[2] & /*$$scope*/ 524288) {
    				link7_changes.$$scope = { dirty, ctx };
    			}

    			link7.$set(link7_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(link2.$$.fragment, local);
    			transition_in(link3.$$.fragment, local);
    			transition_in(link4.$$.fragment, local);
    			transition_in(link5.$$.fragment, local);
    			transition_in(link6.$$.fragment, local);
    			transition_in(link7.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(link2.$$.fragment, local);
    			transition_out(link3.$$.fragment, local);
    			transition_out(link4.$$.fragment, local);
    			transition_out(link5.$$.fragment, local);
    			transition_out(link6.$$.fragment, local);
    			transition_out(link7.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(link1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(link2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(link3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(link4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(link5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(link6, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(link7, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$6.name,
    		type: "slot",
    		source: "(45:0) <FB>",
    		ctx
    	});

    	return block;
    }

    // (125:24) 
    function create_if_block_7$1(ctx) {
    	let ft;
    	let current;

    	ft = new FT({
    			props: {
    				$$slots: { default: [create_default_slot_10$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(ft.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(ft, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const ft_changes = {};

    			if (dirty[0] & /*$page*/ 128 | dirty[2] & /*$$scope*/ 524288) {
    				ft_changes.$$scope = { dirty, ctx };
    			}

    			ft.$set(ft_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ft.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ft.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(ft, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(125:24) ",
    		ctx
    	});

    	return block;
    }

    // (119:25) 
    function create_if_block_6$1(ctx) {
    	let ft;
    	let current;

    	ft = new FT({
    			props: {
    				lab: /*tab*/ ctx[0],
    				$$slots: { default: [create_default_slot_9$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(ft.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(ft, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const ft_changes = {};
    			if (dirty[0] & /*tab*/ 1) ft_changes.lab = /*tab*/ ctx[0];

    			if (dirty[0] & /*$trail*/ 16777216 | dirty[2] & /*$$scope*/ 524288) {
    				ft_changes.$$scope = { dirty, ctx };
    			}

    			ft.$set(ft_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ft.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ft.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(ft, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(119:25) ",
    		ctx
    	});

    	return block;
    }

    // (113:27) 
    function create_if_block_5$4(ctx) {
    	let ft;
    	let current;

    	ft = new FT({
    			props: {
    				lab: /*tab*/ ctx[0],
    				$$slots: { default: [create_default_slot_8$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(ft.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(ft, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const ft_changes = {};
    			if (dirty[0] & /*tab*/ 1) ft_changes.lab = /*tab*/ ctx[0];

    			if (dirty[0] & /*$linkmap*/ 8388608 | dirty[2] & /*$$scope*/ 524288) {
    				ft_changes.$$scope = { dirty, ctx };
    			}

    			ft.$set(ft_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ft.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ft.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(ft, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$4.name,
    		type: "if",
    		source: "(113:27) ",
    		ctx
    	});

    	return block;
    }

    // (106:25) 
    function create_if_block_4$7(ctx) {
    	let ft;
    	let current;

    	ft = new FT({
    			props: {
    				$$slots: { default: [create_default_slot_7$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(ft.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(ft, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const ft_changes = {};

    			if (dirty[0] & /*$links*/ 4194304 | dirty[2] & /*$$scope*/ 524288) {
    				ft_changes.$$scope = { dirty, ctx };
    			}

    			ft.$set(ft_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ft.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ft.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(ft, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$7.name,
    		type: "if",
    		source: "(106:25) ",
    		ctx
    	});

    	return block;
    }

    // (100:25) 
    function create_if_block_3$f(ctx) {
    	let ft;
    	let current;

    	ft = new FT({
    			props: {
    				lab: /*tab*/ ctx[0],
    				$$slots: { default: [create_default_slot_6$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(ft.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(ft, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const ft_changes = {};
    			if (dirty[0] & /*tab*/ 1) ft_changes.lab = /*tab*/ ctx[0];

    			if (dirty[0] & /*$state*/ 2097152 | dirty[2] & /*$$scope*/ 524288) {
    				ft_changes.$$scope = { dirty, ctx };
    			}

    			ft.$set(ft_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ft.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ft.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(ft, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$f.name,
    		type: "if",
    		source: "(100:25) ",
    		ctx
    	});

    	return block;
    }

    // (94:22) 
    function create_if_block_2$k(ctx) {
    	let ft;
    	let current;

    	ft = new FT({
    			props: {
    				$$slots: { default: [create_default_slot_5$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(ft.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(ft, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const ft_changes = {};

    			if (dirty[0] & /*$uc*/ 1048576 | dirty[2] & /*$$scope*/ 524288) {
    				ft_changes.$$scope = { dirty, ctx };
    			}

    			ft.$set(ft_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ft.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ft.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(ft, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$k.name,
    		type: "if",
    		source: "(94:22) ",
    		ctx
    	});

    	return block;
    }

    // (88:22) 
    function create_if_block_1$t(ctx) {
    	let ft;
    	let current;

    	ft = new FT({
    			props: {
    				$$slots: { default: [create_default_slot_4$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(ft.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(ft, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const ft_changes = {};

    			if (dirty[0] & /*$rc*/ 524288 | dirty[2] & /*$$scope*/ 524288) {
    				ft_changes.$$scope = { dirty, ctx };
    			}

    			ft.$set(ft_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ft.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ft.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(ft, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$t.name,
    		type: "if",
    		source: "(88:22) ",
    		ctx
    	});

    	return block;
    }

    // (55:0) {#if tab == 'main'}
    function create_if_block$O(ctx) {
    	let ft;
    	let current;

    	ft = new FT({
    			props: {
    				$$slots: { default: [create_default_slot$$] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(ft.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(ft, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const ft_changes = {};

    			if (dirty[0] & /*$modifiers, $title, $space, $loading, $scrollinfo, $message, $aod, $hashistory, $history, $hasuser, $user, $haspage, $page, $haslogin, $hassess, $editing, $creating, $path*/ 524286 | dirty[2] & /*$$scope*/ 524288) {
    				ft_changes.$$scope = { dirty, ctx };
    			}

    			ft.$set(ft_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ft.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ft.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(ft, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$O.name,
    		type: "if",
    		source: "(55:0) {#if tab == 'main'}",
    		ctx
    	});

    	return block;
    }

    // (127:2) {#if !!$page}
    function create_if_block_8$1(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_6 = Object.entries(/*$page*/ ctx[7]);
    	validate_each_argument(each_value_6);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_6.length; i += 1) {
    		each_blocks[i] = create_each_block_6$1(get_each_context_6$1(ctx, each_value_6, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$page*/ 128) {
    				each_value_6 = Object.entries(/*$page*/ ctx[7]);
    				validate_each_argument(each_value_6);
    				let i;

    				for (i = 0; i < each_value_6.length; i += 1) {
    					const child_ctx = get_each_context_6$1(ctx, each_value_6, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_6$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_6.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_6.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(127:2) {#if !!$page}",
    		ctx
    	});

    	return block;
    }

    // (137:4) {:else}
    function create_else_block_1$4(ctx) {
    	let pp;
    	let current;

    	pp = new PP({
    			props: {
    				lab: /*resp*/ ctx[75][0],
    				val: /*resp*/ ctx[75][1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp_changes = {};
    			if (dirty[0] & /*$page*/ 128) pp_changes.lab = /*resp*/ ctx[75][0];
    			if (dirty[0] & /*$page*/ 128) pp_changes.val = /*resp*/ ctx[75][1];
    			pp.$set(pp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$4.name,
    		type: "else",
    		source: "(137:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (129:4) {#if resp[0] == 'val'}
    function create_if_block_9(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_7 = Object.entries(/*resp*/ ctx[75][1]);
    	validate_each_argument(each_value_7);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_7.length; i += 1) {
    		each_blocks[i] = create_each_block_7(get_each_context_7(ctx, each_value_7, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$page*/ 128) {
    				each_value_7 = Object.entries(/*resp*/ ctx[75][1]);
    				validate_each_argument(each_value_7);
    				let i;

    				for (i = 0; i < each_value_7.length; i += 1) {
    					const child_ctx = get_each_context_7(ctx, each_value_7, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_7.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_7.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(129:4) {#if resp[0] == 'val'}",
    		ctx
    	});

    	return block;
    }

    // (133:8) {:else}
    function create_else_block$o(ctx) {
    	let pp;
    	let current;

    	pp = new PP({
    			props: {
    				lab: /*pair*/ ctx[78][0],
    				val: /*pair*/ ctx[78][1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp_changes = {};
    			if (dirty[0] & /*$page*/ 128) pp_changes.lab = /*pair*/ ctx[78][0];
    			if (dirty[0] & /*$page*/ 128) pp_changes.val = /*pair*/ ctx[78][1];
    			pp.$set(pp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$o.name,
    		type: "else",
    		source: "(133:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (131:8) {#if pair[0] == 'body'}
    function create_if_block_10(ctx) {
    	let pp;
    	let current;

    	pp = new PP({
    			props: {
    				lab: /*pair*/ ctx[78][0],
    				val: /*pair*/ ctx[78][1].slice(0, 100)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp_changes = {};
    			if (dirty[0] & /*$page*/ 128) pp_changes.lab = /*pair*/ ctx[78][0];
    			if (dirty[0] & /*$page*/ 128) pp_changes.val = /*pair*/ ctx[78][1].slice(0, 100);
    			pp.$set(pp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(131:8) {#if pair[0] == 'body'}",
    		ctx
    	});

    	return block;
    }

    // (130:6) {#each Object.entries(resp[1]) as pair}
    function create_each_block_7(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_10, create_else_block$o];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*pair*/ ctx[78][0] == 'body') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_7.name,
    		type: "each",
    		source: "(130:6) {#each Object.entries(resp[1]) as pair}",
    		ctx
    	});

    	return block;
    }

    // (128:2) {#each Object.entries($page) as resp}
    function create_each_block_6$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_9, create_else_block_1$4];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*resp*/ ctx[75][0] == 'val') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_6$1.name,
    		type: "each",
    		source: "(128:2) {#each Object.entries($page) as resp}",
    		ctx
    	});

    	return block;
    }

    // (126:0) <FT>
    function create_default_slot_10$7(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = !!/*$page*/ ctx[7] && create_if_block_8$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!!/*$page*/ ctx[7]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$page*/ 128) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_8$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$7.name,
    		type: "slot",
    		source: "(126:0) <FT>",
    		ctx
    	});

    	return block;
    }

    // (121:2) {#each $trail as p}
    function create_each_block_5$2(ctx) {
    	let pp;
    	let current;

    	pp = new PP({
    			props: { val: /*p*/ ctx[72] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp_changes = {};
    			if (dirty[0] & /*$trail*/ 16777216) pp_changes.val = /*p*/ ctx[72];
    			pp.$set(pp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5$2.name,
    		type: "each",
    		source: "(121:2) {#each $trail as p}",
    		ctx
    	});

    	return block;
    }

    // (120:0) <FT lab={tab}>
    function create_default_slot_9$7(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_5 = /*$trail*/ ctx[24];
    	validate_each_argument(each_value_5);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks[i] = create_each_block_5$2(get_each_context_5$2(ctx, each_value_5, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$trail*/ 16777216) {
    				each_value_5 = /*$trail*/ ctx[24];
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5$2(ctx, each_value_5, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_5$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_5.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_5.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$7.name,
    		type: "slot",
    		source: "(120:0) <FT lab={tab}>",
    		ctx
    	});

    	return block;
    }

    // (115:2) {#each Object.entries($linkmap) as link}
    function create_each_block_4$2(ctx) {
    	let pp;
    	let current;

    	pp = new PP({
    			props: {
    				lab: /*link*/ ctx[67][0],
    				val: /*link*/ ctx[67][1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp_changes = {};
    			if (dirty[0] & /*$linkmap*/ 8388608) pp_changes.lab = /*link*/ ctx[67][0];
    			if (dirty[0] & /*$linkmap*/ 8388608) pp_changes.val = /*link*/ ctx[67][1];
    			pp.$set(pp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4$2.name,
    		type: "each",
    		source: "(115:2) {#each Object.entries($linkmap) as link}",
    		ctx
    	});

    	return block;
    }

    // (114:0) <FT lab={tab}>
    function create_default_slot_8$7(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_4 = Object.entries(/*$linkmap*/ ctx[23]);
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4$2(get_each_context_4$2(ctx, each_value_4, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$linkmap*/ 8388608) {
    				each_value_4 = Object.entries(/*$linkmap*/ ctx[23]);
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4$2(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_4$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_4.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_4.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$7.name,
    		type: "slot",
    		source: "(114:0) <FT lab={tab}>",
    		ctx
    	});

    	return block;
    }

    // (109:2) {#each $links as link}
    function create_each_block_3$3(ctx) {
    	let pp;
    	let current;

    	pp = new PP({
    			props: { val: /*link*/ ctx[67] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp_changes = {};
    			if (dirty[0] & /*$links*/ 4194304) pp_changes.val = /*link*/ ctx[67];
    			pp.$set(pp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$3.name,
    		type: "each",
    		source: "(109:2) {#each $links as link}",
    		ctx
    	});

    	return block;
    }

    // (107:0) <FT>
    function create_default_slot_7$b(ctx) {
    	let pp;
    	let t;
    	let each_1_anchor;
    	let current;

    	pp = new PP({
    			props: {
    				lab: "count",
    				val: /*$links*/ ctx[22].length
    			},
    			$$inline: true
    		});

    	let each_value_3 = /*$links*/ ctx[22];
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3$3(get_each_context_3$3(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(pp.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp, target, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp_changes = {};
    			if (dirty[0] & /*$links*/ 4194304) pp_changes.val = /*$links*/ ctx[22].length;
    			pp.$set(pp_changes);

    			if (dirty[0] & /*$links*/ 4194304) {
    				each_value_3 = /*$links*/ ctx[22];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp.$$.fragment, local);

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp, detaching);
    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$b.name,
    		type: "slot",
    		source: "(107:0) <FT>",
    		ctx
    	});

    	return block;
    }

    // (102:2) {#each Object.entries($state) as s}
    function create_each_block_2$4(ctx) {
    	let pp;
    	let current;

    	pp = new PP({
    			props: {
    				lab: /*s*/ ctx[64][0],
    				val: /*s*/ ctx[64][1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp_changes = {};
    			if (dirty[0] & /*$state*/ 2097152) pp_changes.lab = /*s*/ ctx[64][0];
    			if (dirty[0] & /*$state*/ 2097152) pp_changes.val = /*s*/ ctx[64][1];
    			pp.$set(pp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$4.name,
    		type: "each",
    		source: "(102:2) {#each Object.entries($state) as s}",
    		ctx
    	});

    	return block;
    }

    // (101:0) <FT lab={tab}>
    function create_default_slot_6$d(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_2 = Object.entries(/*$state*/ ctx[21]);
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$4(get_each_context_2$4(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$state*/ 2097152) {
    				each_value_2 = Object.entries(/*$state*/ ctx[21]);
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$4(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$d.name,
    		type: "slot",
    		source: "(101:0) <FT lab={tab}>",
    		ctx
    	});

    	return block;
    }

    // (96:2) {#each Object.entries($uc) as conf}
    function create_each_block_1$5(ctx) {
    	let pp;
    	let current;

    	pp = new PP({
    			props: {
    				lab: /*conf*/ ctx[59][0],
    				val: /*conf*/ ctx[59][1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp_changes = {};
    			if (dirty[0] & /*$uc*/ 1048576) pp_changes.lab = /*conf*/ ctx[59][0];
    			if (dirty[0] & /*$uc*/ 1048576) pp_changes.val = /*conf*/ ctx[59][1];
    			pp.$set(pp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$5.name,
    		type: "each",
    		source: "(96:2) {#each Object.entries($uc) as conf}",
    		ctx
    	});

    	return block;
    }

    // (95:0) <FT>
    function create_default_slot_5$j(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = Object.entries(/*$uc*/ ctx[20]);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$uc*/ 1048576) {
    				each_value_1 = Object.entries(/*$uc*/ ctx[20]);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$j.name,
    		type: "slot",
    		source: "(95:0) <FT>",
    		ctx
    	});

    	return block;
    }

    // (90:2) {#each Object.entries($rc) as conf}
    function create_each_block$e(ctx) {
    	let pp;
    	let current;

    	pp = new PP({
    			props: {
    				lab: /*conf*/ ctx[59][0],
    				val: /*conf*/ ctx[59][1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp_changes = {};
    			if (dirty[0] & /*$rc*/ 524288) pp_changes.lab = /*conf*/ ctx[59][0];
    			if (dirty[0] & /*$rc*/ 524288) pp_changes.val = /*conf*/ ctx[59][1];
    			pp.$set(pp_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(90:2) {#each Object.entries($rc) as conf}",
    		ctx
    	});

    	return block;
    }

    // (89:0) <FT>
    function create_default_slot_4$k(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = Object.entries(/*$rc*/ ctx[19]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$rc*/ 524288) {
    				each_value = Object.entries(/*$rc*/ ctx[19]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$k.name,
    		type: "slot",
    		source: "(89:0) <FT>",
    		ctx
    	});

    	return block;
    }

    // (68:2) <FR lab="message">
    function create_default_slot_3$o(ctx) {
    	let pp0;
    	let t;
    	let pp1;
    	let current;

    	pp0 = new PP({
    			props: {
    				lab: "level",
    				val: /*$message*/ ctx[13].level
    			},
    			$$inline: true
    		});

    	pp1 = new PP({
    			props: {
    				lab: "text",
    				val: /*$message*/ ctx[13].text
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp0.$$.fragment);
    			t = space();
    			create_component(pp1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(pp1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp0_changes = {};
    			if (dirty[0] & /*$message*/ 8192) pp0_changes.val = /*$message*/ ctx[13].level;
    			pp0.$set(pp0_changes);
    			const pp1_changes = {};
    			if (dirty[0] & /*$message*/ 8192) pp1_changes.val = /*$message*/ ctx[13].text;
    			pp1.$set(pp1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp0.$$.fragment, local);
    			transition_in(pp1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp0.$$.fragment, local);
    			transition_out(pp1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(pp1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$o.name,
    		type: "slot",
    		source: "(68:2) <FR lab=\\\"message\\\">",
    		ctx
    	});

    	return block;
    }

    // (72:2) <FR lab="scrollinfo">
    function create_default_slot_2$w(ctx) {
    	let pp0;
    	let t0;
    	let pp1;
    	let t1;
    	let pp2;
    	let t2;
    	let pp3;
    	let t3;
    	let pp4;
    	let current;

    	pp0 = new PP({
    			props: {
    				lab: "ch",
    				val: /*$scrollinfo*/ ctx[14].ch
    			},
    			$$inline: true
    		});

    	pp1 = new PP({
    			props: {
    				lab: "sh",
    				val: /*$scrollinfo*/ ctx[14].sh
    			},
    			$$inline: true
    		});

    	pp2 = new PP({
    			props: {
    				lab: "sy",
    				val: /*$scrollinfo*/ ctx[14].sy
    			},
    			$$inline: true
    		});

    	pp3 = new PP({
    			props: {
    				lab: "scrollable",
    				val: /*$scrollinfo*/ ctx[14].scrollable
    			},
    			$$inline: true
    		});

    	pp4 = new PP({
    			props: {
    				lab: "scrolled",
    				val: /*$scrollinfo*/ ctx[14].scrolled
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp0.$$.fragment);
    			t0 = space();
    			create_component(pp1.$$.fragment);
    			t1 = space();
    			create_component(pp2.$$.fragment);
    			t2 = space();
    			create_component(pp3.$$.fragment);
    			t3 = space();
    			create_component(pp4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(pp1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(pp2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(pp3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(pp4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp0_changes = {};
    			if (dirty[0] & /*$scrollinfo*/ 16384) pp0_changes.val = /*$scrollinfo*/ ctx[14].ch;
    			pp0.$set(pp0_changes);
    			const pp1_changes = {};
    			if (dirty[0] & /*$scrollinfo*/ 16384) pp1_changes.val = /*$scrollinfo*/ ctx[14].sh;
    			pp1.$set(pp1_changes);
    			const pp2_changes = {};
    			if (dirty[0] & /*$scrollinfo*/ 16384) pp2_changes.val = /*$scrollinfo*/ ctx[14].sy;
    			pp2.$set(pp2_changes);
    			const pp3_changes = {};
    			if (dirty[0] & /*$scrollinfo*/ 16384) pp3_changes.val = /*$scrollinfo*/ ctx[14].scrollable;
    			pp3.$set(pp3_changes);
    			const pp4_changes = {};
    			if (dirty[0] & /*$scrollinfo*/ 16384) pp4_changes.val = /*$scrollinfo*/ ctx[14].scrolled;
    			pp4.$set(pp4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp0.$$.fragment, local);
    			transition_in(pp1.$$.fragment, local);
    			transition_in(pp2.$$.fragment, local);
    			transition_in(pp3.$$.fragment, local);
    			transition_in(pp4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp0.$$.fragment, local);
    			transition_out(pp1.$$.fragment, local);
    			transition_out(pp2.$$.fragment, local);
    			transition_out(pp3.$$.fragment, local);
    			transition_out(pp4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(pp1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(pp2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(pp3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(pp4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$w.name,
    		type: "slot",
    		source: "(72:2) <FR lab=\\\"scrollinfo\\\">",
    		ctx
    	});

    	return block;
    }

    // (82:2) <FR lab="modifiers">
    function create_default_slot_1$F(ctx) {
    	let pp0;
    	let t0;
    	let pp1;
    	let t1;
    	let pp2;
    	let current;

    	pp0 = new PP({
    			props: {
    				lab: "shift",
    				val: /*$modifiers*/ ctx[18].Shift
    			},
    			$$inline: true
    		});

    	pp1 = new PP({
    			props: {
    				lab: "ctrl",
    				val: /*$modifiers*/ ctx[18].Control
    			},
    			$$inline: true
    		});

    	pp2 = new PP({
    			props: {
    				lab: "alt",
    				val: /*$modifiers*/ ctx[18].Alt
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp0.$$.fragment);
    			t0 = space();
    			create_component(pp1.$$.fragment);
    			t1 = space();
    			create_component(pp2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(pp1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(pp2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp0_changes = {};
    			if (dirty[0] & /*$modifiers*/ 262144) pp0_changes.val = /*$modifiers*/ ctx[18].Shift;
    			pp0.$set(pp0_changes);
    			const pp1_changes = {};
    			if (dirty[0] & /*$modifiers*/ 262144) pp1_changes.val = /*$modifiers*/ ctx[18].Control;
    			pp1.$set(pp1_changes);
    			const pp2_changes = {};
    			if (dirty[0] & /*$modifiers*/ 262144) pp2_changes.val = /*$modifiers*/ ctx[18].Alt;
    			pp2.$set(pp2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp0.$$.fragment, local);
    			transition_in(pp1.$$.fragment, local);
    			transition_in(pp2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp0.$$.fragment, local);
    			transition_out(pp1.$$.fragment, local);
    			transition_out(pp2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(pp1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(pp2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$F.name,
    		type: "slot",
    		source: "(82:2) <FR lab=\\\"modifiers\\\">",
    		ctx
    	});

    	return block;
    }

    // (56:0) <FT>
    function create_default_slot$$(ctx) {
    	let pp0;
    	let t0;
    	let locro;
    	let t1;
    	let pp1;
    	let t2;
    	let pp2;
    	let t3;
    	let pp3;
    	let t4;
    	let pp4;
    	let t5;
    	let sessro;
    	let t6;
    	let respro0;
    	let t7;
    	let respro1;
    	let t8;
    	let respro2;
    	let t9;
    	let pp5;
    	let t10;
    	let fr0;
    	let t11;
    	let fr1;
    	let t12;
    	let pp6;
    	let t13;
    	let pp7;
    	let t14;
    	let pp8;
    	let t15;
    	let fr2;
    	let current;

    	pp0 = new PP({
    			props: { lab: "path", val: /*$path*/ ctx[1] },
    			$$inline: true
    		});

    	locro = new LocRO({ $$inline: true });

    	pp1 = new PP({
    			props: {
    				lab: "creating",
    				val: /*$creating*/ ctx[2]
    			},
    			$$inline: true
    		});

    	pp2 = new PP({
    			props: { lab: "editing", val: /*$editing*/ ctx[3] },
    			$$inline: true
    		});

    	pp3 = new PP({
    			props: { lab: "hassess", val: /*$hassess*/ ctx[4] },
    			$$inline: true
    		});

    	pp4 = new PP({
    			props: {
    				lab: "haslogin",
    				val: /*$haslogin*/ ctx[5]
    			},
    			$$inline: true
    		});

    	sessro = new SessRO({ $$inline: true });

    	respro0 = new RespRO({
    			props: {
    				lab: "page",
    				h: /*$haspage*/ ctx[6],
    				r: /*$page*/ ctx[7]
    			},
    			$$inline: true
    		});

    	respro1 = new RespRO({
    			props: {
    				lab: "user",
    				h: /*$hasuser*/ ctx[8],
    				r: /*$user*/ ctx[9]
    			},
    			$$inline: true
    		});

    	respro2 = new RespRO({
    			props: {
    				lab: "history",
    				h: /*$hashistory*/ ctx[10],
    				r: /*$history*/ ctx[11]
    			},
    			$$inline: true
    		});

    	pp5 = new PP({
    			props: {
    				lab: "AOD",
    				t: func_8,
    				val: /*$aod*/ ctx[12]
    			},
    			$$inline: true
    		});

    	fr0 = new FR({
    			props: {
    				lab: "message",
    				$$slots: { default: [create_default_slot_3$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fr1 = new FR({
    			props: {
    				lab: "scrollinfo",
    				$$slots: { default: [create_default_slot_2$w] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	pp6 = new PP({
    			props: {
    				lab: "loading",
    				t: func_9,
    				val: /*$loading*/ ctx[15]
    			},
    			$$inline: true
    		});

    	pp7 = new PP({
    			props: { lab: "space", val: /*$space*/ ctx[16] },
    			$$inline: true
    		});

    	pp8 = new PP({
    			props: { lab: "title", val: /*$title*/ ctx[17] },
    			$$inline: true
    		});

    	fr2 = new FR({
    			props: {
    				lab: "modifiers",
    				$$slots: { default: [create_default_slot_1$F] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pp0.$$.fragment);
    			t0 = space();
    			create_component(locro.$$.fragment);
    			t1 = space();
    			create_component(pp1.$$.fragment);
    			t2 = space();
    			create_component(pp2.$$.fragment);
    			t3 = space();
    			create_component(pp3.$$.fragment);
    			t4 = space();
    			create_component(pp4.$$.fragment);
    			t5 = space();
    			create_component(sessro.$$.fragment);
    			t6 = space();
    			create_component(respro0.$$.fragment);
    			t7 = space();
    			create_component(respro1.$$.fragment);
    			t8 = space();
    			create_component(respro2.$$.fragment);
    			t9 = space();
    			create_component(pp5.$$.fragment);
    			t10 = space();
    			create_component(fr0.$$.fragment);
    			t11 = space();
    			create_component(fr1.$$.fragment);
    			t12 = space();
    			create_component(pp6.$$.fragment);
    			t13 = space();
    			create_component(pp7.$$.fragment);
    			t14 = space();
    			create_component(pp8.$$.fragment);
    			t15 = space();
    			create_component(fr2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pp0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(locro, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(pp1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(pp2, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(pp3, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(pp4, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(sessro, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(respro0, target, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(respro1, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(respro2, target, anchor);
    			insert_dev(target, t9, anchor);
    			mount_component(pp5, target, anchor);
    			insert_dev(target, t10, anchor);
    			mount_component(fr0, target, anchor);
    			insert_dev(target, t11, anchor);
    			mount_component(fr1, target, anchor);
    			insert_dev(target, t12, anchor);
    			mount_component(pp6, target, anchor);
    			insert_dev(target, t13, anchor);
    			mount_component(pp7, target, anchor);
    			insert_dev(target, t14, anchor);
    			mount_component(pp8, target, anchor);
    			insert_dev(target, t15, anchor);
    			mount_component(fr2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pp0_changes = {};
    			if (dirty[0] & /*$path*/ 2) pp0_changes.val = /*$path*/ ctx[1];
    			pp0.$set(pp0_changes);
    			const pp1_changes = {};
    			if (dirty[0] & /*$creating*/ 4) pp1_changes.val = /*$creating*/ ctx[2];
    			pp1.$set(pp1_changes);
    			const pp2_changes = {};
    			if (dirty[0] & /*$editing*/ 8) pp2_changes.val = /*$editing*/ ctx[3];
    			pp2.$set(pp2_changes);
    			const pp3_changes = {};
    			if (dirty[0] & /*$hassess*/ 16) pp3_changes.val = /*$hassess*/ ctx[4];
    			pp3.$set(pp3_changes);
    			const pp4_changes = {};
    			if (dirty[0] & /*$haslogin*/ 32) pp4_changes.val = /*$haslogin*/ ctx[5];
    			pp4.$set(pp4_changes);
    			const respro0_changes = {};
    			if (dirty[0] & /*$haspage*/ 64) respro0_changes.h = /*$haspage*/ ctx[6];
    			if (dirty[0] & /*$page*/ 128) respro0_changes.r = /*$page*/ ctx[7];
    			respro0.$set(respro0_changes);
    			const respro1_changes = {};
    			if (dirty[0] & /*$hasuser*/ 256) respro1_changes.h = /*$hasuser*/ ctx[8];
    			if (dirty[0] & /*$user*/ 512) respro1_changes.r = /*$user*/ ctx[9];
    			respro1.$set(respro1_changes);
    			const respro2_changes = {};
    			if (dirty[0] & /*$hashistory*/ 1024) respro2_changes.h = /*$hashistory*/ ctx[10];
    			if (dirty[0] & /*$history*/ 2048) respro2_changes.r = /*$history*/ ctx[11];
    			respro2.$set(respro2_changes);
    			const pp5_changes = {};
    			if (dirty[0] & /*$aod*/ 4096) pp5_changes.val = /*$aod*/ ctx[12];
    			pp5.$set(pp5_changes);
    			const fr0_changes = {};

    			if (dirty[0] & /*$message*/ 8192 | dirty[2] & /*$$scope*/ 524288) {
    				fr0_changes.$$scope = { dirty, ctx };
    			}

    			fr0.$set(fr0_changes);
    			const fr1_changes = {};

    			if (dirty[0] & /*$scrollinfo*/ 16384 | dirty[2] & /*$$scope*/ 524288) {
    				fr1_changes.$$scope = { dirty, ctx };
    			}

    			fr1.$set(fr1_changes);
    			const pp6_changes = {};
    			if (dirty[0] & /*$loading*/ 32768) pp6_changes.val = /*$loading*/ ctx[15];
    			pp6.$set(pp6_changes);
    			const pp7_changes = {};
    			if (dirty[0] & /*$space*/ 65536) pp7_changes.val = /*$space*/ ctx[16];
    			pp7.$set(pp7_changes);
    			const pp8_changes = {};
    			if (dirty[0] & /*$title*/ 131072) pp8_changes.val = /*$title*/ ctx[17];
    			pp8.$set(pp8_changes);
    			const fr2_changes = {};

    			if (dirty[0] & /*$modifiers*/ 262144 | dirty[2] & /*$$scope*/ 524288) {
    				fr2_changes.$$scope = { dirty, ctx };
    			}

    			fr2.$set(fr2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pp0.$$.fragment, local);
    			transition_in(locro.$$.fragment, local);
    			transition_in(pp1.$$.fragment, local);
    			transition_in(pp2.$$.fragment, local);
    			transition_in(pp3.$$.fragment, local);
    			transition_in(pp4.$$.fragment, local);
    			transition_in(sessro.$$.fragment, local);
    			transition_in(respro0.$$.fragment, local);
    			transition_in(respro1.$$.fragment, local);
    			transition_in(respro2.$$.fragment, local);
    			transition_in(pp5.$$.fragment, local);
    			transition_in(fr0.$$.fragment, local);
    			transition_in(fr1.$$.fragment, local);
    			transition_in(pp6.$$.fragment, local);
    			transition_in(pp7.$$.fragment, local);
    			transition_in(pp8.$$.fragment, local);
    			transition_in(fr2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pp0.$$.fragment, local);
    			transition_out(locro.$$.fragment, local);
    			transition_out(pp1.$$.fragment, local);
    			transition_out(pp2.$$.fragment, local);
    			transition_out(pp3.$$.fragment, local);
    			transition_out(pp4.$$.fragment, local);
    			transition_out(sessro.$$.fragment, local);
    			transition_out(respro0.$$.fragment, local);
    			transition_out(respro1.$$.fragment, local);
    			transition_out(respro2.$$.fragment, local);
    			transition_out(pp5.$$.fragment, local);
    			transition_out(fr0.$$.fragment, local);
    			transition_out(fr1.$$.fragment, local);
    			transition_out(pp6.$$.fragment, local);
    			transition_out(pp7.$$.fragment, local);
    			transition_out(pp8.$$.fragment, local);
    			transition_out(fr2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pp0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(locro, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(pp1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(pp2, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(pp3, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(pp4, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(sessro, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(respro0, detaching);
    			if (detaching) detach_dev(t7);
    			destroy_component(respro1, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(respro2, detaching);
    			if (detaching) detach_dev(t9);
    			destroy_component(pp5, detaching);
    			if (detaching) detach_dev(t10);
    			destroy_component(fr0, detaching);
    			if (detaching) detach_dev(t11);
    			destroy_component(fr1, detaching);
    			if (detaching) detach_dev(t12);
    			destroy_component(pp6, detaching);
    			if (detaching) detach_dev(t13);
    			destroy_component(pp7, detaching);
    			if (detaching) detach_dev(t14);
    			destroy_component(pp8, detaching);
    			if (detaching) detach_dev(t15);
    			destroy_component(fr2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$$.name,
    		type: "slot",
    		source: "(56:0) <FT>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1A(ctx) {
    	let fb;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	fb = new FB({
    			props: {
    				$$slots: { default: [create_default_slot_11$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [
    		create_if_block$O,
    		create_if_block_1$t,
    		create_if_block_2$k,
    		create_if_block_3$f,
    		create_if_block_4$7,
    		create_if_block_5$4,
    		create_if_block_6$1,
    		create_if_block_7$1
    	];

    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*tab*/ ctx[0] == 'main') return 0;
    		if (/*tab*/ ctx[0] == 'rc') return 1;
    		if (/*tab*/ ctx[0] == 'uc') return 2;
    		if (/*tab*/ ctx[0] == 'state') return 3;
    		if (/*tab*/ ctx[0] == 'links') return 4;
    		if (/*tab*/ ctx[0] == 'linkmap') return 5;
    		if (/*tab*/ ctx[0] == 'trail') return 6;
    		if (/*tab*/ ctx[0] == 'page') return 7;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[0] & /*tab*/ 1 | dirty[2] & /*$$scope*/ 524288) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func_8 = v => v > 0;
    const func_9 = v => !v;

    function instance$1A($$self, $$props, $$invalidate) {
    	let $path;
    	let $creating;
    	let $editing;
    	let $hassess;
    	let $haslogin;
    	let $haspage;
    	let $page;
    	let $hasuser;
    	let $user;
    	let $hashistory;
    	let $history;
    	let $aod;
    	let $message;
    	let $scrollinfo;
    	let $loading;
    	let $space;
    	let $title;
    	let $modifiers;
    	let $rc;
    	let $uc;
    	let $state;
    	let $links;
    	let $linkmap;
    	let $trail;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Debugger', slots, []);
    	const path = getContext('path');
    	validate_store(path, 'path');
    	component_subscribe($$self, path, value => $$invalidate(1, $path = value));
    	const hassess = getContext('hassess');
    	validate_store(hassess, 'hassess');
    	component_subscribe($$self, hassess, value => $$invalidate(4, $hassess = value));
    	const haslogin = getContext('haslogin');
    	validate_store(haslogin, 'haslogin');
    	component_subscribe($$self, haslogin, value => $$invalidate(5, $haslogin = value));
    	const haspage = getContext('haspage');
    	validate_store(haspage, 'haspage');
    	component_subscribe($$self, haspage, value => $$invalidate(6, $haspage = value));
    	const hasuser = getContext('hasuser');
    	validate_store(hasuser, 'hasuser');
    	component_subscribe($$self, hasuser, value => $$invalidate(8, $hasuser = value));
    	const hashistory = getContext('hashistory');
    	validate_store(hashistory, 'hashistory');
    	component_subscribe($$self, hashistory, value => $$invalidate(10, $hashistory = value));
    	const creating = getContext('creating');
    	validate_store(creating, 'creating');
    	component_subscribe($$self, creating, value => $$invalidate(2, $creating = value));
    	const editing = getContext('editing');
    	validate_store(editing, 'editing');
    	component_subscribe($$self, editing, value => $$invalidate(3, $editing = value));
    	const page = getContext('page');
    	validate_store(page, 'page');
    	component_subscribe($$self, page, value => $$invalidate(7, $page = value));
    	const user = getContext('user');
    	validate_store(user, 'user');
    	component_subscribe($$self, user, value => $$invalidate(9, $user = value));
    	const history = getContext('history');
    	validate_store(history, 'history');
    	component_subscribe($$self, history, value => $$invalidate(11, $history = value));
    	const aod = getContext('aod');
    	validate_store(aod, 'aod');
    	component_subscribe($$self, aod, value => $$invalidate(12, $aod = value));
    	const message = getContext('message');
    	validate_store(message, 'message');
    	component_subscribe($$self, message, value => $$invalidate(13, $message = value));
    	const loading = getContext('loading');
    	validate_store(loading, 'loading');
    	component_subscribe($$self, loading, value => $$invalidate(15, $loading = value));
    	const space = getContext('space');
    	validate_store(space, 'space');
    	component_subscribe($$self, space, value => $$invalidate(16, $space = value));
    	const title = getContext('title');
    	validate_store(title, 'title');
    	component_subscribe($$self, title, value => $$invalidate(17, $title = value));
    	const rc = getContext('rc');
    	validate_store(rc, 'rc');
    	component_subscribe($$self, rc, value => $$invalidate(19, $rc = value));
    	const uc = getContext('uc');
    	validate_store(uc, 'uc');
    	component_subscribe($$self, uc, value => $$invalidate(20, $uc = value));
    	const links = getContext('links');
    	validate_store(links, 'links');
    	component_subscribe($$self, links, value => $$invalidate(22, $links = value));
    	const linkmap = getContext('linkmap');
    	validate_store(linkmap, 'linkmap');
    	component_subscribe($$self, linkmap, value => $$invalidate(23, $linkmap = value));
    	const modifiers = getContext('modifiers');
    	validate_store(modifiers, 'modifiers');
    	component_subscribe($$self, modifiers, value => $$invalidate(18, $modifiers = value));
    	const contcls = getContext('contcls');
    	const trail = getContext('trail');
    	validate_store(trail, 'trail');
    	component_subscribe($$self, trail, value => $$invalidate(24, $trail = value));
    	const scrollinfo = getContext('scrollinfo');
    	validate_store(scrollinfo, 'scrollinfo');
    	component_subscribe($$self, scrollinfo, value => $$invalidate(14, $scrollinfo = value));
    	const state = getContext('state');
    	validate_store(state, 'state');
    	component_subscribe($$self, state, value => $$invalidate(21, $state = value));
    	let tab = localStorage.getItem('debugtab') || 'main';

    	const go = n => {
    		$$invalidate(0, tab = n);
    		localStorage.setItem('debugtab', tab);
    	};

    	const writable_props = [];

    	Object_1$3.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Debugger> was created with unknown prop '${key}'`);
    	});

    	const func = () => go('main');
    	const func_1 = () => go('rc');
    	const func_2 = () => go('uc');
    	const func_3 = () => go('state');
    	const func_4 = () => go('links');
    	const func_5 = () => go('linkmap');
    	const func_6 = () => go('trail');
    	const func_7 = () => go('page');

    	$$self.$capture_state = () => ({
    		FB,
    		FP,
    		PP,
    		FR,
    		FT,
    		Link: Link$1,
    		LocRO,
    		SessRO,
    		RespRO,
    		getContext,
    		path,
    		hassess,
    		haslogin,
    		haspage,
    		hasuser,
    		hashistory,
    		creating,
    		editing,
    		page,
    		user,
    		history,
    		aod,
    		message,
    		loading,
    		space,
    		title,
    		rc,
    		uc,
    		links,
    		linkmap,
    		modifiers,
    		contcls,
    		trail,
    		scrollinfo,
    		state,
    		tab,
    		go,
    		$path,
    		$creating,
    		$editing,
    		$hassess,
    		$haslogin,
    		$haspage,
    		$page,
    		$hasuser,
    		$user,
    		$hashistory,
    		$history,
    		$aod,
    		$message,
    		$scrollinfo,
    		$loading,
    		$space,
    		$title,
    		$modifiers,
    		$rc,
    		$uc,
    		$state,
    		$links,
    		$linkmap,
    		$trail
    	});

    	$$self.$inject_state = $$props => {
    		if ('tab' in $$props) $$invalidate(0, tab = $$props.tab);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		tab,
    		$path,
    		$creating,
    		$editing,
    		$hassess,
    		$haslogin,
    		$haspage,
    		$page,
    		$hasuser,
    		$user,
    		$hashistory,
    		$history,
    		$aod,
    		$message,
    		$scrollinfo,
    		$loading,
    		$space,
    		$title,
    		$modifiers,
    		$rc,
    		$uc,
    		$state,
    		$links,
    		$linkmap,
    		$trail,
    		path,
    		hassess,
    		haslogin,
    		haspage,
    		hasuser,
    		hashistory,
    		creating,
    		editing,
    		page,
    		user,
    		history,
    		aod,
    		message,
    		loading,
    		space,
    		title,
    		rc,
    		uc,
    		links,
    		linkmap,
    		modifiers,
    		trail,
    		scrollinfo,
    		state,
    		go,
    		func,
    		func_1,
    		func_2,
    		func_3,
    		func_4,
    		func_5,
    		func_6,
    		func_7
    	];
    }

    class Debugger extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1A, create_fragment$1A, safe_not_equal, {}, null, [-1, -1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Debugger",
    			options,
    			id: create_fragment$1A.name
    		});
    	}
    }

    /* src/r2/R2.svelte generated by Svelte v3.44.3 */
    const file$V = "src/r2/R2.svelte";

    // (24:4) {#if !fillv}
    function create_if_block_4$6(ctx) {
    	let div0;
    	let t;
    	let div1;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "r2-bar r2-vert");
    			add_location(div0, file$V, 24, 6, 591);
    			attr_dev(div1, "class", "r2-bar r2-vert");
    			add_location(div1, file$V, 25, 6, 632);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$6.name,
    		type: "if",
    		source: "(24:4) {#if !fillv}",
    		ctx
    	});

    	return block;
    }

    // (23:2) <FB vert between zero c="r2-col r2-left {fillv ? 'r2-bar' : ''}">
    function create_default_slot_6$c(ctx) {
    	let if_block_anchor;
    	let if_block = !/*fillv*/ ctx[0] && create_if_block_4$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*fillv*/ ctx[0]) {
    				if (if_block) ; else {
    					if_block = create_if_block_4$6(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$c.name,
    		type: "slot",
    		source: "(23:2) <FB vert between zero c=\\\"r2-col r2-left {fillv ? 'r2-bar' : ''}\\\">",
    		ctx
    	});

    	return block;
    }

    // (32:6) {#if !fillh}
    function create_if_block_3$e(ctx) {
    	let div0;
    	let t;
    	let div1;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "r2-bar r2-hori");
    			add_location(div0, file$V, 32, 8, 827);
    			attr_dev(div1, "class", "r2-bar r2-hori");
    			add_location(div1, file$V, 33, 8, 870);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$e.name,
    		type: "if",
    		source: "(32:6) {#if !fillh}",
    		ctx
    	});

    	return block;
    }

    // (31:4) <FB between zero c="r2-row r2-top {fillh ? 'r2-bar' : ''}">
    function create_default_slot_5$i(ctx) {
    	let if_block_anchor;
    	let if_block = !/*fillh*/ ctx[1] && create_if_block_3$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*fillh*/ ctx[1]) {
    				if (if_block) ; else {
    					if_block = create_if_block_3$e(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$i.name,
    		type: "slot",
    		source: "(31:4) <FB between zero c=\\\"r2-row r2-top {fillh ? 'r2-bar' : ''}\\\">",
    		ctx
    	});

    	return block;
    }

    // (37:4) {#if $$slots.default}
    function create_if_block_2$j(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				expand: true,
    				c: "r2-row r2-content",
    				$$slots: { default: [create_default_slot_4$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$j.name,
    		type: "if",
    		source: "(37:4) {#if $$slots.default}",
    		ctx
    	});

    	return block;
    }

    // (38:6) <FB vert expand c="r2-row r2-content">
    function create_default_slot_4$j(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$j.name,
    		type: "slot",
    		source: "(38:6) <FB vert expand c=\\\"r2-row r2-content\\\">",
    		ctx
    	});

    	return block;
    }

    // (41:6) {#if !fillh}
    function create_if_block_1$s(ctx) {
    	let div0;
    	let t;
    	let div1;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "r2-bar r2-hori");
    			add_location(div0, file$V, 41, 8, 1117);
    			attr_dev(div1, "class", "r2-bar r2-hori");
    			add_location(div1, file$V, 42, 8, 1160);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$s.name,
    		type: "if",
    		source: "(41:6) {#if !fillh}",
    		ctx
    	});

    	return block;
    }

    // (40:4) <FB between zero c="r2-row r2-bot {fillh ? 'r2-bar' : ''}">
    function create_default_slot_3$n(ctx) {
    	let if_block_anchor;
    	let if_block = !/*fillh*/ ctx[1] && create_if_block_1$s(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*fillh*/ ctx[1]) {
    				if (if_block) ; else {
    					if_block = create_if_block_1$s(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$n.name,
    		type: "slot",
    		source: "(40:4) <FB between zero c=\\\"r2-row r2-bot {fillh ? 'r2-bar' : ''}\\\">",
    		ctx
    	});

    	return block;
    }

    // (30:2) <FB vert expand zero between c="r2-col r2-mid">
    function create_default_slot_2$v(ctx) {
    	let fb0;
    	let t0;
    	let t1;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				between: true,
    				zero: true,
    				c: "r2-row r2-top " + (/*fillh*/ ctx[1] ? 'r2-bar' : ''),
    				$$slots: { default: [create_default_slot_5$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$$slots*/ ctx[3].default && create_if_block_2$j(ctx);

    	fb1 = new FB({
    			props: {
    				between: true,
    				zero: true,
    				c: "r2-row r2-bot " + (/*fillh*/ ctx[1] ? 'r2-bar' : ''),
    				$$slots: { default: [create_default_slot_3$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};
    			if (dirty & /*fillh*/ 2) fb0_changes.c = "r2-row r2-top " + (/*fillh*/ ctx[1] ? 'r2-bar' : '');

    			if (dirty & /*$$scope, fillh*/ 514) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);

    			if (/*$$slots*/ ctx[3].default) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$j(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t1.parentNode, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const fb1_changes = {};
    			if (dirty & /*fillh*/ 2) fb1_changes.c = "r2-row r2-bot " + (/*fillh*/ ctx[1] ? 'r2-bar' : '');

    			if (dirty & /*$$scope, fillh*/ 514) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$v.name,
    		type: "slot",
    		source: "(30:2) <FB vert expand zero between c=\\\"r2-col r2-mid\\\">",
    		ctx
    	});

    	return block;
    }

    // (49:4) {#if !fillv}
    function create_if_block$N(ctx) {
    	let div0;
    	let t;
    	let div1;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "r2-bar r2-vert");
    			add_location(div0, file$V, 49, 6, 1318);
    			attr_dev(div1, "class", "r2-bar r2-vert");
    			add_location(div1, file$V, 50, 6, 1359);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$N.name,
    		type: "if",
    		source: "(49:4) {#if !fillv}",
    		ctx
    	});

    	return block;
    }

    // (48:2) <FB vert between zero c="r2-col r2-right {fillv ? 'r2-bar' : ''}">
    function create_default_slot_1$E(ctx) {
    	let if_block_anchor;
    	let if_block = !/*fillv*/ ctx[0] && create_if_block$N(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*fillv*/ ctx[0]) {
    				if (if_block) ; else {
    					if_block = create_if_block$N(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$E.name,
    		type: "slot",
    		source: "(48:2) <FB vert between zero c=\\\"r2-col r2-right {fillv ? 'r2-bar' : ''}\\\">",
    		ctx
    	});

    	return block;
    }

    // (22:0) <FB expand zero {c}>
    function create_default_slot$_(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let fb2;
    	let current;

    	fb0 = new FB({
    			props: {
    				vert: true,
    				between: true,
    				zero: true,
    				c: "r2-col r2-left " + (/*fillv*/ ctx[0] ? 'r2-bar' : ''),
    				$$slots: { default: [create_default_slot_6$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				vert: true,
    				expand: true,
    				zero: true,
    				between: true,
    				c: "r2-col r2-mid",
    				$$slots: { default: [create_default_slot_2$v] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb2 = new FB({
    			props: {
    				vert: true,
    				between: true,
    				zero: true,
    				c: "r2-col r2-right " + (/*fillv*/ ctx[0] ? 'r2-bar' : ''),
    				$$slots: { default: [create_default_slot_1$E] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    			create_component(fb2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};
    			if (dirty & /*fillv*/ 1) fb0_changes.c = "r2-col r2-left " + (/*fillv*/ ctx[0] ? 'r2-bar' : '');

    			if (dirty & /*$$scope, fillv*/ 513) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope, fillh, $$slots*/ 522) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    			const fb2_changes = {};
    			if (dirty & /*fillv*/ 1) fb2_changes.c = "r2-col r2-right " + (/*fillv*/ ctx[0] ? 'r2-bar' : '');

    			if (dirty & /*$$scope, fillv*/ 513) {
    				fb2_changes.$$scope = { dirty, ctx };
    			}

    			fb2.$set(fb2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(fb2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(fb2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$_.name,
    		type: "slot",
    		source: "(22:0) <FB expand zero {c}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1z(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				expand: true,
    				zero: true,
    				c: /*c*/ ctx[2],
    				$$slots: { default: [create_default_slot$_] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*c*/ 4) fb_changes.c = /*c*/ ctx[2];

    			if (dirty & /*$$scope, fillv, fillh, $$slots*/ 523) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('R2', slots, ['default']);
    	const $$slots = compute_slots(slots);
    	let { size = 5 } = $$props;
    	let { fillv = false } = $$props;
    	let { fillh = false } = $$props;
    	let { raise = false } = $$props;
    	let { hyper = false } = $$props;
    	let { abs = false } = $$props;
    	let c;

    	const mkc = () => {
    		let mc = ['r2'];
    		if (size == 'x') mc.push('r2-sx'); else mc.push(`r2-s${size * 10}`);
    		if (hyper) mc.push('r2-hyper'); else if (raise) mc.push('r2-raised');
    		if (abs) mc.push('r2-abs');
    		$$invalidate(2, c = mc);
    	};

    	const writable_props = ['size', 'fillv', 'fillh', 'raise', 'hyper', 'abs'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<R2> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('fillv' in $$props) $$invalidate(0, fillv = $$props.fillv);
    		if ('fillh' in $$props) $$invalidate(1, fillh = $$props.fillh);
    		if ('raise' in $$props) $$invalidate(5, raise = $$props.raise);
    		if ('hyper' in $$props) $$invalidate(6, hyper = $$props.hyper);
    		if ('abs' in $$props) $$invalidate(7, abs = $$props.abs);
    		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		size,
    		fillv,
    		fillh,
    		raise,
    		hyper,
    		abs,
    		c,
    		mkc
    	});

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('fillv' in $$props) $$invalidate(0, fillv = $$props.fillv);
    		if ('fillh' in $$props) $$invalidate(1, fillh = $$props.fillh);
    		if ('raise' in $$props) $$invalidate(5, raise = $$props.raise);
    		if ('hyper' in $$props) $$invalidate(6, hyper = $$props.hyper);
    		if ('abs' in $$props) $$invalidate(7, abs = $$props.abs);
    		if ('c' in $$props) $$invalidate(2, c = $$props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*size, raise, abs*/ 176) {
    			mkc();
    		}
    	};

    	return [fillv, fillh, c, $$slots, size, raise, hyper, abs, slots, $$scope];
    }

    class R2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1z, create_fragment$1z, safe_not_equal, {
    			size: 4,
    			fillv: 0,
    			fillh: 1,
    			raise: 5,
    			hyper: 6,
    			abs: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "R2",
    			options,
    			id: create_fragment$1z.name
    		});
    	}

    	get size() {
    		throw new Error("<R2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<R2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillv() {
    		throw new Error("<R2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillv(value) {
    		throw new Error("<R2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillh() {
    		throw new Error("<R2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillh(value) {
    		throw new Error("<R2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get raise() {
    		throw new Error("<R2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set raise(value) {
    		throw new Error("<R2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hyper() {
    		throw new Error("<R2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hyper(value) {
    		throw new Error("<R2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get abs() {
    		throw new Error("<R2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set abs(value) {
    		throw new Error("<R2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/r2/R2Hider.svelte generated by Svelte v3.44.3 */
    const file$U = "src/r2/R2Hider.svelte";
    const get_hidable_slot_changes = dirty => ({});
    const get_hidable_slot_context = ctx => ({});
    const get_inner_slot_changes$1 = dirty => ({});
    const get_inner_slot_context$1 = ctx => ({});

    // (11:0) {#if hide}
    function create_if_block_2$i(ctx) {
    	let r2;
    	let current;

    	r2 = new R2({
    			props: {
    				size: /*size*/ ctx[0],
    				fillh: /*fillh*/ ctx[2],
    				fillv: /*fillv*/ ctx[1],
    				raise: true,
    				hyper: /*hyper*/ ctx[4],
    				abs: true,
    				$$slots: { default: [create_default_slot$Z] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(r2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(r2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const r2_changes = {};
    			if (dirty & /*size*/ 1) r2_changes.size = /*size*/ ctx[0];
    			if (dirty & /*fillh*/ 4) r2_changes.fillh = /*fillh*/ ctx[2];
    			if (dirty & /*fillv*/ 2) r2_changes.fillv = /*fillv*/ ctx[1];
    			if (dirty & /*hyper*/ 16) r2_changes.hyper = /*hyper*/ ctx[4];

    			if (dirty & /*$$scope, $$slots*/ 160) {
    				r2_changes.$$scope = { dirty, ctx };
    			}

    			r2.$set(r2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(r2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(r2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(r2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$i.name,
    		type: "if",
    		source: "(11:0) {#if hide}",
    		ctx
    	});

    	return block;
    }

    // (13:4) {#if $$slots.inner}
    function create_if_block_3$d(ctx) {
    	let current;
    	const inner_slot_template = /*#slots*/ ctx[6].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[7], get_inner_slot_context$1);

    	const block = {
    		c: function create() {
    			if (inner_slot) inner_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (inner_slot) {
    				inner_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[7], dirty, get_inner_slot_changes$1),
    						get_inner_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(inner_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(inner_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (inner_slot) inner_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$d.name,
    		type: "if",
    		source: "(13:4) {#if $$slots.inner}",
    		ctx
    	});

    	return block;
    }

    // (12:2) <R2 {size} {fillh} {fillv} raise {hyper} abs>
    function create_default_slot$Z(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$$slots*/ ctx[5].inner && create_if_block_3$d(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$$slots*/ ctx[5].inner) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 32) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3$d(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$Z.name,
    		type: "slot",
    		source: "(12:2) <R2 {size} {fillh} {fillv} raise {hyper} abs>",
    		ctx
    	});

    	return block;
    }

    // (21:26) 
    function create_if_block_1$r(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$r.name,
    		type: "if",
    		source: "(21:26) ",
    		ctx
    	});

    	return block;
    }

    // (17:0) {#if $$slots.hidable}
    function create_if_block$M(ctx) {
    	let div;
    	let current;
    	const hidable_slot_template = /*#slots*/ ctx[6].hidable;
    	const hidable_slot = create_slot(hidable_slot_template, ctx, /*$$scope*/ ctx[7], get_hidable_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (hidable_slot) hidable_slot.c();
    			toggle_class(div, "invis", /*hide*/ ctx[3]);
    			add_location(div, file$U, 17, 2, 363);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (hidable_slot) {
    				hidable_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (hidable_slot) {
    				if (hidable_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						hidable_slot,
    						hidable_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(hidable_slot_template, /*$$scope*/ ctx[7], dirty, get_hidable_slot_changes),
    						get_hidable_slot_context
    					);
    				}
    			}

    			if (dirty & /*hide*/ 8) {
    				toggle_class(div, "invis", /*hide*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hidable_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hidable_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (hidable_slot) hidable_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$M.name,
    		type: "if",
    		source: "(17:0) {#if $$slots.hidable}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1y(ctx) {
    	let t;
    	let current_block_type_index;
    	let if_block1;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*hide*/ ctx[3] && create_if_block_2$i(ctx);
    	const if_block_creators = [create_if_block$M, create_if_block_1$r];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$$slots*/ ctx[5].hidable) return 0;
    		if (/*$$slots*/ ctx[5].default) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*hide*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*hide*/ 8) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$i(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block1) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block1 = if_blocks[current_block_type_index];

    					if (!if_block1) {
    						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block1.c();
    					} else {
    						if_block1.p(ctx, dirty);
    					}

    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				} else {
    					if_block1 = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('R2Hider', slots, ['inner','hidable','default']);
    	const $$slots = compute_slots(slots);
    	let { size = 5 } = $$props;
    	let { fillv = false } = $$props;
    	let { fillh = false } = $$props;
    	let { hide = true } = $$props;
    	let { hyper = true } = $$props;
    	const writable_props = ['size', 'fillv', 'fillh', 'hide', 'hyper'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<R2Hider> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(0, size = $$props.size);
    		if ('fillv' in $$props) $$invalidate(1, fillv = $$props.fillv);
    		if ('fillh' in $$props) $$invalidate(2, fillh = $$props.fillh);
    		if ('hide' in $$props) $$invalidate(3, hide = $$props.hide);
    		if ('hyper' in $$props) $$invalidate(4, hyper = $$props.hyper);
    		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ R2, FB, size, fillv, fillh, hide, hyper });

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(0, size = $$props.size);
    		if ('fillv' in $$props) $$invalidate(1, fillv = $$props.fillv);
    		if ('fillh' in $$props) $$invalidate(2, fillh = $$props.fillh);
    		if ('hide' in $$props) $$invalidate(3, hide = $$props.hide);
    		if ('hyper' in $$props) $$invalidate(4, hyper = $$props.hyper);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, fillv, fillh, hide, hyper, $$slots, slots, $$scope];
    }

    class R2Hider extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1y, create_fragment$1y, safe_not_equal, {
    			size: 0,
    			fillv: 1,
    			fillh: 2,
    			hide: 3,
    			hyper: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "R2Hider",
    			options,
    			id: create_fragment$1y.name
    		});
    	}

    	get size() {
    		throw new Error("<R2Hider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<R2Hider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillv() {
    		throw new Error("<R2Hider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillv(value) {
    		throw new Error("<R2Hider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillh() {
    		throw new Error("<R2Hider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillh(value) {
    		throw new Error("<R2Hider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hide() {
    		throw new Error("<R2Hider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hide(value) {
    		throw new Error("<R2Hider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hyper() {
    		throw new Error("<R2Hider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hyper(value) {
    		throw new Error("<R2Hider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // can-promise has a crash in some versions of react native that dont have
    // standard global objects
    // https://github.com/soldair/node-qrcode/issues/157

    var canPromise = function () {
      return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then
    };

    let toSJISFunction;
    const CODEWORDS_COUNT = [
      0, // Not used
      26, 44, 70, 100, 134, 172, 196, 242, 292, 346,
      404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,
      1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,
      2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706
    ];

    /**
     * Returns the QR Code size for the specified version
     *
     * @param  {Number} version QR Code version
     * @return {Number}         size of QR code
     */
    var getSymbolSize$1 = function getSymbolSize (version) {
      if (!version) throw new Error('"version" cannot be null or undefined')
      if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40')
      return version * 4 + 17
    };

    /**
     * Returns the total number of codewords used to store data and EC information.
     *
     * @param  {Number} version QR Code version
     * @return {Number}         Data length in bits
     */
    var getSymbolTotalCodewords = function getSymbolTotalCodewords (version) {
      return CODEWORDS_COUNT[version]
    };

    /**
     * Encode data with Bose-Chaudhuri-Hocquenghem
     *
     * @param  {Number} data Value to encode
     * @return {Number}      Encoded value
     */
    var getBCHDigit = function (data) {
      let digit = 0;

      while (data !== 0) {
        digit++;
        data >>>= 1;
      }

      return digit
    };

    var setToSJISFunction = function setToSJISFunction (f) {
      if (typeof f !== 'function') {
        throw new Error('"toSJISFunc" is not a valid function.')
      }

      toSJISFunction = f;
    };

    var isKanjiModeEnabled = function () {
      return typeof toSJISFunction !== 'undefined'
    };

    var toSJIS = function toSJIS (kanji) {
      return toSJISFunction(kanji)
    };

    var utils$1 = {
    	getSymbolSize: getSymbolSize$1,
    	getSymbolTotalCodewords: getSymbolTotalCodewords,
    	getBCHDigit: getBCHDigit,
    	setToSJISFunction: setToSJISFunction,
    	isKanjiModeEnabled: isKanjiModeEnabled,
    	toSJIS: toSJIS
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    var errorCorrectionLevel = createCommonjsModule(function (module, exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };

    function fromString (string) {
      if (typeof string !== 'string') {
        throw new Error('Param is not a string')
      }

      const lcStr = string.toLowerCase();

      switch (lcStr) {
        case 'l':
        case 'low':
          return exports.L

        case 'm':
        case 'medium':
          return exports.M

        case 'q':
        case 'quartile':
          return exports.Q

        case 'h':
        case 'high':
          return exports.H

        default:
          throw new Error('Unknown EC Level: ' + string)
      }
    }

    exports.isValid = function isValid (level) {
      return level && typeof level.bit !== 'undefined' &&
        level.bit >= 0 && level.bit < 4
    };

    exports.from = function from (value, defaultValue) {
      if (exports.isValid(value)) {
        return value
      }

      try {
        return fromString(value)
      } catch (e) {
        return defaultValue
      }
    };
    });

    function BitBuffer () {
      this.buffer = [];
      this.length = 0;
    }

    BitBuffer.prototype = {

      get: function (index) {
        const bufIndex = Math.floor(index / 8);
        return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1
      },

      put: function (num, length) {
        for (let i = 0; i < length; i++) {
          this.putBit(((num >>> (length - i - 1)) & 1) === 1);
        }
      },

      getLengthInBits: function () {
        return this.length
      },

      putBit: function (bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }

        if (bit) {
          this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
        }

        this.length++;
      }
    };

    var bitBuffer = BitBuffer;

    /**
     * Helper class to handle QR Code symbol modules
     *
     * @param {Number} size Symbol size
     */
    function BitMatrix (size) {
      if (!size || size < 1) {
        throw new Error('BitMatrix size must be defined and greater than 0')
      }

      this.size = size;
      this.data = new Uint8Array(size * size);
      this.reservedBit = new Uint8Array(size * size);
    }

    /**
     * Set bit value at specified location
     * If reserved flag is set, this bit will be ignored during masking process
     *
     * @param {Number}  row
     * @param {Number}  col
     * @param {Boolean} value
     * @param {Boolean} reserved
     */
    BitMatrix.prototype.set = function (row, col, value, reserved) {
      const index = row * this.size + col;
      this.data[index] = value;
      if (reserved) this.reservedBit[index] = true;
    };

    /**
     * Returns bit value at specified location
     *
     * @param  {Number}  row
     * @param  {Number}  col
     * @return {Boolean}
     */
    BitMatrix.prototype.get = function (row, col) {
      return this.data[row * this.size + col]
    };

    /**
     * Applies xor operator at specified location
     * (used during masking process)
     *
     * @param {Number}  row
     * @param {Number}  col
     * @param {Boolean} value
     */
    BitMatrix.prototype.xor = function (row, col, value) {
      this.data[row * this.size + col] ^= value;
    };

    /**
     * Check if bit at specified location is reserved
     *
     * @param {Number}   row
     * @param {Number}   col
     * @return {Boolean}
     */
    BitMatrix.prototype.isReserved = function (row, col) {
      return this.reservedBit[row * this.size + col]
    };

    var bitMatrix = BitMatrix;

    /**
     * Alignment pattern are fixed reference pattern in defined positions
     * in a matrix symbology, which enables the decode software to re-synchronise
     * the coordinate mapping of the image modules in the event of moderate amounts
     * of distortion of the image.
     *
     * Alignment patterns are present only in QR Code symbols of version 2 or larger
     * and their number depends on the symbol version.
     */

    var alignmentPattern = createCommonjsModule(function (module, exports) {
    const getSymbolSize = utils$1.getSymbolSize;

    /**
     * Calculate the row/column coordinates of the center module of each alignment pattern
     * for the specified QR Code version.
     *
     * The alignment patterns are positioned symmetrically on either side of the diagonal
     * running from the top left corner of the symbol to the bottom right corner.
     *
     * Since positions are simmetrical only half of the coordinates are returned.
     * Each item of the array will represent in turn the x and y coordinate.
     * @see {@link getPositions}
     *
     * @param  {Number} version QR Code version
     * @return {Array}          Array of coordinate
     */
    exports.getRowColCoords = function getRowColCoords (version) {
      if (version === 1) return []

      const posCount = Math.floor(version / 7) + 2;
      const size = getSymbolSize(version);
      const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7]; // Last coord is always (size - 7)

      for (let i = 1; i < posCount - 1; i++) {
        positions[i] = positions[i - 1] - intervals;
      }

      positions.push(6); // First coord is always 6

      return positions.reverse()
    };

    /**
     * Returns an array containing the positions of each alignment pattern.
     * Each array's element represent the center point of the pattern as (x, y) coordinates
     *
     * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}
     * and filtering out the items that overlaps with finder pattern
     *
     * @example
     * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.
     * The alignment patterns, therefore, are to be centered on (row, column)
     * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).
     * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns
     * and are not therefore used for alignment patterns.
     *
     * let pos = getPositions(7)
     * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]
     *
     * @param  {Number} version QR Code version
     * @return {Array}          Array of coordinates
     */
    exports.getPositions = function getPositions (version) {
      const coords = [];
      const pos = exports.getRowColCoords(version);
      const posLength = pos.length;

      for (let i = 0; i < posLength; i++) {
        for (let j = 0; j < posLength; j++) {
          // Skip if position is occupied by finder patterns
          if ((i === 0 && j === 0) || // top-left
              (i === 0 && j === posLength - 1) || // bottom-left
              (i === posLength - 1 && j === 0)) { // top-right
            continue
          }

          coords.push([pos[i], pos[j]]);
        }
      }

      return coords
    };
    });

    const getSymbolSize = utils$1.getSymbolSize;
    const FINDER_PATTERN_SIZE = 7;

    /**
     * Returns an array containing the positions of each finder pattern.
     * Each array's element represent the top-left point of the pattern as (x, y) coordinates
     *
     * @param  {Number} version QR Code version
     * @return {Array}          Array of coordinates
     */
    var getPositions = function getPositions (version) {
      const size = getSymbolSize(version);

      return [
        // top-left
        [0, 0],
        // top-right
        [size - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size - FINDER_PATTERN_SIZE]
      ]
    };

    var finderPattern = {
    	getPositions: getPositions
    };

    /**
     * Data mask pattern reference
     * @type {Object}
     */

    var maskPattern = createCommonjsModule(function (module, exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };

    /**
     * Weighted penalty scores for the undesirable features
     * @type {Object}
     */
    const PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };

    /**
     * Check if mask pattern value is valid
     *
     * @param  {Number}  mask    Mask pattern
     * @return {Boolean}         true if valid, false otherwise
     */
    exports.isValid = function isValid (mask) {
      return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7
    };

    /**
     * Returns mask pattern from a value.
     * If value is not valid, returns undefined
     *
     * @param  {Number|String} value        Mask pattern value
     * @return {Number}                     Valid mask pattern or undefined
     */
    exports.from = function from (value) {
      return exports.isValid(value) ? parseInt(value, 10) : undefined
    };

    /**
    * Find adjacent modules in row/column with the same color
    * and assign a penalty value.
    *
    * Points: N1 + i
    * i is the amount by which the number of adjacent modules of the same color exceeds 5
    */
    exports.getPenaltyN1 = function getPenaltyN1 (data) {
      const size = data.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;

      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;

        for (let col = 0; col < size; col++) {
          let module = data.get(row, col);
          if (module === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module;
            sameCountCol = 1;
          }

          module = data.get(col, row);
          if (module === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module;
            sameCountRow = 1;
          }
        }

        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
      }

      return points
    };

    /**
     * Find 2x2 blocks with the same color and assign a penalty value
     *
     * Points: N2 * (m - 1) * (n - 1)
     */
    exports.getPenaltyN2 = function getPenaltyN2 (data) {
      const size = data.size;
      let points = 0;

      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last = data.get(row, col) +
            data.get(row, col + 1) +
            data.get(row + 1, col) +
            data.get(row + 1, col + 1);

          if (last === 4 || last === 0) points++;
        }
      }

      return points * PenaltyScores.N2
    };

    /**
     * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,
     * preceded or followed by light area 4 modules wide
     *
     * Points: N3 * number of pattern found
     */
    exports.getPenaltyN3 = function getPenaltyN3 (data) {
      const size = data.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;

      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size; col++) {
          bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col);
          if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++;

          bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row);
          if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++;
        }
      }

      return points * PenaltyScores.N3
    };

    /**
     * Calculate proportion of dark modules in entire symbol
     *
     * Points: N4 * k
     *
     * k is the rating of the deviation of the proportion of dark modules
     * in the symbol from 50% in steps of 5%
     */
    exports.getPenaltyN4 = function getPenaltyN4 (data) {
      let darkCount = 0;
      const modulesCount = data.data.length;

      for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];

      const k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10);

      return k * PenaltyScores.N4
    };

    /**
     * Return mask value at given position
     *
     * @param  {Number} maskPattern Pattern reference value
     * @param  {Number} i           Row
     * @param  {Number} j           Column
     * @return {Boolean}            Mask value
     */
    function getMaskAt (maskPattern, i, j) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000: return (i + j) % 2 === 0
        case exports.Patterns.PATTERN001: return i % 2 === 0
        case exports.Patterns.PATTERN010: return j % 3 === 0
        case exports.Patterns.PATTERN011: return (i + j) % 3 === 0
        case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0
        case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0
        case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0
        case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0

        default: throw new Error('bad maskPattern:' + maskPattern)
      }
    }

    /**
     * Apply a mask pattern to a BitMatrix
     *
     * @param  {Number}    pattern Pattern reference number
     * @param  {BitMatrix} data    BitMatrix data
     */
    exports.applyMask = function applyMask (pattern, data) {
      const size = data.size;

      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data.isReserved(row, col)) continue
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };

    /**
     * Returns the best mask pattern for data
     *
     * @param  {BitMatrix} data
     * @return {Number} Mask pattern reference number
     */
    exports.getBestMask = function getBestMask (data, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;

      for (let p = 0; p < numPatterns; p++) {
        setupFormatFunc(p);
        exports.applyMask(p, data);

        // Calculate penalty
        const penalty =
          exports.getPenaltyN1(data) +
          exports.getPenaltyN2(data) +
          exports.getPenaltyN3(data) +
          exports.getPenaltyN4(data);

        // Undo previously applied mask
        exports.applyMask(p, data);

        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p;
        }
      }

      return bestPattern
    };
    });

    const EC_BLOCKS_TABLE = [
    // L  M  Q  H
      1, 1, 1, 1,
      1, 1, 1, 1,
      1, 1, 2, 2,
      1, 2, 2, 4,
      1, 2, 4, 4,
      2, 4, 4, 4,
      2, 4, 6, 5,
      2, 4, 6, 6,
      2, 5, 8, 8,
      4, 5, 8, 8,
      4, 5, 8, 11,
      4, 8, 10, 11,
      4, 9, 12, 16,
      4, 9, 16, 16,
      6, 10, 12, 18,
      6, 10, 17, 16,
      6, 11, 16, 19,
      6, 13, 18, 21,
      7, 14, 21, 25,
      8, 16, 20, 25,
      8, 17, 23, 25,
      9, 17, 23, 34,
      9, 18, 25, 30,
      10, 20, 27, 32,
      12, 21, 29, 35,
      12, 23, 34, 37,
      12, 25, 34, 40,
      13, 26, 35, 42,
      14, 28, 38, 45,
      15, 29, 40, 48,
      16, 31, 43, 51,
      17, 33, 45, 54,
      18, 35, 48, 57,
      19, 37, 51, 60,
      19, 38, 53, 63,
      20, 40, 56, 66,
      21, 43, 59, 70,
      22, 45, 62, 74,
      24, 47, 65, 77,
      25, 49, 68, 81
    ];

    const EC_CODEWORDS_TABLE = [
    // L  M  Q  H
      7, 10, 13, 17,
      10, 16, 22, 28,
      15, 26, 36, 44,
      20, 36, 52, 64,
      26, 48, 72, 88,
      36, 64, 96, 112,
      40, 72, 108, 130,
      48, 88, 132, 156,
      60, 110, 160, 192,
      72, 130, 192, 224,
      80, 150, 224, 264,
      96, 176, 260, 308,
      104, 198, 288, 352,
      120, 216, 320, 384,
      132, 240, 360, 432,
      144, 280, 408, 480,
      168, 308, 448, 532,
      180, 338, 504, 588,
      196, 364, 546, 650,
      224, 416, 600, 700,
      224, 442, 644, 750,
      252, 476, 690, 816,
      270, 504, 750, 900,
      300, 560, 810, 960,
      312, 588, 870, 1050,
      336, 644, 952, 1110,
      360, 700, 1020, 1200,
      390, 728, 1050, 1260,
      420, 784, 1140, 1350,
      450, 812, 1200, 1440,
      480, 868, 1290, 1530,
      510, 924, 1350, 1620,
      540, 980, 1440, 1710,
      570, 1036, 1530, 1800,
      570, 1064, 1590, 1890,
      600, 1120, 1680, 1980,
      630, 1204, 1770, 2100,
      660, 1260, 1860, 2220,
      720, 1316, 1950, 2310,
      750, 1372, 2040, 2430
    ];

    /**
     * Returns the number of error correction block that the QR Code should contain
     * for the specified version and error correction level.
     *
     * @param  {Number} version              QR Code version
     * @param  {Number} errorCorrectionLevel Error correction level
     * @return {Number}                      Number of error correction blocks
     */
    var getBlocksCount = function getBlocksCount (version, errorCorrectionLevel$1) {
      switch (errorCorrectionLevel$1) {
        case errorCorrectionLevel.L:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 0]
        case errorCorrectionLevel.M:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 1]
        case errorCorrectionLevel.Q:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 2]
        case errorCorrectionLevel.H:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 3]
        default:
          return undefined
      }
    };

    /**
     * Returns the number of error correction codewords to use for the specified
     * version and error correction level.
     *
     * @param  {Number} version              QR Code version
     * @param  {Number} errorCorrectionLevel Error correction level
     * @return {Number}                      Number of error correction codewords
     */
    var getTotalCodewordsCount = function getTotalCodewordsCount (version, errorCorrectionLevel$1) {
      switch (errorCorrectionLevel$1) {
        case errorCorrectionLevel.L:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0]
        case errorCorrectionLevel.M:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1]
        case errorCorrectionLevel.Q:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2]
        case errorCorrectionLevel.H:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3]
        default:
          return undefined
      }
    };

    var errorCorrectionCode = {
    	getBlocksCount: getBlocksCount,
    	getTotalCodewordsCount: getTotalCodewordsCount
    };

    const EXP_TABLE = new Uint8Array(512);
    const LOG_TABLE = new Uint8Array(256)
    /**
     * Precompute the log and anti-log tables for faster computation later
     *
     * For each possible value in the galois field 2^8, we will pre-compute
     * the logarithm and anti-logarithm (exponential) of this value
     *
     * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}
     */
    ;(function initTables () {
      let x = 1;
      for (let i = 0; i < 255; i++) {
        EXP_TABLE[i] = x;
        LOG_TABLE[x] = i;

        x <<= 1; // multiply by 2

        // The QR code specification says to use byte-wise modulo 100011101 arithmetic.
        // This means that when a number is 256 or larger, it should be XORed with 0x11D.
        if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)
          x ^= 0x11D;
        }
      }

      // Optimization: double the size of the anti-log table so that we don't need to mod 255 to
      // stay inside the bounds (because we will mainly use this table for the multiplication of
      // two GF numbers, no more).
      // @see {@link mul}
      for (let i = 255; i < 512; i++) {
        EXP_TABLE[i] = EXP_TABLE[i - 255];
      }
    }());

    /**
     * Returns log value of n inside Galois Field
     *
     * @param  {Number} n
     * @return {Number}
     */
    var log = function log (n) {
      if (n < 1) throw new Error('log(' + n + ')')
      return LOG_TABLE[n]
    };

    /**
     * Returns anti-log value of n inside Galois Field
     *
     * @param  {Number} n
     * @return {Number}
     */
    var exp = function exp (n) {
      return EXP_TABLE[n]
    };

    /**
     * Multiplies two number inside Galois Field
     *
     * @param  {Number} x
     * @param  {Number} y
     * @return {Number}
     */
    var mul = function mul (x, y) {
      if (x === 0 || y === 0) return 0

      // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized
      // @see {@link initTables}
      return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]
    };

    var galoisField = {
    	log: log,
    	exp: exp,
    	mul: mul
    };

    var polynomial = createCommonjsModule(function (module, exports) {
    /**
     * Multiplies two polynomials inside Galois Field
     *
     * @param  {Uint8Array} p1 Polynomial
     * @param  {Uint8Array} p2 Polynomial
     * @return {Uint8Array}    Product of p1 and p2
     */
    exports.mul = function mul (p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);

      for (let i = 0; i < p1.length; i++) {
        for (let j = 0; j < p2.length; j++) {
          coeff[i + j] ^= galoisField.mul(p1[i], p2[j]);
        }
      }

      return coeff
    };

    /**
     * Calculate the remainder of polynomials division
     *
     * @param  {Uint8Array} divident Polynomial
     * @param  {Uint8Array} divisor  Polynomial
     * @return {Uint8Array}          Remainder
     */
    exports.mod = function mod (divident, divisor) {
      let result = new Uint8Array(divident);

      while ((result.length - divisor.length) >= 0) {
        const coeff = result[0];

        for (let i = 0; i < divisor.length; i++) {
          result[i] ^= galoisField.mul(divisor[i], coeff);
        }

        // remove all zeros from buffer head
        let offset = 0;
        while (offset < result.length && result[offset] === 0) offset++;
        result = result.slice(offset);
      }

      return result
    };

    /**
     * Generate an irreducible generator polynomial of specified degree
     * (used by Reed-Solomon encoder)
     *
     * @param  {Number} degree Degree of the generator polynomial
     * @return {Uint8Array}    Buffer containing polynomial coefficients
     */
    exports.generateECPolynomial = function generateECPolynomial (degree) {
      let poly = new Uint8Array([1]);
      for (let i = 0; i < degree; i++) {
        poly = exports.mul(poly, new Uint8Array([1, galoisField.exp(i)]));
      }

      return poly
    };
    });

    function ReedSolomonEncoder (degree) {
      this.genPoly = undefined;
      this.degree = degree;

      if (this.degree) this.initialize(this.degree);
    }

    /**
     * Initialize the encoder.
     * The input param should correspond to the number of error correction codewords.
     *
     * @param  {Number} degree
     */
    ReedSolomonEncoder.prototype.initialize = function initialize (degree) {
      // create an irreducible generator polynomial
      this.degree = degree;
      this.genPoly = polynomial.generateECPolynomial(this.degree);
    };

    /**
     * Encodes a chunk of data
     *
     * @param  {Uint8Array} data Buffer containing input data
     * @return {Uint8Array}      Buffer containing encoded data
     */
    ReedSolomonEncoder.prototype.encode = function encode (data) {
      if (!this.genPoly) {
        throw new Error('Encoder not initialized')
      }

      // Calculate EC for this data block
      // extends data size to data+genPoly size
      const paddedData = new Uint8Array(data.length + this.degree);
      paddedData.set(data);

      // The error correction codewords are the remainder after dividing the data codewords
      // by a generator polynomial
      const remainder = polynomial.mod(paddedData, this.genPoly);

      // return EC data blocks (last n byte, where n is the degree of genPoly)
      // If coefficients number in remainder are less than genPoly degree,
      // pad with 0s to the left to reach the needed number of coefficients
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);

        return buff
      }

      return remainder
    };

    var reedSolomonEncoder = ReedSolomonEncoder;

    /**
     * Check if QR Code version is valid
     *
     * @param  {Number}  version QR Code version
     * @return {Boolean}         true if valid version, false otherwise
     */
    var isValid = function isValid (version) {
      return !isNaN(version) && version >= 1 && version <= 40
    };

    var versionCheck = {
    	isValid: isValid
    };

    const numeric = '[0-9]+';
    const alphanumeric = '[A-Z $%*+\\-./:]+';
    let kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +
      '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +
      '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +
      '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+';
    kanji = kanji.replace(/u/g, '\\u');

    const byte = '(?:(?![A-Z0-9 $%*+\\-./:]|' + kanji + ')(?:.|[\r\n]))+';

    var KANJI = new RegExp(kanji, 'g');
    var BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\-./:]+', 'g');
    var BYTE = new RegExp(byte, 'g');
    var NUMERIC = new RegExp(numeric, 'g');
    var ALPHANUMERIC = new RegExp(alphanumeric, 'g');

    const TEST_KANJI = new RegExp('^' + kanji + '$');
    const TEST_NUMERIC = new RegExp('^' + numeric + '$');
    const TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\-./:]+$');

    var testKanji = function testKanji (str) {
      return TEST_KANJI.test(str)
    };

    var testNumeric = function testNumeric (str) {
      return TEST_NUMERIC.test(str)
    };

    var testAlphanumeric = function testAlphanumeric (str) {
      return TEST_ALPHANUMERIC.test(str)
    };

    var regex = {
    	KANJI: KANJI,
    	BYTE_KANJI: BYTE_KANJI,
    	BYTE: BYTE,
    	NUMERIC: NUMERIC,
    	ALPHANUMERIC: ALPHANUMERIC,
    	testKanji: testKanji,
    	testNumeric: testNumeric,
    	testAlphanumeric: testAlphanumeric
    };

    var mode = createCommonjsModule(function (module, exports) {
    /**
     * Numeric mode encodes data from the decimal digit set (0 - 9)
     * (byte values 30HEX to 39HEX).
     * Normally, 3 data characters are represented by 10 bits.
     *
     * @type {Object}
     */
    exports.NUMERIC = {
      id: 'Numeric',
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };

    /**
     * Alphanumeric mode encodes data from a set of 45 characters,
     * i.e. 10 numeric digits (0 - 9),
     *      26 alphabetic characters (A - Z),
     *   and 9 symbols (SP, $, %, *, +, -, ., /, :).
     * Normally, two input characters are represented by 11 bits.
     *
     * @type {Object}
     */
    exports.ALPHANUMERIC = {
      id: 'Alphanumeric',
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };

    /**
     * In byte mode, data is encoded at 8 bits per character.
     *
     * @type {Object}
     */
    exports.BYTE = {
      id: 'Byte',
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };

    /**
     * The Kanji mode efficiently encodes Kanji characters in accordance with
     * the Shift JIS system based on JIS X 0208.
     * The Shift JIS values are shifted from the JIS X 0208 values.
     * JIS X 0208 gives details of the shift coded representation.
     * Each two-byte character value is compacted to a 13-bit binary codeword.
     *
     * @type {Object}
     */
    exports.KANJI = {
      id: 'Kanji',
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };

    /**
     * Mixed mode will contain a sequences of data in a combination of any of
     * the modes described above
     *
     * @type {Object}
     */
    exports.MIXED = {
      bit: -1
    };

    /**
     * Returns the number of bits needed to store the data length
     * according to QR Code specifications.
     *
     * @param  {Mode}   mode    Data mode
     * @param  {Number} version QR Code version
     * @return {Number}         Number of bits
     */
    exports.getCharCountIndicator = function getCharCountIndicator (mode, version) {
      if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)

      if (!versionCheck.isValid(version)) {
        throw new Error('Invalid version: ' + version)
      }

      if (version >= 1 && version < 10) return mode.ccBits[0]
      else if (version < 27) return mode.ccBits[1]
      return mode.ccBits[2]
    };

    /**
     * Returns the most efficient mode to store the specified data
     *
     * @param  {String} dataStr Input data string
     * @return {Mode}           Best mode
     */
    exports.getBestModeForData = function getBestModeForData (dataStr) {
      if (regex.testNumeric(dataStr)) return exports.NUMERIC
      else if (regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC
      else if (regex.testKanji(dataStr)) return exports.KANJI
      else return exports.BYTE
    };

    /**
     * Return mode name as string
     *
     * @param {Mode} mode Mode object
     * @returns {String}  Mode name
     */
    exports.toString = function toString (mode) {
      if (mode && mode.id) return mode.id
      throw new Error('Invalid mode')
    };

    /**
     * Check if input param is a valid mode object
     *
     * @param   {Mode}    mode Mode object
     * @returns {Boolean} True if valid mode, false otherwise
     */
    exports.isValid = function isValid (mode) {
      return mode && mode.bit && mode.ccBits
    };

    /**
     * Get mode object from its name
     *
     * @param   {String} string Mode name
     * @returns {Mode}          Mode object
     */
    function fromString (string) {
      if (typeof string !== 'string') {
        throw new Error('Param is not a string')
      }

      const lcStr = string.toLowerCase();

      switch (lcStr) {
        case 'numeric':
          return exports.NUMERIC
        case 'alphanumeric':
          return exports.ALPHANUMERIC
        case 'kanji':
          return exports.KANJI
        case 'byte':
          return exports.BYTE
        default:
          throw new Error('Unknown mode: ' + string)
      }
    }

    /**
     * Returns mode from a value.
     * If value is not a valid mode, returns defaultValue
     *
     * @param  {Mode|String} value        Encoding mode
     * @param  {Mode}        defaultValue Fallback value
     * @return {Mode}                     Encoding mode
     */
    exports.from = function from (value, defaultValue) {
      if (exports.isValid(value)) {
        return value
      }

      try {
        return fromString(value)
      } catch (e) {
        return defaultValue
      }
    };
    });

    var version = createCommonjsModule(function (module, exports) {
    // Generator polynomial used to encode version information
    const G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
    const G18_BCH = utils$1.getBCHDigit(G18);

    function getBestVersionForDataLength (mode, length, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion
        }
      }

      return undefined
    }

    function getReservedBitsCount (mode$1, version) {
      // Character count indicator + mode indicator bits
      return mode.getCharCountIndicator(mode$1, version) + 4
    }

    function getTotalBitsFromDataArray (segments, version) {
      let totalBits = 0;

      segments.forEach(function (data) {
        const reservedBits = getReservedBitsCount(data.mode, version);
        totalBits += reservedBits + data.getBitsLength();
      });

      return totalBits
    }

    function getBestVersionForMixedData (segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode.MIXED)) {
          return currentVersion
        }
      }

      return undefined
    }

    /**
     * Returns version number from a value.
     * If value is not a valid version, returns defaultValue
     *
     * @param  {Number|String} value        QR Code version
     * @param  {Number}        defaultValue Fallback value
     * @return {Number}                     QR Code version number
     */
    exports.from = function from (value, defaultValue) {
      if (versionCheck.isValid(value)) {
        return parseInt(value, 10)
      }

      return defaultValue
    };

    /**
     * Returns how much data can be stored with the specified QR code version
     * and error correction level
     *
     * @param  {Number} version              QR Code version (1-40)
     * @param  {Number} errorCorrectionLevel Error correction level
     * @param  {Mode}   mode                 Data mode
     * @return {Number}                      Quantity of storable data
     */
    exports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode$1) {
      if (!versionCheck.isValid(version)) {
        throw new Error('Invalid QR Code version')
      }

      // Use Byte mode as default
      if (typeof mode$1 === 'undefined') mode$1 = mode.BYTE;

      // Total codewords for this QR code version (Data + Error correction)
      const totalCodewords = utils$1.getSymbolTotalCodewords(version);

      // Total number of error correction codewords
      const ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);

      // Total number of data codewords
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;

      if (mode$1 === mode.MIXED) return dataTotalCodewordsBits

      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode$1, version);

      // Return max number of storable codewords
      switch (mode$1) {
        case mode.NUMERIC:
          return Math.floor((usableBits / 10) * 3)

        case mode.ALPHANUMERIC:
          return Math.floor((usableBits / 11) * 2)

        case mode.KANJI:
          return Math.floor(usableBits / 13)

        case mode.BYTE:
        default:
          return Math.floor(usableBits / 8)
      }
    };

    /**
     * Returns the minimum version needed to contain the amount of data
     *
     * @param  {Segment} data                    Segment of data
     * @param  {Number} [errorCorrectionLevel=H] Error correction level
     * @param  {Mode} mode                       Data mode
     * @return {Number}                          QR Code version
     */
    exports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel$1) {
      let seg;

      const ecl = errorCorrectionLevel.from(errorCorrectionLevel$1, errorCorrectionLevel.M);

      if (Array.isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl)
        }

        if (data.length === 0) {
          return 1
        }

        seg = data[0];
      } else {
        seg = data;
      }

      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)
    };

    /**
     * Returns version information with relative error correction bits
     *
     * The version information is included in QR Code symbols of version 7 or larger.
     * It consists of an 18-bit sequence containing 6 data bits,
     * with 12 error correction bits calculated using the (18, 6) Golay code.
     *
     * @param  {Number} version QR Code version
     * @return {Number}         Encoded version info bits
     */
    exports.getEncodedBits = function getEncodedBits (version) {
      if (!versionCheck.isValid(version) || version < 7) {
        throw new Error('Invalid QR Code version')
      }

      let d = version << 12;

      while (utils$1.getBCHDigit(d) - G18_BCH >= 0) {
        d ^= (G18 << (utils$1.getBCHDigit(d) - G18_BCH));
      }

      return (version << 12) | d
    };
    });

    const G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
    const G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);
    const G15_BCH = utils$1.getBCHDigit(G15);

    /**
     * Returns format information with relative error correction bits
     *
     * The format information is a 15-bit sequence containing 5 data bits,
     * with 10 error correction bits calculated using the (15, 5) BCH code.
     *
     * @param  {Number} errorCorrectionLevel Error correction level
     * @param  {Number} mask                 Mask pattern
     * @return {Number}                      Encoded format information bits
     */
    var getEncodedBits = function getEncodedBits (errorCorrectionLevel, mask) {
      const data = ((errorCorrectionLevel.bit << 3) | mask);
      let d = data << 10;

      while (utils$1.getBCHDigit(d) - G15_BCH >= 0) {
        d ^= (G15 << (utils$1.getBCHDigit(d) - G15_BCH));
      }

      // xor final data with mask pattern in order to ensure that
      // no combination of Error Correction Level and data mask pattern
      // will result in an all-zero data string
      return ((data << 10) | d) ^ G15_MASK
    };

    var formatInfo = {
    	getEncodedBits: getEncodedBits
    };

    function NumericData (data) {
      this.mode = mode.NUMERIC;
      this.data = data.toString();
    }

    NumericData.getBitsLength = function getBitsLength (length) {
      return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0)
    };

    NumericData.prototype.getLength = function getLength () {
      return this.data.length
    };

    NumericData.prototype.getBitsLength = function getBitsLength () {
      return NumericData.getBitsLength(this.data.length)
    };

    NumericData.prototype.write = function write (bitBuffer) {
      let i, group, value;

      // The input data string is divided into groups of three digits,
      // and each group is converted to its 10-bit binary equivalent.
      for (i = 0; i + 3 <= this.data.length; i += 3) {
        group = this.data.substr(i, 3);
        value = parseInt(group, 10);

        bitBuffer.put(value, 10);
      }

      // If the number of input digits is not an exact multiple of three,
      // the final one or two digits are converted to 4 or 7 bits respectively.
      const remainingNum = this.data.length - i;
      if (remainingNum > 0) {
        group = this.data.substr(i);
        value = parseInt(group, 10);

        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };

    var numericData = NumericData;

    /**
     * Array of characters available in alphanumeric mode
     *
     * As per QR Code specification, to each character
     * is assigned a value from 0 to 44 which in this case coincides
     * with the array index
     *
     * @type {Array}
     */
    const ALPHA_NUM_CHARS = [
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
      'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
      ' ', '$', '%', '*', '+', '-', '.', '/', ':'
    ];

    function AlphanumericData (data) {
      this.mode = mode.ALPHANUMERIC;
      this.data = data;
    }

    AlphanumericData.getBitsLength = function getBitsLength (length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2)
    };

    AlphanumericData.prototype.getLength = function getLength () {
      return this.data.length
    };

    AlphanumericData.prototype.getBitsLength = function getBitsLength () {
      return AlphanumericData.getBitsLength(this.data.length)
    };

    AlphanumericData.prototype.write = function write (bitBuffer) {
      let i;

      // Input data characters are divided into groups of two characters
      // and encoded as 11-bit binary codes.
      for (i = 0; i + 2 <= this.data.length; i += 2) {
        // The character value of the first character is multiplied by 45
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;

        // The character value of the second digit is added to the product
        value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);

        // The sum is then stored as 11-bit binary number
        bitBuffer.put(value, 11);
      }

      // If the number of input data characters is not a multiple of two,
      // the character value of the final character is encoded as a 6-bit binary number.
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
      }
    };

    var alphanumericData = AlphanumericData;

    var encodeUtf8 = function encodeUtf8 (input) {
      var result = [];
      var size = input.length;

      for (var index = 0; index < size; index++) {
        var point = input.charCodeAt(index);

        if (point >= 0xD800 && point <= 0xDBFF && size > index + 1) {
          var second = input.charCodeAt(index + 1);

          if (second >= 0xDC00 && second <= 0xDFFF) {
            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            point = (point - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            index += 1;
          }
        }

        // US-ASCII
        if (point < 0x80) {
          result.push(point);
          continue
        }

        // 2-byte UTF-8
        if (point < 0x800) {
          result.push((point >> 6) | 192);
          result.push((point & 63) | 128);
          continue
        }

        // 3-byte UTF-8
        if (point < 0xD800 || (point >= 0xE000 && point < 0x10000)) {
          result.push((point >> 12) | 224);
          result.push(((point >> 6) & 63) | 128);
          result.push((point & 63) | 128);
          continue
        }

        // 4-byte UTF-8
        if (point >= 0x10000 && point <= 0x10FFFF) {
          result.push((point >> 18) | 240);
          result.push(((point >> 12) & 63) | 128);
          result.push(((point >> 6) & 63) | 128);
          result.push((point & 63) | 128);
          continue
        }

        // Invalid character
        result.push(0xEF, 0xBF, 0xBD);
      }

      return new Uint8Array(result).buffer
    };

    function ByteData (data) {
      this.mode = mode.BYTE;
      this.data = new Uint8Array(encodeUtf8(data));
    }

    ByteData.getBitsLength = function getBitsLength (length) {
      return length * 8
    };

    ByteData.prototype.getLength = function getLength () {
      return this.data.length
    };

    ByteData.prototype.getBitsLength = function getBitsLength () {
      return ByteData.getBitsLength(this.data.length)
    };

    ByteData.prototype.write = function (bitBuffer) {
      for (let i = 0, l = this.data.length; i < l; i++) {
        bitBuffer.put(this.data[i], 8);
      }
    };

    var byteData = ByteData;

    function KanjiData (data) {
      this.mode = mode.KANJI;
      this.data = data;
    }

    KanjiData.getBitsLength = function getBitsLength (length) {
      return length * 13
    };

    KanjiData.prototype.getLength = function getLength () {
      return this.data.length
    };

    KanjiData.prototype.getBitsLength = function getBitsLength () {
      return KanjiData.getBitsLength(this.data.length)
    };

    KanjiData.prototype.write = function (bitBuffer) {
      let i;

      // In the Shift JIS system, Kanji characters are represented by a two byte combination.
      // These byte values are shifted from the JIS X 0208 values.
      // JIS X 0208 gives details of the shift coded representation.
      for (i = 0; i < this.data.length; i++) {
        let value = utils$1.toSJIS(this.data[i]);

        // For characters with Shift JIS values from 0x8140 to 0x9FFC:
        if (value >= 0x8140 && value <= 0x9FFC) {
          // Subtract 0x8140 from Shift JIS value
          value -= 0x8140;

        // For characters with Shift JIS values from 0xE040 to 0xEBBF
        } else if (value >= 0xE040 && value <= 0xEBBF) {
          // Subtract 0xC140 from Shift JIS value
          value -= 0xC140;
        } else {
          throw new Error(
            'Invalid SJIS character: ' + this.data[i] + '\n' +
            'Make sure your charset is UTF-8')
        }

        // Multiply most significant byte of result by 0xC0
        // and add least significant byte to product
        value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff);

        // Convert result to a 13-bit binary string
        bitBuffer.put(value, 13);
      }
    };

    var kanjiData = KanjiData;

    var dijkstra_1 = createCommonjsModule(function (module) {

    /******************************************************************************
     * Created 2008-08-19.
     *
     * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.
     *
     * Copyright (C) 2008
     *   Wyatt Baldwin <self@wyattbaldwin.com>
     *   All rights reserved
     *
     * Licensed under the MIT license.
     *
     *   http://www.opensource.org/licenses/mit-license.php
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *****************************************************************************/
    var dijkstra = {
      single_source_shortest_paths: function(graph, s, d) {
        // Predecessor map for each node that has been encountered.
        // node ID => predecessor node ID
        var predecessors = {};

        // Costs of shortest paths from s to all nodes encountered.
        // node ID => cost
        var costs = {};
        costs[s] = 0;

        // Costs of shortest paths from s to all nodes encountered; differs from
        // `costs` in that it provides easy access to the node that currently has
        // the known shortest path from s.
        // XXX: Do we actually need both `costs` and `open`?
        var open = dijkstra.PriorityQueue.make();
        open.push(s, 0);

        var closest,
            u, v,
            cost_of_s_to_u,
            adjacent_nodes,
            cost_of_e,
            cost_of_s_to_u_plus_cost_of_e,
            cost_of_s_to_v,
            first_visit;
        while (!open.empty()) {
          // In the nodes remaining in graph that have a known cost from s,
          // find the node, u, that currently has the shortest path from s.
          closest = open.pop();
          u = closest.value;
          cost_of_s_to_u = closest.cost;

          // Get nodes adjacent to u...
          adjacent_nodes = graph[u] || {};

          // ...and explore the edges that connect u to those nodes, updating
          // the cost of the shortest paths to any or all of those nodes as
          // necessary. v is the node across the current edge from u.
          for (v in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v)) {
              // Get the cost of the edge running from u to v.
              cost_of_e = adjacent_nodes[v];

              // Cost of s to u plus the cost of u to v across e--this is *a*
              // cost from s to v that may or may not be less than the current
              // known cost to v.
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;

              // If we haven't visited v yet OR if the current known cost from s to
              // v is greater than the new cost we just found (cost of s to u plus
              // cost of u to v across e), update v's cost in the cost list and
              // update v's predecessor in the predecessor list (it's now u).
              cost_of_s_to_v = costs[v];
              first_visit = (typeof costs[v] === 'undefined');
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v] = u;
              }
            }
          }
        }

        if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {
          var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');
          throw new Error(msg);
        }

        return predecessors;
      },

      extract_shortest_path_from_predecessor_list: function(predecessors, d) {
        var nodes = [];
        var u = d;
        while (u) {
          nodes.push(u);
          u = predecessors[u];
        }
        nodes.reverse();
        return nodes;
      },

      find_path: function(graph, s, d) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors, d);
      },

      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function (opts) {
          var T = dijkstra.PriorityQueue,
              t = {},
              key;
          opts = opts || {};
          for (key in T) {
            if (T.hasOwnProperty(key)) {
              t[key] = T[key];
            }
          }
          t.queue = [];
          t.sorter = opts.sorter || T.default_sorter;
          return t;
        },

        default_sorter: function (a, b) {
          return a.cost - b.cost;
        },

        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function (value, cost) {
          var item = {value: value, cost: cost};
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },

        /**
         * Return the highest priority element in the queue.
         */
        pop: function () {
          return this.queue.shift();
        },

        empty: function () {
          return this.queue.length === 0;
        }
      }
    };


    // node.js module exports
    {
      module.exports = dijkstra;
    }
    });

    var segments = createCommonjsModule(function (module, exports) {
    /**
     * Returns UTF8 byte length
     *
     * @param  {String} str Input string
     * @return {Number}     Number of byte
     */
    function getStringByteLength (str) {
      return unescape(encodeURIComponent(str)).length
    }

    /**
     * Get a list of segments of the specified mode
     * from a string
     *
     * @param  {Mode}   mode Segment mode
     * @param  {String} str  String to process
     * @return {Array}       Array of object with segments data
     */
    function getSegments (regex, mode, str) {
      const segments = [];
      let result;

      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode: mode,
          length: result[0].length
        });
      }

      return segments
    }

    /**
     * Extracts a series of segments with the appropriate
     * modes from a string
     *
     * @param  {String} dataStr Input string
     * @return {Array}          Array of object with segments data
     */
    function getSegmentsFromString (dataStr) {
      const numSegs = getSegments(regex.NUMERIC, mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(regex.ALPHANUMERIC, mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;

      if (utils$1.isKanjiModeEnabled()) {
        byteSegs = getSegments(regex.BYTE, mode.BYTE, dataStr);
        kanjiSegs = getSegments(regex.KANJI, mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(regex.BYTE_KANJI, mode.BYTE, dataStr);
        kanjiSegs = [];
      }

      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);

      return segs
        .sort(function (s1, s2) {
          return s1.index - s2.index
        })
        .map(function (obj) {
          return {
            data: obj.data,
            mode: obj.mode,
            length: obj.length
          }
        })
    }

    /**
     * Returns how many bits are needed to encode a string of
     * specified length with the specified mode
     *
     * @param  {Number} length String length
     * @param  {Mode} mode     Segment mode
     * @return {Number}        Bit length
     */
    function getSegmentBitsLength (length, mode$1) {
      switch (mode$1) {
        case mode.NUMERIC:
          return numericData.getBitsLength(length)
        case mode.ALPHANUMERIC:
          return alphanumericData.getBitsLength(length)
        case mode.KANJI:
          return kanjiData.getBitsLength(length)
        case mode.BYTE:
          return byteData.getBitsLength(length)
      }
    }

    /**
     * Merges adjacent segments which have the same mode
     *
     * @param  {Array} segs Array of object with segments data
     * @return {Array}      Array of object with segments data
     */
    function mergeSegments (segs) {
      return segs.reduce(function (acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc
        }

        acc.push(curr);
        return acc
      }, [])
    }

    /**
     * Generates a list of all possible nodes combination which
     * will be used to build a segments graph.
     *
     * Nodes are divided by groups. Each group will contain a list of all the modes
     * in which is possible to encode the given text.
     *
     * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.
     * The group for '12345' will contain then 3 objects, one for each
     * possible encoding mode.
     *
     * Each node represents a possible segment.
     *
     * @param  {Array} segs Array of object with segments data
     * @return {Array}      Array of object with segments data
     */
    function buildNodes (segs) {
      const nodes = [];
      for (let i = 0; i < segs.length; i++) {
        const seg = segs[i];

        switch (seg.mode) {
          case mode.NUMERIC:
            nodes.push([seg,
              { data: seg.data, mode: mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: mode.BYTE, length: seg.length }
            ]);
            break
          case mode.ALPHANUMERIC:
            nodes.push([seg,
              { data: seg.data, mode: mode.BYTE, length: seg.length }
            ]);
            break
          case mode.KANJI:
            nodes.push([seg,
              { data: seg.data, mode: mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break
          case mode.BYTE:
            nodes.push([
              { data: seg.data, mode: mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }

      return nodes
    }

    /**
     * Builds a graph from a list of nodes.
     * All segments in each node group will be connected with all the segments of
     * the next group and so on.
     *
     * At each connection will be assigned a weight depending on the
     * segment's byte length.
     *
     * @param  {Array} nodes    Array of object with segments data
     * @param  {Number} version QR Code version
     * @return {Object}         Graph of all possible segments
     */
    function buildGraph (nodes, version) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ['start'];

      for (let i = 0; i < nodes.length; i++) {
        const nodeGroup = nodes[i];
        const currentNodeIds = [];

        for (let j = 0; j < nodeGroup.length; j++) {
          const node = nodeGroup[j];
          const key = '' + i + j;

          currentNodeIds.push(key);
          table[key] = { node: node, lastCount: 0 };
          graph[key] = {};

          for (let n = 0; n < prevNodeIds.length; n++) {
            const prevNodeId = prevNodeIds[n];

            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] =
                getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -
                getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);

              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;

              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +
                4 + mode.getCharCountIndicator(node.mode, version); // switch cost
            }
          }
        }

        prevNodeIds = currentNodeIds;
      }

      for (let n = 0; n < prevNodeIds.length; n++) {
        graph[prevNodeIds[n]].end = 0;
      }

      return { map: graph, table: table }
    }

    /**
     * Builds a segment from a specified data and mode.
     * If a mode is not specified, the more suitable will be used.
     *
     * @param  {String} data             Input data
     * @param  {Mode | String} modesHint Data mode
     * @return {Segment}                 Segment
     */
    function buildSingleSegment (data, modesHint) {
      let mode$1;
      const bestMode = mode.getBestModeForData(data);

      mode$1 = mode.from(modesHint, bestMode);

      // Make sure data can be encoded
      if (mode$1 !== mode.BYTE && mode$1.bit < bestMode.bit) {
        throw new Error('"' + data + '"' +
          ' cannot be encoded with mode ' + mode.toString(mode$1) +
          '.\n Suggested mode is: ' + mode.toString(bestMode))
      }

      // Use Mode.BYTE if Kanji support is disabled
      if (mode$1 === mode.KANJI && !utils$1.isKanjiModeEnabled()) {
        mode$1 = mode.BYTE;
      }

      switch (mode$1) {
        case mode.NUMERIC:
          return new numericData(data)

        case mode.ALPHANUMERIC:
          return new alphanumericData(data)

        case mode.KANJI:
          return new kanjiData(data)

        case mode.BYTE:
          return new byteData(data)
      }
    }

    /**
     * Builds a list of segments from an array.
     * Array can contain Strings or Objects with segment's info.
     *
     * For each item which is a string, will be generated a segment with the given
     * string and the more appropriate encoding mode.
     *
     * For each item which is an object, will be generated a segment with the given
     * data and mode.
     * Objects must contain at least the property "data".
     * If property "mode" is not present, the more suitable mode will be used.
     *
     * @param  {Array} array Array of objects with segments data
     * @return {Array}       Array of Segments
     */
    exports.fromArray = function fromArray (array) {
      return array.reduce(function (acc, seg) {
        if (typeof seg === 'string') {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }

        return acc
      }, [])
    };

    /**
     * Builds an optimized sequence of segments from a string,
     * which will produce the shortest possible bitstream.
     *
     * @param  {String} data    Input string
     * @param  {Number} version QR Code version
     * @return {Array}          Array of segments
     */
    exports.fromString = function fromString (data, version) {
      const segs = getSegmentsFromString(data);

      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version);
      const path = dijkstra_1.find_path(graph.map, 'start', 'end');

      const optimizedSegs = [];
      for (let i = 1; i < path.length - 1; i++) {
        optimizedSegs.push(graph.table[path[i]].node);
      }

      return exports.fromArray(mergeSegments(optimizedSegs))
    };

    /**
     * Splits a string in various segments with the modes which
     * best represent their content.
     * The produced segments are far from being optimized.
     * The output of this function is only used to estimate a QR Code version
     * which may contain the data.
     *
     * @param  {string} data Input string
     * @return {Array}       Array of segments
     */
    exports.rawSplit = function rawSplit (data) {
      return exports.fromArray(
        getSegmentsFromString(data)
      )
    };
    });

    /**
     * QRCode for JavaScript
     *
     * modified by Ryan Day for nodejs support
     * Copyright (c) 2011 Ryan Day
     *
     * Licensed under the MIT license:
     *   http://www.opensource.org/licenses/mit-license.php
     *
    //---------------------------------------------------------------------
    // QRCode for JavaScript
    //
    // Copyright (c) 2009 Kazuhiko Arase
    //
    // URL: http://www.d-project.com/
    //
    // Licensed under the MIT license:
    //   http://www.opensource.org/licenses/mit-license.php
    //
    // The word "QR Code" is registered trademark of
    // DENSO WAVE INCORPORATED
    //   http://www.denso-wave.com/qrcode/faqpatent-e.html
    //
    //---------------------------------------------------------------------
    */

    /**
     * Add finder patterns bits to matrix
     *
     * @param  {BitMatrix} matrix  Modules matrix
     * @param  {Number}    version QR Code version
     */
    function setupFinderPattern (matrix, version) {
      const size = matrix.size;
      const pos = finderPattern.getPositions(version);

      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];

        for (let r = -1; r <= 7; r++) {
          if (row + r <= -1 || size <= row + r) continue

          for (let c = -1; c <= 7; c++) {
            if (col + c <= -1 || size <= col + c) continue

            if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||
              (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||
              (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }

    /**
     * Add timing pattern bits to matrix
     *
     * Note: this function must be called before {@link setupAlignmentPattern}
     *
     * @param  {BitMatrix} matrix Modules matrix
     */
    function setupTimingPattern (matrix) {
      const size = matrix.size;

      for (let r = 8; r < size - 8; r++) {
        const value = r % 2 === 0;
        matrix.set(r, 6, value, true);
        matrix.set(6, r, value, true);
      }
    }

    /**
     * Add alignment patterns bits to matrix
     *
     * Note: this function must be called after {@link setupTimingPattern}
     *
     * @param  {BitMatrix} matrix  Modules matrix
     * @param  {Number}    version QR Code version
     */
    function setupAlignmentPattern (matrix, version) {
      const pos = alignmentPattern.getPositions(version);

      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];

        for (let r = -2; r <= 2; r++) {
          for (let c = -2; c <= 2; c++) {
            if (r === -2 || r === 2 || c === -2 || c === 2 ||
              (r === 0 && c === 0)) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }

    /**
     * Add version info bits to matrix
     *
     * @param  {BitMatrix} matrix  Modules matrix
     * @param  {Number}    version QR Code version
     */
    function setupVersionInfo (matrix, version$1) {
      const size = matrix.size;
      const bits = version.getEncodedBits(version$1);
      let row, col, mod;

      for (let i = 0; i < 18; i++) {
        row = Math.floor(i / 3);
        col = i % 3 + size - 8 - 3;
        mod = ((bits >> i) & 1) === 1;

        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }

    /**
     * Add format info bits to matrix
     *
     * @param  {BitMatrix} matrix               Modules matrix
     * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level
     * @param  {Number}    maskPattern          Mask pattern reference value
     */
    function setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {
      const size = matrix.size;
      const bits = formatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i, mod;

      for (i = 0; i < 15; i++) {
        mod = ((bits >> i) & 1) === 1;

        // vertical
        if (i < 6) {
          matrix.set(i, 8, mod, true);
        } else if (i < 8) {
          matrix.set(i + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i, 8, mod, true);
        }

        // horizontal
        if (i < 8) {
          matrix.set(8, size - i - 1, mod, true);
        } else if (i < 9) {
          matrix.set(8, 15 - i - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i - 1, mod, true);
        }
      }

      // fixed module
      matrix.set(size - 8, 8, 1, true);
    }

    /**
     * Add encoded data bits to matrix
     *
     * @param  {BitMatrix}  matrix Modules matrix
     * @param  {Uint8Array} data   Data codewords
     */
    function setupData (matrix, data) {
      const size = matrix.size;
      let inc = -1;
      let row = size - 1;
      let bitIndex = 7;
      let byteIndex = 0;

      for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6) col--;

        while (true) {
          for (let c = 0; c < 2; c++) {
            if (!matrix.isReserved(row, col - c)) {
              let dark = false;

              if (byteIndex < data.length) {
                dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);
              }

              matrix.set(row, col - c, dark);
              bitIndex--;

              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }

          row += inc;

          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break
          }
        }
      }
    }

    /**
     * Create encoded codewords from data input
     *
     * @param  {Number}   version              QR Code version
     * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level
     * @param  {ByteData} data                 Data input
     * @return {Uint8Array}                    Buffer containing encoded codewords
     */
    function createData (version, errorCorrectionLevel, segments) {
      // Prepare data buffer
      const buffer = new bitBuffer();

      segments.forEach(function (data) {
        // prefix data with mode indicator (4 bits)
        buffer.put(data.mode.bit, 4);

        // Prefix data with character count indicator.
        // The character count indicator is a string of bits that represents the
        // number of characters that are being encoded.
        // The character count indicator must be placed after the mode indicator
        // and must be a certain number of bits long, depending on the QR version
        // and data mode
        // @see {@link Mode.getCharCountIndicator}.
        buffer.put(data.getLength(), mode.getCharCountIndicator(data.mode, version));

        // add binary data sequence to buffer
        data.write(buffer);
      });

      // Calculate required number of bits
      const totalCodewords = utils$1.getSymbolTotalCodewords(version);
      const ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;

      // Add a terminator.
      // If the bit string is shorter than the total number of required bits,
      // a terminator of up to four 0s must be added to the right side of the string.
      // If the bit string is more than four bits shorter than the required number of bits,
      // add four 0s to the end.
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }

      // If the bit string is fewer than four bits shorter, add only the number of 0s that
      // are needed to reach the required number of bits.

      // After adding the terminator, if the number of bits in the string is not a multiple of 8,
      // pad the string on the right with 0s to make the string's length a multiple of 8.
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }

      // Add pad bytes if the string is still shorter than the total number of required bits.
      // Extend the buffer to fill the data capacity of the symbol corresponding to
      // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)
      // and 00010001 (0x11) alternately.
      const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (let i = 0; i < remainingByte; i++) {
        buffer.put(i % 2 ? 0x11 : 0xEC, 8);
      }

      return createCodewords(buffer, version, errorCorrectionLevel)
    }

    /**
     * Encode input data with Reed-Solomon and return codewords with
     * relative error correction bits
     *
     * @param  {BitBuffer} bitBuffer            Data to encode
     * @param  {Number}    version              QR Code version
     * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level
     * @return {Uint8Array}                     Buffer containing encoded codewords
     */
    function createCodewords (bitBuffer, version, errorCorrectionLevel) {
      // Total codewords for this QR code version (Data + Error correction)
      const totalCodewords = utils$1.getSymbolTotalCodewords(version);

      // Total number of error correction codewords
      const ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);

      // Total number of data codewords
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;

      // Total number of blocks
      const ecTotalBlocks = errorCorrectionCode.getBlocksCount(version, errorCorrectionLevel);

      // Calculate how many blocks each group should contain
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;

      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);

      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;

      // Number of EC codewords is the same for both groups
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;

      // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount
      const rs = new reedSolomonEncoder(ecCount);

      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer);

      // Divide the buffer into the required number of blocks
      for (let b = 0; b < ecTotalBlocks; b++) {
        const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;

        // extract a block of data from buffer
        dcData[b] = buffer.slice(offset, offset + dataSize);

        // Calculate EC codewords for this data block
        ecData[b] = rs.encode(dcData[b]);

        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }

      // Create final data
      // Interleave the data and error correction codewords from each block
      const data = new Uint8Array(totalCodewords);
      let index = 0;
      let i, r;

      // Add data codewords
      for (i = 0; i < maxDataSize; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          if (i < dcData[r].length) {
            data[index++] = dcData[r][i];
          }
        }
      }

      // Apped EC codewords
      for (i = 0; i < ecCount; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          data[index++] = ecData[r][i];
        }
      }

      return data
    }

    /**
     * Build QR Code symbol
     *
     * @param  {String} data                 Input string
     * @param  {Number} version              QR Code version
     * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level
     * @param  {MaskPattern} maskPattern     Mask pattern
     * @return {Object}                      Object containing symbol data
     */
    function createSymbol (data, version$1, errorCorrectionLevel, maskPattern$1) {
      let segments$1;

      if (Array.isArray(data)) {
        segments$1 = segments.fromArray(data);
      } else if (typeof data === 'string') {
        let estimatedVersion = version$1;

        if (!estimatedVersion) {
          const rawSegments = segments.rawSplit(data);

          // Estimate best version that can contain raw splitted segments
          estimatedVersion = version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }

        // Build optimized segments
        // If estimated version is undefined, try with the highest version
        segments$1 = segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error('Invalid data')
      }

      // Get the min version that can contain data
      const bestVersion = version.getBestVersionForData(segments$1, errorCorrectionLevel);

      // If no version is found, data cannot be stored
      if (!bestVersion) {
        throw new Error('The amount of data is too big to be stored in a QR Code')
      }

      // If not specified, use min version as default
      if (!version$1) {
        version$1 = bestVersion;

      // Check if the specified version can contain the data
      } else if (version$1 < bestVersion) {
        throw new Error('\n' +
          'The chosen QR Code version cannot contain this amount of data.\n' +
          'Minimum version required to store current data is: ' + bestVersion + '.\n'
        )
      }

      const dataBits = createData(version$1, errorCorrectionLevel, segments$1);

      // Allocate matrix buffer
      const moduleCount = utils$1.getSymbolSize(version$1);
      const modules = new bitMatrix(moduleCount);

      // Add function modules
      setupFinderPattern(modules, version$1);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version$1);

      // Add temporary dummy bits for format info just to set them as reserved.
      // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}
      // since the masking operation must be performed only on the encoding region.
      // These blocks will be replaced with correct values later in code.
      setupFormatInfo(modules, errorCorrectionLevel, 0);

      if (version$1 >= 7) {
        setupVersionInfo(modules, version$1);
      }

      // Add data codewords
      setupData(modules, dataBits);

      if (isNaN(maskPattern$1)) {
        // Find best mask pattern
        maskPattern$1 = maskPattern.getBestMask(modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel));
      }

      // Apply mask pattern
      maskPattern.applyMask(maskPattern$1, modules);

      // Replace format info bits with correct values
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern$1);

      return {
        modules: modules,
        version: version$1,
        errorCorrectionLevel: errorCorrectionLevel,
        maskPattern: maskPattern$1,
        segments: segments$1
      }
    }

    /**
     * QR Code
     *
     * @param {String | Array} data                 Input data
     * @param {Object} options                      Optional configurations
     * @param {Number} options.version              QR Code version
     * @param {String} options.errorCorrectionLevel Error correction level
     * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis
     */
    var create$1 = function create (data, options) {
      if (typeof data === 'undefined' || data === '') {
        throw new Error('No input text')
      }

      let errorCorrectionLevel$1 = errorCorrectionLevel.M;
      let version$1;
      let mask;

      if (typeof options !== 'undefined') {
        // Use higher error correction level as default
        errorCorrectionLevel$1 = errorCorrectionLevel.from(options.errorCorrectionLevel, errorCorrectionLevel.M);
        version$1 = version.from(options.version);
        mask = maskPattern.from(options.maskPattern);

        if (options.toSJISFunc) {
          utils$1.setToSJISFunction(options.toSJISFunc);
        }
      }

      return createSymbol(data, version$1, errorCorrectionLevel$1, mask)
    };

    var qrcode = {
    	create: create$1
    };

    var utils = createCommonjsModule(function (module, exports) {
    function hex2rgba (hex) {
      if (typeof hex === 'number') {
        hex = hex.toString();
      }

      if (typeof hex !== 'string') {
        throw new Error('Color should be defined as hex string')
      }

      let hexCode = hex.slice().replace('#', '').split('');
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error('Invalid hex color: ' + hex)
      }

      // Convert from short to long form (fff -> ffffff)
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {
          return [c, c]
        }));
      }

      // Add default alpha value
      if (hexCode.length === 6) hexCode.push('F', 'F');

      const hexValue = parseInt(hexCode.join(''), 16);

      return {
        r: (hexValue >> 24) & 255,
        g: (hexValue >> 16) & 255,
        b: (hexValue >> 8) & 255,
        a: hexValue & 255,
        hex: '#' + hexCode.slice(0, 6).join('')
      }
    }

    exports.getOptions = function getOptions (options) {
      if (!options) options = {};
      if (!options.color) options.color = {};

      const margin = typeof options.margin === 'undefined' ||
        options.margin === null ||
        options.margin < 0
        ? 4
        : options.margin;

      const width = options.width && options.width >= 21 ? options.width : undefined;
      const scale = options.scale || 4;

      return {
        width: width,
        scale: width ? 4 : scale,
        margin: margin,
        color: {
          dark: hex2rgba(options.color.dark || '#000000ff'),
          light: hex2rgba(options.color.light || '#ffffffff')
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      }
    };

    exports.getScale = function getScale (qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2
        ? opts.width / (qrSize + opts.margin * 2)
        : opts.scale
    };

    exports.getImageWidth = function getImageWidth (qrSize, opts) {
      const scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale)
    };

    exports.qrToImageData = function qrToImageData (imgData, qr, opts) {
      const size = qr.modules.size;
      const data = qr.modules.data;
      const scale = exports.getScale(size, opts);
      const symbolSize = Math.floor((size + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];

      for (let i = 0; i < symbolSize; i++) {
        for (let j = 0; j < symbolSize; j++) {
          let posDst = (i * symbolSize + j) * 4;
          let pxColor = opts.color.light;

          if (i >= scaledMargin && j >= scaledMargin &&
            i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i - scaledMargin) / scale);
            const jSrc = Math.floor((j - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }

          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
    });

    var canvas = createCommonjsModule(function (module, exports) {
    function clearCanvas (ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!canvas.style) canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + 'px';
      canvas.style.width = size + 'px';
    }

    function getCanvasElement () {
      try {
        return document.createElement('canvas')
      } catch (e) {
        throw new Error('You need to specify a canvas element')
      }
    }

    exports.render = function render (qrData, canvas, options) {
      let opts = options;
      let canvasEl = canvas;

      if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = undefined;
      }

      if (!canvas) {
        canvasEl = getCanvasElement();
      }

      opts = utils.getOptions(opts);
      const size = utils.getImageWidth(qrData.modules.size, opts);

      const ctx = canvasEl.getContext('2d');
      const image = ctx.createImageData(size, size);
      utils.qrToImageData(image.data, qrData, opts);

      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);

      return canvasEl
    };

    exports.renderToDataURL = function renderToDataURL (qrData, canvas, options) {
      let opts = options;

      if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = undefined;
      }

      if (!opts) opts = {};

      const canvasEl = exports.render(qrData, canvas, opts);

      const type = opts.type || 'image/png';
      const rendererOpts = opts.rendererOpts || {};

      return canvasEl.toDataURL(type, rendererOpts.quality)
    };
    });

    function getColorAttrib (color, attrib) {
      const alpha = color.a / 255;
      const str = attrib + '="' + color.hex + '"';

      return alpha < 1
        ? str + ' ' + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"'
        : str
    }

    function svgCmd (cmd, x, y) {
      let str = cmd + x;
      if (typeof y !== 'undefined') str += ' ' + y;

      return str
    }

    function qrToPath (data, size, margin) {
      let path = '';
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;

      for (let i = 0; i < data.length; i++) {
        const col = Math.floor(i % size);
        const row = Math.floor(i / size);

        if (!col && !newRow) newRow = true;

        if (data[i]) {
          lineLength++;

          if (!(i > 0 && col > 0 && data[i - 1])) {
            path += newRow
              ? svgCmd('M', col + margin, 0.5 + row + margin)
              : svgCmd('m', moveBy, 0);

            moveBy = 0;
            newRow = false;
          }

          if (!(col + 1 < size && data[i + 1])) {
            path += svgCmd('h', lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }

      return path
    }

    var render$1 = function render (qrData, options, cb) {
      const opts = utils.getOptions(options);
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const qrcodesize = size + opts.margin * 2;

      const bg = !opts.color.light.a
        ? ''
        : '<path ' + getColorAttrib(opts.color.light, 'fill') +
          ' d="M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z"/>';

      const path =
        '<path ' + getColorAttrib(opts.color.dark, 'stroke') +
        ' d="' + qrToPath(data, size, opts.margin) + '"/>';

      const viewBox = 'viewBox="' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '"';

      const width = !opts.width ? '' : 'width="' + opts.width + '" height="' + opts.width + '" ';

      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + '</svg>\n';

      if (typeof cb === 'function') {
        cb(null, svgTag);
      }

      return svgTag
    };

    var svgTag = {
    	render: render$1
    };

    function renderCanvas (renderFunc, canvas, text, opts, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === 'function';

      if (!isLastArgCb && !canPromise()) {
        throw new Error('Callback required as last argument')
      }

      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error('Too few arguments provided')
        }

        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = undefined;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === 'undefined') {
            cb = opts;
            opts = undefined;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = undefined;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error('Too few arguments provided')
        }

        if (argsNum === 1) {
          text = canvas;
          canvas = opts = undefined;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = undefined;
        }

        return new Promise(function (resolve, reject) {
          try {
            const data = qrcode.create(text, opts);
            resolve(renderFunc(data, canvas, opts));
          } catch (e) {
            reject(e);
          }
        })
      }

      try {
        const data = qrcode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e) {
        cb(e);
      }
    }

    var create = qrcode.create;
    var toCanvas = renderCanvas.bind(null, canvas.render);
    var toDataURL = renderCanvas.bind(null, canvas.renderToDataURL);

    // only svg for now.
    var toString = renderCanvas.bind(null, function (data, _, opts) {
      return svgTag.render(data, opts)
    });

    var browser = {
    	create: create,
    	toCanvas: toCanvas,
    	toDataURL: toDataURL,
    	toString: toString
    };

    /* src/QR.svelte generated by Svelte v3.44.3 */

    const { console: console_1$6 } = globals;
    const file$T = "src/QR.svelte";

    // (53:26) 
    function create_if_block_2$h(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "QR CODE FAILED";
    			attr_dev(span, "class", "uitxt s3txt");
    			add_location(span, file$T, 53, 8, 1466);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$h.name,
    		type: "if",
    		source: "(53:26) ",
    		ctx
    	});

    	return block;
    }

    // (51:6) {#if size > 65}
    function create_if_block_1$q(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "FAILED TO GENERATE QR CODE";
    			attr_dev(span, "class", "uitxt s3txt");
    			add_location(span, file$T, 51, 8, 1371);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$q.name,
    		type: "if",
    		source: "(51:6) {#if size > 65}",
    		ctx
    	});

    	return block;
    }

    // (49:4) 
    function create_inner_slot$3(ctx) {
    	let div;
    	let span;
    	let t1;

    	function select_block_type(ctx, dirty) {
    		if (/*size*/ ctx[4] > 65) return create_if_block_1$q;
    		if (/*size*/ ctx[4] > 50) return create_if_block_2$h;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			span.textContent = "ERR";
    			t1 = space();
    			if (if_block) if_block.c();
    			attr_dev(span, "class", "uitxt s1txt w5txt");
    			add_location(span, file$T, 49, 6, 1298);
    			attr_dev(div, "slot", "inner");
    			add_location(div, file$T, 48, 4, 1273);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(div, t1);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (if_block) {
    				if_block.d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_inner_slot$3.name,
    		type: "slot",
    		source: "(49:4) ",
    		ctx
    	});

    	return block;
    }

    // (61:4) {:else}
    function create_else_block$n(ctx) {
    	let canvas_1;

    	const block = {
    		c: function create() {
    			canvas_1 = element("canvas");
    			attr_dev(canvas_1, "title", /*title*/ ctx[0]);
    			add_location(canvas_1, file$T, 61, 6, 1699);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, canvas_1, anchor);
    			/*canvas_1_binding_1*/ ctx[13](canvas_1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 1) {
    				attr_dev(canvas_1, "title", /*title*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(canvas_1);
    			/*canvas_1_binding_1*/ ctx[13](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$n.name,
    		type: "else",
    		source: "(61:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (59:4) {#if uuid}
    function create_if_block$L(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				nored: true,
    				uuid: /*uuid*/ ctx[1],
    				$$slots: { default: [create_default_slot_1$D] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*uuid*/ 2) link_changes.uuid = /*uuid*/ ctx[1];

    			if (dirty & /*$$scope, canvas*/ 262148) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$L.name,
    		type: "if",
    		source: "(59:4) {#if uuid}",
    		ctx
    	});

    	return block;
    }

    // (60:6) <Link nored {uuid}>
    function create_default_slot_1$D(ctx) {
    	let canvas_1;

    	const block = {
    		c: function create() {
    			canvas_1 = element("canvas");
    			add_location(canvas_1, file$T, 59, 25, 1637);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, canvas_1, anchor);
    			/*canvas_1_binding*/ ctx[12](canvas_1);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(canvas_1);
    			/*canvas_1_binding*/ ctx[12](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$D.name,
    		type: "slot",
    		source: "(60:6) <Link nored {uuid}>",
    		ctx
    	});

    	return block;
    }

    // (47:0) <FB c="qrcode" rel style={{width: `${size}px`, height: `${size}px`}}>
    function create_default_slot$Y(ctx) {
    	let r2hider;
    	let t;
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;

    	r2hider = new R2Hider({
    			props: {
    				hide: /*hidden*/ ctx[3],
    				size: 0.5,
    				$$slots: { inner: [create_inner_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$L, create_else_block$n];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*uuid*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			create_component(r2hider.$$.fragment);
    			t = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "qrcanvas");
    			toggle_class(div, "hidden", /*hidden*/ ctx[3]);
    			add_location(div, file$T, 57, 2, 1552);
    		},
    		m: function mount(target, anchor) {
    			mount_component(r2hider, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const r2hider_changes = {};
    			if (dirty & /*hidden*/ 8) r2hider_changes.hide = /*hidden*/ ctx[3];

    			if (dirty & /*$$scope, size*/ 262160) {
    				r2hider_changes.$$scope = { dirty, ctx };
    			}

    			r2hider.$set(r2hider_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			if (dirty & /*hidden*/ 8) {
    				toggle_class(div, "hidden", /*hidden*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(r2hider.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(r2hider.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(r2hider, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$Y.name,
    		type: "slot",
    		source: "(47:0) <FB c=\\\"qrcode\\\" rel style={{width: `${size}px`, height: `${size}px`}}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1x(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: "qrcode",
    				rel: true,
    				style: {
    					width: `${/*size*/ ctx[4]}px`,
    					height: `${/*size*/ ctx[4]}px`
    				},
    				$$slots: { default: [create_default_slot$Y] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*size*/ 16) fb_changes.style = {
    				width: `${/*size*/ ctx[4]}px`,
    				height: `${/*size*/ ctx[4]}px`
    			};

    			if (dirty & /*$$scope, hidden, uuid, canvas, title, size*/ 262175) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1x($$self, $$props, $$invalidate) {
    	let color;
    	let size;
    	let $usedark;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('QR', slots, []);
    	const gs = getContext('gs');
    	const usedark = getContext('usedark');
    	validate_store(usedark, 'usedark');
    	component_subscribe($$self, usedark, value => $$invalidate(11, $usedark = value));
    	let { data } = $$props;
    	let { title = null } = $$props;
    	let { uuid = null } = $$props;
    	let { scale = 3 } = $$props;
    	let { margin = 0 } = $$props;
    	let { ver = 1 } = $$props;
    	let { mask = null } = $$props;
    	let canvas;
    	let hidden = true;

    	const generate = data => {
    		if (typeof data == 'string') data = data.toUpperCase();

    		const opt = {
    			errorCorrectionLevel: 'L',
    			margin,
    			scale,
    			color
    		};

    		if (mask) opt.maskPattern = mask;
    		if (ver) opt.version = ver;
    		browser.toCanvas(canvas, data, opt, display);
    	};

    	const display = e => {
    		$$invalidate(3, hidden = !!e);
    		if (e) console.log(e);
    	};

    	onMount(() => generate(data));
    	const writable_props = ['data', 'title', 'uuid', 'scale', 'margin', 'ver', 'mask'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$6.warn(`<QR> was created with unknown prop '${key}'`);
    	});

    	function canvas_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			canvas = $$value;
    			$$invalidate(2, canvas);
    		});
    	}

    	function canvas_1_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			canvas = $$value;
    			$$invalidate(2, canvas);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('data' in $$props) $$invalidate(6, data = $$props.data);
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('uuid' in $$props) $$invalidate(1, uuid = $$props.uuid);
    		if ('scale' in $$props) $$invalidate(7, scale = $$props.scale);
    		if ('margin' in $$props) $$invalidate(8, margin = $$props.margin);
    		if ('ver' in $$props) $$invalidate(9, ver = $$props.ver);
    		if ('mask' in $$props) $$invalidate(10, mask = $$props.mask);
    	};

    	$$self.$capture_state = () => ({
    		Link: Link$1,
    		FB,
    		R2Hider,
    		getContext,
    		gs,
    		usedark,
    		onMount,
    		QRCode: browser,
    		data,
    		title,
    		uuid,
    		scale,
    		margin,
    		ver,
    		mask,
    		canvas,
    		hidden,
    		generate,
    		display,
    		size,
    		color,
    		$usedark
    	});

    	$$self.$inject_state = $$props => {
    		if ('data' in $$props) $$invalidate(6, data = $$props.data);
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('uuid' in $$props) $$invalidate(1, uuid = $$props.uuid);
    		if ('scale' in $$props) $$invalidate(7, scale = $$props.scale);
    		if ('margin' in $$props) $$invalidate(8, margin = $$props.margin);
    		if ('ver' in $$props) $$invalidate(9, ver = $$props.ver);
    		if ('mask' in $$props) $$invalidate(10, mask = $$props.mask);
    		if ('canvas' in $$props) $$invalidate(2, canvas = $$props.canvas);
    		if ('hidden' in $$props) $$invalidate(3, hidden = $$props.hidden);
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('color' in $$props) color = $$props.color;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data, uuid*/ 66) {
    			if (!data) $$invalidate(6, data = uuid);
    		}

    		if ($$self.$$.dirty & /*$usedark*/ 2048) {
    			color = !!$usedark
    			? { dark: '#909090ff', light: '#25252500' }
    			: { dark: '#353535ff', light: '#ffffff00' };
    		}

    		if ($$self.$$.dirty & /*ver, scale*/ 640) {
    			$$invalidate(4, size = (17 + 4 * ver) * scale);
    		}

    		if ($$self.$$.dirty & /*canvas, data, scale, margin, ver, mask, $usedark*/ 4036) {
    			if (canvas) generate(data);
    		}
    	};

    	return [
    		title,
    		uuid,
    		canvas,
    		hidden,
    		size,
    		usedark,
    		data,
    		scale,
    		margin,
    		ver,
    		mask,
    		$usedark,
    		canvas_1_binding,
    		canvas_1_binding_1
    	];
    }

    class QR extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1x, create_fragment$1x, safe_not_equal, {
    			data: 6,
    			title: 0,
    			uuid: 1,
    			scale: 7,
    			margin: 8,
    			ver: 9,
    			mask: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "QR",
    			options,
    			id: create_fragment$1x.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[6] === undefined && !('data' in props)) {
    			console_1$6.warn("<QR> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<QR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<QR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<QR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<QR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get uuid() {
    		throw new Error("<QR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set uuid(value) {
    		throw new Error("<QR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scale() {
    		throw new Error("<QR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scale(value) {
    		throw new Error("<QR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get margin() {
    		throw new Error("<QR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set margin(value) {
    		throw new Error("<QR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ver() {
    		throw new Error("<QR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ver(value) {
    		throw new Error("<QR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mask() {
    		throw new Error("<QR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mask(value) {
    		throw new Error("<QR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/util/Strike.svelte generated by Svelte v3.44.3 */

    // (5:0) <FB expand vert center c="strike">
    function create_default_slot$X(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: { c: "strikebar" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$X.name,
    		type: "slot",
    		source: "(5:0) <FB expand vert center c=\\\"strike\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1w(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				expand: true,
    				vert: true,
    				center: true,
    				c: "strike",
    				$$slots: { default: [create_default_slot$X] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Strike', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Strike> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ FB });
    	return [];
    }

    class Strike extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1w, create_fragment$1w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Strike",
    			options,
    			id: create_fragment$1w.name
    		});
    	}
    }

    /* src/UUID.svelte generated by Svelte v3.44.3 */
    const file$S = "src/UUID.svelte";

    // (8:0) {:else}
    function create_else_block$m(ctx) {
    	let span;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			attr_dev(span, "class", "uuid");
    			add_location(span, file$S, 8, 2, 168);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$m.name,
    		type: "else",
    		source: "(8:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (6:0) {#if link}
    function create_if_block$K(ctx) {
    	let span;
    	let link_1;
    	let current;

    	link_1 = new Link$1({
    			props: {
    				nored: true,
    				uuid: /*link*/ ctx[0],
    				$$slots: { default: [create_default_slot$W] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(link_1.$$.fragment);
    			attr_dev(span, "class", "uuid");
    			add_location(span, file$S, 6, 2, 94);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(link_1, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_1_changes = {};
    			if (dirty & /*link*/ 1) link_1_changes.uuid = /*link*/ ctx[0];

    			if (dirty & /*$$scope, link*/ 5) {
    				link_1_changes.$$scope = { dirty, ctx };
    			}

    			link_1.$set(link_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(link_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$K.name,
    		type: "if",
    		source: "(6:0) {#if link}",
    		ctx
    	});

    	return block;
    }

    // (7:21) <Link nored uuid={link}>
    function create_default_slot$W(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*link*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*link*/ 1) set_data_dev(t, /*link*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$W.name,
    		type: "slot",
    		source: "(7:21) <Link nored uuid={link}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1v(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$K, create_else_block$m];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*link*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('UUID', slots, ['default']);
    	let { link = false } = $$props;
    	const writable_props = ['link'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UUID> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('link' in $$props) $$invalidate(0, link = $$props.link);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ Link: Link$1, link });

    	$$self.$inject_state = $$props => {
    		if ('link' in $$props) $$invalidate(0, link = $$props.link);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [link, slots, $$scope];
    }

    class UUID extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1v, create_fragment$1v, safe_not_equal, { link: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UUID",
    			options,
    			id: create_fragment$1v.name
    		});
    	}

    	get link() {
    		throw new Error("<UUID>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set link(value) {
    		throw new Error("<UUID>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Logo.svelte generated by Svelte v3.44.3 */

    // (9:2) <FB title c="logo">
    function create_default_slot_1$C(ctx) {
    	let t_value = /*$rc*/ ctx[0].title + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$rc*/ 1 && t_value !== (t_value = /*$rc*/ ctx[0].title + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$C.name,
    		type: "slot",
    		source: "(9:2) <FB title c=\\\"logo\\\">",
    		ctx
    	});

    	return block;
    }

    // (8:0) <Link space="main" title="Home" silent>
    function create_default_slot$V(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				title: true,
    				c: "logo",
    				$$slots: { default: [create_default_slot_1$C] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, $rc*/ 5) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$V.name,
    		type: "slot",
    		source: "(8:0) <Link space=\\\"main\\\" title=\\\"Home\\\" silent>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1u(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				space: "main",
    				title: "Home",
    				silent: true,
    				$$slots: { default: [create_default_slot$V] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const link_changes = {};

    			if (dirty & /*$$scope, $rc*/ 5) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1u($$self, $$props, $$invalidate) {
    	let $rc;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Logo', slots, []);
    	const rc = getContext('rc');
    	validate_store(rc, 'rc');
    	component_subscribe($$self, rc, value => $$invalidate(0, $rc = value));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Logo> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Link: Link$1, FB, getContext, rc, $rc });
    	return [$rc, rc];
    }

    class Logo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1u, create_fragment$1u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Logo",
    			options,
    			id: create_fragment$1u.name
    		});
    	}
    }

    /* src/Bookmarks.svelte generated by Svelte v3.44.3 */

    // (7:0) <Link nst="main">
    function create_default_slot_5$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("HOME");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$h.name,
    		type: "slot",
    		source: "(7:0) <Link nst=\\\"main\\\">",
    		ctx
    	});

    	return block;
    }

    // (8:0) <Link nst="main/foo">
    function create_default_slot_4$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("foo");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$i.name,
    		type: "slot",
    		source: "(8:0) <Link nst=\\\"main/foo\\\">",
    		ctx
    	});

    	return block;
    }

    // (9:0) <Link nst="main/bar">
    function create_default_slot_3$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("bar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$m.name,
    		type: "slot",
    		source: "(9:0) <Link nst=\\\"main/bar\\\">",
    		ctx
    	});

    	return block;
    }

    // (10:0) <Link nst="main/Home">
    function create_default_slot_2$u(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("HOME 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$u.name,
    		type: "slot",
    		source: "(10:0) <Link nst=\\\"main/Home\\\">",
    		ctx
    	});

    	return block;
    }

    // (11:0) <Link nst="main/FAKE">
    function create_default_slot_1$B(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("RED LINK");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$B.name,
    		type: "slot",
    		source: "(11:0) <Link nst=\\\"main/FAKE\\\">",
    		ctx
    	});

    	return block;
    }

    // (6:0) <FB flip>
    function create_default_slot$U(ctx) {
    	let link0;
    	let t0;
    	let link1;
    	let t1;
    	let link2;
    	let t2;
    	let link3;
    	let t3;
    	let link4;
    	let current;

    	link0 = new Link$1({
    			props: {
    				nst: "main",
    				$$slots: { default: [create_default_slot_5$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link$1({
    			props: {
    				nst: "main/foo",
    				$$slots: { default: [create_default_slot_4$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link2 = new Link$1({
    			props: {
    				nst: "main/bar",
    				$$slots: { default: [create_default_slot_3$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link3 = new Link$1({
    			props: {
    				nst: "main/Home",
    				$$slots: { default: [create_default_slot_2$u] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link4 = new Link$1({
    			props: {
    				nst: "main/FAKE",
    				$$slots: { default: [create_default_slot_1$B] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link0.$$.fragment);
    			t0 = space();
    			create_component(link1.$$.fragment);
    			t1 = space();
    			create_component(link2.$$.fragment);
    			t2 = space();
    			create_component(link3.$$.fragment);
    			t3 = space();
    			create_component(link4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(link1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(link2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(link3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(link4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    			const link2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				link2_changes.$$scope = { dirty, ctx };
    			}

    			link2.$set(link2_changes);
    			const link3_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				link3_changes.$$scope = { dirty, ctx };
    			}

    			link3.$set(link3_changes);
    			const link4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				link4_changes.$$scope = { dirty, ctx };
    			}

    			link4.$set(link4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(link2.$$.fragment, local);
    			transition_in(link3.$$.fragment, local);
    			transition_in(link4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(link2.$$.fragment, local);
    			transition_out(link3.$$.fragment, local);
    			transition_out(link4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(link1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(link2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(link3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(link4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$U.name,
    		type: "slot",
    		source: "(6:0) <FB flip>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1t(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				flip: true,
    				$$slots: { default: [create_default_slot$U] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Bookmarks', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Bookmarks> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Link: Link$1, FB });
    	return [];
    }

    class Bookmarks$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1t, create_fragment$1t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Bookmarks",
    			options,
    			id: create_fragment$1t.name
    		});
    	}
    }

    /* src/UserBar.svelte generated by Svelte v3.44.3 */
    const file$R = "src/UserBar.svelte";

    // (16:2) {#if $hassess}
    function create_if_block_4$5(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_5$3, create_if_block_7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$session*/ ctx[3].val.login) return 0;
    		if (!/*$rc*/ ctx[4].singleuser) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$5.name,
    		type: "if",
    		source: "(16:2) {#if $hassess}",
    		ctx
    	});

    	return block;
    }

    // (25:30) 
    function create_if_block_7(ctx) {
    	let span;
    	let if_block = !/*generic*/ ctx[1] && create_if_block_8(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (if_block) if_block.c();
    			add_location(span, file$R, 25, 6, 578);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if (if_block) if_block.m(span, null);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*generic*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_8(ctx);
    					if_block.c();
    					if_block.m(span, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(25:30) ",
    		ctx
    	});

    	return block;
    }

    // (17:4) {#if $session.val.login}
    function create_if_block_5$3(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				nst: "CPB:user",
    				$$slots: { default: [create_default_slot_5$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};

    			if (dirty & /*$$scope, generic, $session*/ 522) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(17:4) {#if $session.val.login}",
    		ctx
    	});

    	return block;
    }

    // (26:12) {#if !generic}
    function create_if_block_8(ctx) {
    	let t_value = /*$session*/ ctx[3].val.handle + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$session*/ 8 && t_value !== (t_value = /*$session*/ ctx[3].val.handle + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(26:12) {#if !generic}",
    		ctx
    	});

    	return block;
    }

    // (21:8) {:else}
    function create_else_block$l(ctx) {
    	let t_value = /*$session*/ ctx[3].val.handle + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$session*/ 8 && t_value !== (t_value = /*$session*/ ctx[3].val.handle + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$l.name,
    		type: "else",
    		source: "(21:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (19:8) {#if generic}
    function create_if_block_6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("USER");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(19:8) {#if generic}",
    		ctx
    	});

    	return block;
    }

    // (18:6) <Link nst="CPB:user">
    function create_default_slot_5$g(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*generic*/ ctx[1]) return create_if_block_6;
    		return create_else_block$l;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$g.name,
    		type: "slot",
    		source: "(18:6) <Link nst=\\\"CPB:user\\\">",
    		ctx
    	});

    	return block;
    }

    // (29:2) {#if mini}
    function create_if_block_3$c(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				$$slots: { default: [create_default_slot_4$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$c.name,
    		type: "if",
    		source: "(29:2) {#if mini}",
    		ctx
    	});

    	return block;
    }

    // (29:12) <FB>
    function create_default_slot_4$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("/");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$h.name,
    		type: "slot",
    		source: "(29:12) <FB>",
    		ctx
    	});

    	return block;
    }

    // (32:28) 
    function create_if_block_2$g(ctx) {
    	let link0;
    	let t;
    	let link1;
    	let current;

    	link0 = new Link$1({
    			props: {
    				nst: "CPB:login",
    				$$slots: { default: [create_default_slot_3$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link$1({
    			props: {
    				nst: "CPB:register",
    				$$slots: { default: [create_default_slot_2$t] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link0.$$.fragment);
    			t = space();
    			create_component(link1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(link1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(link1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$g.name,
    		type: "if",
    		source: "(32:28) ",
    		ctx
    	});

    	return block;
    }

    // (30:2) {#if $hassess && $session.val.login}
    function create_if_block_1$p(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				first: /*logout*/ ctx[8],
    				global: true,
    				self: true,
    				info: "End your session. We'll be sorry to see you go!",
    				$$slots: { default: [create_default_slot_1$A] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$p.name,
    		type: "if",
    		source: "(30:2) {#if $hassess && $session.val.login}",
    		ctx
    	});

    	return block;
    }

    // (33:4) <Link nst="CPB:login">
    function create_default_slot_3$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("LOGIN");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$l.name,
    		type: "slot",
    		source: "(33:4) <Link nst=\\\"CPB:login\\\">",
    		ctx
    	});

    	return block;
    }

    // (34:4) <Link nst="CPB:register">
    function create_default_slot_2$t(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("REGISTER");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$t.name,
    		type: "slot",
    		source: "(34:4) <Link nst=\\\"CPB:register\\\">",
    		ctx
    	});

    	return block;
    }

    // (31:4) <Link first={logout} global self info="End your session. We'll be sorry to see you go!">
    function create_default_slot_1$A(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("LOGOUT");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$A.name,
    		type: "slot",
    		source: "(31:4) <Link first={logout} global self info=\\\"End your session. We'll be sorry to see you go!\\\">",
    		ctx
    	});

    	return block;
    }

    // (36:2) {#if mini}
    function create_if_block$J(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: { expand: true, c: "ubmini fill" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$J.name,
    		type: "if",
    		source: "(36:2) {#if mini}",
    		ctx
    	});

    	return block;
    }

    // (15:0) <FB c="user-bar" fw={7}>
    function create_default_slot$T(ctx) {
    	let t0;
    	let t1;
    	let current_block_type_index;
    	let if_block2;
    	let t2;
    	let if_block3_anchor;
    	let current;
    	let if_block0 = /*$hassess*/ ctx[2] && create_if_block_4$5(ctx);
    	let if_block1 = /*mini*/ ctx[0] && create_if_block_3$c(ctx);
    	const if_block_creators = [create_if_block_1$p, create_if_block_2$g];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$hassess*/ ctx[2] && /*$session*/ ctx[3].val.login) return 0;
    		if (!/*$rc*/ ctx[4].singleuser) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_2(ctx))) {
    		if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	let if_block3 = /*mini*/ ctx[0] && create_if_block$J(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			if_block3_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, t2, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, if_block3_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$hassess*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$hassess*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*mini*/ ctx[0]) {
    				if (if_block1) {
    					if (dirty & /*mini*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$c(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block2) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block2 = if_blocks[current_block_type_index];

    					if (!if_block2) {
    						if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block2.c();
    					} else {
    						if_block2.p(ctx, dirty);
    					}

    					transition_in(if_block2, 1);
    					if_block2.m(t2.parentNode, t2);
    				} else {
    					if_block2 = null;
    				}
    			}

    			if (/*mini*/ ctx[0]) {
    				if (if_block3) {
    					if (dirty & /*mini*/ 1) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block$J(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(t2);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(if_block3_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$T.name,
    		type: "slot",
    		source: "(15:0) <FB c=\\\"user-bar\\\" fw={7}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1s(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: "user-bar",
    				fw: 7,
    				$$slots: { default: [create_default_slot$T] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, mini, $hassess, $session, $rc, generic*/ 543) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1s($$self, $$props, $$invalidate) {
    	let $hassess;
    	let $session;
    	let $rc;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('UserBar', slots, []);
    	const rc = getContext('rc');
    	validate_store(rc, 'rc');
    	component_subscribe($$self, rc, value => $$invalidate(4, $rc = value));
    	const session = getContext('session');
    	validate_store(session, 'session');
    	component_subscribe($$self, session, value => $$invalidate(3, $session = value));
    	const hassess = getContext('hassess');
    	validate_store(hassess, 'hassess');
    	component_subscribe($$self, hassess, value => $$invalidate(2, $hassess = value));
    	const logout = getContext('logout');
    	let { mini = false } = $$props;
    	let { generic = false } = $$props;
    	const writable_props = ['mini', 'generic'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UserBar> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('mini' in $$props) $$invalidate(0, mini = $$props.mini);
    		if ('generic' in $$props) $$invalidate(1, generic = $$props.generic);
    	};

    	$$self.$capture_state = () => ({
    		Link: Link$1,
    		FB,
    		getContext,
    		rc,
    		session,
    		hassess,
    		logout,
    		mini,
    		generic,
    		$hassess,
    		$session,
    		$rc
    	});

    	$$self.$inject_state = $$props => {
    		if ('mini' in $$props) $$invalidate(0, mini = $$props.mini);
    		if ('generic' in $$props) $$invalidate(1, generic = $$props.generic);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [mini, generic, $hassess, $session, $rc, rc, session, hassess, logout];
    }

    class UserBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1s, create_fragment$1s, safe_not_equal, { mini: 0, generic: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UserBar",
    			options,
    			id: create_fragment$1s.name
    		});
    	}

    	get mini() {
    		throw new Error("<UserBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mini(value) {
    		throw new Error("<UserBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get generic() {
    		throw new Error("<UserBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set generic(value) {
    		throw new Error("<UserBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/TitleControls.svelte generated by Svelte v3.44.3 */
    const file$Q = "src/TitleControls.svelte";

    // (24:2) {#if $state.content}
    function create_if_block_5$2(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				self: true,
    				opt: { history: true },
    				$$slots: { default: [create_default_slot_6$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(24:2) {#if $state.content}",
    		ctx
    	});

    	return block;
    }

    // (25:3) <Link self opt={{history:true}}>
    function create_default_slot_6$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("HISTORY");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$b.name,
    		type: "slot",
    		source: "(25:3) <Link self opt={{history:true}}>",
    		ctx
    	});

    	return block;
    }

    // (27:2) {#if $state.editable}
    function create_if_block_4$4(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				self: true,
    				opt: { edit: true },
    				$$slots: { default: [create_default_slot_5$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(27:2) {#if $state.editable}",
    		ctx
    	});

    	return block;
    }

    // (28:4) <Link self opt={{edit:true}}>
    function create_default_slot_5$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("EDIT");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$f.name,
    		type: "slot",
    		source: "(28:4) <Link self opt={{edit:true}}>",
    		ctx
    	});

    	return block;
    }

    // (30:2) {#if $state.byid}
    function create_if_block_3$b(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				space: /*$page*/ ctx[2].val.namespace,
    				title: /*$page*/ ctx[2].val.title,
    				$$slots: { default: [create_default_slot_4$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*$page*/ 4) link_changes.space = /*$page*/ ctx[2].val.namespace;
    			if (dirty & /*$page*/ 4) link_changes.title = /*$page*/ ctx[2].val.title;

    			if (dirty & /*$$scope*/ 32768) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$b.name,
    		type: "if",
    		source: "(30:2) {#if $state.byid}",
    		ctx
    	});

    	return block;
    }

    // (31:4) <Link space={$page.val.namespace} title={$page.val.title}>
    function create_default_slot_4$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("ANCHOR");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$g.name,
    		type: "slot",
    		source: "(31:4) <Link space={$page.val.namespace} title={$page.val.title}>",
    		ctx
    	});

    	return block;
    }

    // (33:2) {#if $state.editing}
    function create_if_block_2$f(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				self: true,
    				opt: { edit: undefined },
    				$$slots: { default: [create_default_slot_3$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};

    			if (dirty & /*$$scope*/ 32768) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$f.name,
    		type: "if",
    		source: "(33:2) {#if $state.editing}",
    		ctx
    	});

    	return block;
    }

    // (34:4) <Link self opt={{edit:undefined}}>
    function create_default_slot_3$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("CANCEL");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$k.name,
    		type: "slot",
    		source: "(34:4) <Link self opt={{edit:undefined}}>",
    		ctx
    	});

    	return block;
    }

    // (36:2) {#if $state.history}
    function create_if_block_1$o(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				self: true,
    				opt: { history: undefined },
    				$$slots: { default: [create_default_slot_2$s] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};

    			if (dirty & /*$$scope*/ 32768) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$o.name,
    		type: "if",
    		source: "(36:2) {#if $state.history}",
    		ctx
    	});

    	return block;
    }

    // (37:4) <Link self opt={{history:undefined}}>
    function create_default_slot_2$s(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("BACK");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$s.name,
    		type: "slot",
    		source: "(37:4) <Link self opt={{history:undefined}}>",
    		ctx
    	});

    	return block;
    }

    // (39:2) {#if showany}
    function create_if_block$I(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "·";
    			attr_dev(span, "class", "content-subtitle");
    			add_location(span, file$Q, 39, 3, 1223);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$I.name,
    		type: "if",
    		source: "(39:2) {#if showany}",
    		ctx
    	});

    	return block;
    }

    // (23:1) <FB line title>
    function create_default_slot_1$z(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let span;
    	let t6_value = /*$state*/ ctx[0].label + "";
    	let t6;
    	let current;
    	let if_block0 = /*$state*/ ctx[0].content && create_if_block_5$2(ctx);
    	let if_block1 = /*$state*/ ctx[0].editable && create_if_block_4$4(ctx);
    	let if_block2 = /*$state*/ ctx[0].byid && create_if_block_3$b(ctx);
    	let if_block3 = /*$state*/ ctx[0].editing && create_if_block_2$f(ctx);
    	let if_block4 = /*$state*/ ctx[0].history && create_if_block_1$o(ctx);
    	let if_block5 = /*showany*/ ctx[1] && create_if_block$I(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			t5 = space();
    			span = element("span");
    			t6 = text(t6_value);
    			attr_dev(span, "class", "content-subtitle");
    			add_location(span, file$Q, 41, 2, 1280);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t4, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t6);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$state*/ ctx[0].content) {
    				if (if_block0) {
    					if (dirty & /*$state*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$state*/ ctx[0].editable) {
    				if (if_block1) {
    					if (dirty & /*$state*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_4$4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*$state*/ ctx[0].byid) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*$state*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_3$b(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(t2.parentNode, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*$state*/ ctx[0].editing) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*$state*/ 1) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_2$f(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t3.parentNode, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*$state*/ ctx[0].history) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*$state*/ 1) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_1$o(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t4.parentNode, t4);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*showany*/ ctx[1]) {
    				if (if_block5) ; else {
    					if_block5 = create_if_block$I(ctx);
    					if_block5.c();
    					if_block5.m(t5.parentNode, t5);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if ((!current || dirty & /*$state*/ 1) && t6_value !== (t6_value = /*$state*/ ctx[0].label + "")) set_data_dev(t6, t6_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$z.name,
    		type: "slot",
    		source: "(23:1) <FB line title>",
    		ctx
    	});

    	return block;
    }

    // (22:0) <FB vert zero>
    function create_default_slot$S(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				line: true,
    				title: true,
    				$$slots: { default: [create_default_slot_1$z] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, $state, showany, $page*/ 32775) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$S.name,
    		type: "slot",
    		source: "(22:0) <FB vert zero>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1r(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				zero: true,
    				$$slots: { default: [create_default_slot$S] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, $state, showany, $page*/ 32775) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1r($$self, $$props, $$invalidate) {
    	let showany;
    	let $state;
    	let $page;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TitleControls', slots, []);
    	const loading = getContext('loading');
    	const finished = getContext('finished');
    	const session = getContext('session');
    	const hassess = getContext('hassess');
    	const haslogin = getContext('haslogin');
    	const hashistory = getContext('hashistory');
    	const page = getContext('page');
    	validate_store(page, 'page');
    	component_subscribe($$self, page, value => $$invalidate(2, $page = value));
    	const haspage = getContext('haspage');
    	const loc = getContext('loc');
    	const editing = getContext('editing');
    	const creating = getContext('creating');
    	const state = getContext('state');
    	validate_store(state, 'state');
    	component_subscribe($$self, state, value => $$invalidate(0, $state = value));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TitleControls> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		FB,
    		Link: Link$1,
    		R2Hider,
    		getContext,
    		loading,
    		finished,
    		session,
    		hassess,
    		haslogin,
    		hashistory,
    		page,
    		haspage,
    		loc,
    		editing,
    		creating,
    		state,
    		showany,
    		$state,
    		$page
    	});

    	$$self.$inject_state = $$props => {
    		if ('showany' in $$props) $$invalidate(1, showany = $$props.showany);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$state*/ 1) {
    			$$invalidate(1, showany = $state.content || $state.editable || $state.historical || $state.editing || $state.history);
    		}
    	};

    	return [$state, showany, $page, page, state];
    }

    class TitleControls extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1r, create_fragment$1r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TitleControls",
    			options,
    			id: create_fragment$1r.name
    		});
    	}
    }

    /* src/Messenger.svelte generated by Svelte v3.44.3 */

    // (9:0) {#if $message.text}
    function create_if_block$H(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				center: true,
    				c: "messenger",
    				$$slots: { default: [create_default_slot$R] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, line, $message*/ 11) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$H.name,
    		type: "if",
    		source: "(9:0) {#if $message.text}",
    		ctx
    	});

    	return block;
    }

    // (11:4) <FB {line} c="message level-{$message.level}">
    function create_default_slot_1$y(ctx) {
    	let t_value = /*$message*/ ctx[0].text + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$message*/ 1 && t_value !== (t_value = /*$message*/ ctx[0].text + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$y.name,
    		type: "slot",
    		source: "(11:4) <FB {line} c=\\\"message level-{$message.level}\\\">",
    		ctx
    	});

    	return block;
    }

    // (10:2) <FB vert center c="messenger">
    function create_default_slot$R(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				line: /*line*/ ctx[1],
    				c: "message level-" + /*$message*/ ctx[0].level,
    				$$slots: { default: [create_default_slot_1$y] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};
    			if (dirty & /*line*/ 2) fb_changes.line = /*line*/ ctx[1];
    			if (dirty & /*$message*/ 1) fb_changes.c = "message level-" + /*$message*/ ctx[0].level;

    			if (dirty & /*$$scope, $message*/ 9) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$R.name,
    		type: "slot",
    		source: "(10:2) <FB vert center c=\\\"messenger\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1q(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$message*/ ctx[0].text && create_if_block$H(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$message*/ ctx[0].text) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$message*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$H(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1q($$self, $$props, $$invalidate) {
    	let line;
    	let $message;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Messenger', slots, []);
    	const message = getContext('message');
    	validate_store(message, 'message');
    	component_subscribe($$self, message, value => $$invalidate(0, $message = value));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Messenger> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ FB, getContext, message, line, $message });

    	$$self.$inject_state = $$props => {
    		if ('line' in $$props) $$invalidate(1, line = $$props.line);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$message*/ 1) {
    			$$invalidate(1, line = $message && $message.level == 'z' ? 's2' : 's1');
    		}
    	};

    	return [$message, line, message];
    }

    class Messenger extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1q, create_fragment$1q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Messenger",
    			options,
    			id: create_fragment$1q.name
    		});
    	}
    }

    /* src/doc/Doc.svelte generated by Svelte v3.44.3 */

    // (8:0) <FB vert {center} c="flexdoc {wc}">
    function create_default_slot$Q(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$Q.name,
    		type: "slot",
    		source: "(8:0) <FB vert {center} c=\\\"flexdoc {wc}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1p(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				center: /*center*/ ctx[0],
    				c: "flexdoc " + /*wc*/ ctx[1],
    				$$slots: { default: [create_default_slot$Q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*center*/ 1) fb_changes.center = /*center*/ ctx[0];
    			if (dirty & /*wc*/ 2) fb_changes.c = "flexdoc " + /*wc*/ ctx[1];

    			if (dirty & /*$$scope*/ 16) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1p($$self, $$props, $$invalidate) {
    	let wc;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Doc', slots, ['default']);
    	let { w = 100 } = $$props;
    	let { center = false } = $$props;
    	const writable_props = ['w', 'center'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Doc> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('w' in $$props) $$invalidate(2, w = $$props.w);
    		if ('center' in $$props) $$invalidate(0, center = $$props.center);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ FB, w, center, wc });

    	$$self.$inject_state = $$props => {
    		if ('w' in $$props) $$invalidate(2, w = $$props.w);
    		if ('center' in $$props) $$invalidate(0, center = $$props.center);
    		if ('wc' in $$props) $$invalidate(1, wc = $$props.wc);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*w*/ 4) {
    			$$invalidate(1, wc = w ? `w${w}` : '');
    		}
    	};

    	return [center, wc, w, slots, $$scope];
    }

    class Doc extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1p, create_fragment$1p, safe_not_equal, { w: 2, center: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Doc",
    			options,
    			id: create_fragment$1p.name
    		});
    	}

    	get w() {
    		throw new Error("<Doc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set w(value) {
    		throw new Error("<Doc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get center() {
    		throw new Error("<Doc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set center(value) {
    		throw new Error("<Doc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/doc/Line.svelte generated by Svelte v3.44.3 */

    // (8:0) <FB {flip} c="flexline uitxt {s}txt {s}line {input ? 'input' : ''}">
    function create_default_slot$P(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$P.name,
    		type: "slot",
    		source: "(8:0) <FB {flip} c=\\\"flexline uitxt {s}txt {s}line {input ? 'input' : ''}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1o(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				flip: /*flip*/ ctx[2],
    				c: "flexline uitxt " + /*s*/ ctx[0] + "txt " + /*s*/ ctx[0] + "line " + (/*input*/ ctx[1] ? 'input' : ''),
    				$$slots: { default: [create_default_slot$P] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*flip*/ 4) fb_changes.flip = /*flip*/ ctx[2];
    			if (dirty & /*s, input*/ 3) fb_changes.c = "flexline uitxt " + /*s*/ ctx[0] + "txt " + /*s*/ ctx[0] + "line " + (/*input*/ ctx[1] ? 'input' : '');

    			if (dirty & /*$$scope*/ 16) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Line', slots, ['default']);
    	let { s = 'n' } = $$props;
    	let { input = false } = $$props;
    	let { flip = false } = $$props;
    	const writable_props = ['s', 'input', 'flip'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Line> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('s' in $$props) $$invalidate(0, s = $$props.s);
    		if ('input' in $$props) $$invalidate(1, input = $$props.input);
    		if ('flip' in $$props) $$invalidate(2, flip = $$props.flip);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ FB, s, input, flip });

    	$$self.$inject_state = $$props => {
    		if ('s' in $$props) $$invalidate(0, s = $$props.s);
    		if ('input' in $$props) $$invalidate(1, input = $$props.input);
    		if ('flip' in $$props) $$invalidate(2, flip = $$props.flip);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [s, input, flip, slots, $$scope];
    }

    class Line$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1o, create_fragment$1o, safe_not_equal, { s: 0, input: 1, flip: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Line",
    			options,
    			id: create_fragment$1o.name
    		});
    	}

    	get s() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set s(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flip() {
    		throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flip(value) {
    		throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Pipe.svelte generated by Svelte v3.44.3 */
    const file$P = "src/Pipe.svelte";

    // (21:2) {#if a}
    function create_if_block_3$a(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: "fb-pipe-exp",
    				expand: true,
    				leaf: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$a.name,
    		type: "if",
    		source: "(21:2) {#if a}",
    		ctx
    	});

    	return block;
    }

    // (28:2) {:else}
    function create_else_block_1$3(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(28:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (22:2) {#if pipe}
    function create_if_block_1$n(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (!/*vert*/ ctx[0]) return create_if_block_2$e;
    		return create_else_block$k;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$n.name,
    		type: "if",
    		source: "(22:2) {#if pipe}",
    		ctx
    	});

    	return block;
    }

    // (25:4) {:else}
    function create_else_block$k(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "v-pipe");
    			add_location(div, file$P, 25, 6, 572);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$k.name,
    		type: "else",
    		source: "(25:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (23:4) {#if !vert}
    function create_if_block_2$e(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "h-pipe");
    			add_location(div, file$P, 23, 6, 527);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$e.name,
    		type: "if",
    		source: "(23:4) {#if !vert}",
    		ctx
    	});

    	return block;
    }

    // (31:2) {#if b}
    function create_if_block$G(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: "fb-pipe-exp",
    				expand: true,
    				leaf: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$G.name,
    		type: "if",
    		source: "(31:2) {#if b}",
    		ctx
    	});

    	return block;
    }

    // (20:0) <FB c="fb-pipe" {expand} vert={!vert} zero>
    function create_default_slot$O(ctx) {
    	let t0;
    	let current_block_type_index;
    	let if_block1;
    	let t1;
    	let if_block2_anchor;
    	let current;
    	let if_block0 = /*a*/ ctx[2] && create_if_block_3$a(ctx);
    	const if_block_creators = [create_if_block_1$n, create_else_block_1$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*pipe*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block2 = /*b*/ ctx[3] && create_if_block$G(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*a*/ ctx[2]) {
    				if (if_block0) {
    					if (dirty & /*a*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$a(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if_block1.p(ctx, dirty);

    			if (/*b*/ ctx[3]) {
    				if (if_block2) {
    					if (dirty & /*b*/ 8) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$G(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$O.name,
    		type: "slot",
    		source: "(20:0) <FB c=\\\"fb-pipe\\\" {expand} vert={!vert} zero>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1n(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: "fb-pipe",
    				expand: /*expand*/ ctx[1],
    				vert: !/*vert*/ ctx[0],
    				zero: true,
    				$$slots: { default: [create_default_slot$O] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*expand*/ 2) fb_changes.expand = /*expand*/ ctx[1];
    			if (dirty & /*vert*/ 1) fb_changes.vert = !/*vert*/ ctx[0];

    			if (dirty & /*$$scope, b, vert, a*/ 525) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Pipe', slots, ['default']);
    	const $$slots = compute_slots(slots);
    	let { left = false } = $$props;
    	let { right = false } = $$props;
    	let { center = false } = $$props;
    	let { vert = false } = $$props;
    	let { expand = false } = $$props;
    	let a = false;
    	let b = false;
    	let pipe = !$$slots.default;
    	const writable_props = ['left', 'right', 'center', 'vert', 'expand'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Pipe> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('left' in $$props) $$invalidate(6, left = $$props.left);
    		if ('right' in $$props) $$invalidate(7, right = $$props.right);
    		if ('center' in $$props) $$invalidate(5, center = $$props.center);
    		if ('vert' in $$props) $$invalidate(0, vert = $$props.vert);
    		if ('expand' in $$props) $$invalidate(1, expand = $$props.expand);
    		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		left,
    		right,
    		center,
    		vert,
    		expand,
    		a,
    		b,
    		pipe
    	});

    	$$self.$inject_state = $$props => {
    		if ('left' in $$props) $$invalidate(6, left = $$props.left);
    		if ('right' in $$props) $$invalidate(7, right = $$props.right);
    		if ('center' in $$props) $$invalidate(5, center = $$props.center);
    		if ('vert' in $$props) $$invalidate(0, vert = $$props.vert);
    		if ('expand' in $$props) $$invalidate(1, expand = $$props.expand);
    		if ('a' in $$props) $$invalidate(2, a = $$props.a);
    		if ('b' in $$props) $$invalidate(3, b = $$props.b);
    		if ('pipe' in $$props) $$invalidate(4, pipe = $$props.pipe);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*left, right, center*/ 224) {
    			if (!left && !right && !center) $$invalidate(5, center = true);
    		}

    		if ($$self.$$.dirty & /*left, right, center*/ 224) {
    			if (left) $$invalidate(3, b = true); else if (right) $$invalidate(2, a = true); else if (center) {
    				$$invalidate(2, a = true);
    				$$invalidate(3, b = true);
    			}
    		}
    	};

    	return [vert, expand, a, b, pipe, center, left, right, slots, $$scope];
    }

    class Pipe extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1n, create_fragment$1n, safe_not_equal, {
    			left: 6,
    			right: 7,
    			center: 5,
    			vert: 0,
    			expand: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Pipe",
    			options,
    			id: create_fragment$1n.name
    		});
    	}

    	get left() {
    		throw new Error("<Pipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set left(value) {
    		throw new Error("<Pipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get right() {
    		throw new Error("<Pipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set right(value) {
    		throw new Error("<Pipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get center() {
    		throw new Error("<Pipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set center(value) {
    		throw new Error("<Pipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vert() {
    		throw new Error("<Pipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vert(value) {
    		throw new Error("<Pipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expand() {
    		throw new Error("<Pipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expand(value) {
    		throw new Error("<Pipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/doc/Lab.svelte generated by Svelte v3.44.3 */

    // (12:2) <FB vert center c="flexlab-txt">
    function create_default_slot_1$x(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*txt*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*txt*/ 1) set_data_dev(t, /*txt*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$x.name,
    		type: "slot",
    		source: "(12:2) <FB vert center c=\\\"flexlab-txt\\\">",
    		ctx
    	});

    	return block;
    }

    // (13:2) {#if between}
    function create_if_block$F(ctx) {
    	let pipe;
    	let current;
    	pipe = new Pipe({ props: { expand: true }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(pipe.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pipe, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pipe.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pipe.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pipe, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$F.name,
    		type: "if",
    		source: "(13:2) {#if between}",
    		ctx
    	});

    	return block;
    }

    // (11:0) <FB {between} {flip} c="flexlab {wc}">
    function create_default_slot$N(ctx) {
    	let fb;
    	let t0;
    	let t1;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				center: true,
    				c: "flexlab-txt",
    				$$slots: { default: [create_default_slot_1$x] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*between*/ ctx[1] && create_if_block$F(ctx);
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t1, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, txt*/ 65) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);

    			if (/*between*/ ctx[1]) {
    				if (if_block) {
    					if (dirty & /*between*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$F(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t1.parentNode, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$N.name,
    		type: "slot",
    		source: "(11:0) <FB {between} {flip} c=\\\"flexlab {wc}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1m(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				between: /*between*/ ctx[1],
    				flip: /*flip*/ ctx[2],
    				c: "flexlab " + /*wc*/ ctx[3],
    				$$slots: { default: [create_default_slot$N] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*between*/ 2) fb_changes.between = /*between*/ ctx[1];
    			if (dirty & /*flip*/ 4) fb_changes.flip = /*flip*/ ctx[2];
    			if (dirty & /*wc*/ 8) fb_changes.c = "flexlab " + /*wc*/ ctx[3];

    			if (dirty & /*$$scope, between, txt*/ 67) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1m($$self, $$props, $$invalidate) {
    	let wc;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Lab', slots, ['default']);
    	let { txt } = $$props;
    	let { w = null } = $$props;
    	let { between = false } = $$props;
    	let { flip = false } = $$props;
    	const writable_props = ['txt', 'w', 'between', 'flip'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Lab> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('txt' in $$props) $$invalidate(0, txt = $$props.txt);
    		if ('w' in $$props) $$invalidate(4, w = $$props.w);
    		if ('between' in $$props) $$invalidate(1, between = $$props.between);
    		if ('flip' in $$props) $$invalidate(2, flip = $$props.flip);
    		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ FB, Pipe, txt, w, between, flip, wc });

    	$$self.$inject_state = $$props => {
    		if ('txt' in $$props) $$invalidate(0, txt = $$props.txt);
    		if ('w' in $$props) $$invalidate(4, w = $$props.w);
    		if ('between' in $$props) $$invalidate(1, between = $$props.between);
    		if ('flip' in $$props) $$invalidate(2, flip = $$props.flip);
    		if ('wc' in $$props) $$invalidate(3, wc = $$props.wc);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*w*/ 16) {
    			$$invalidate(3, wc = w ? `w${w}` : '');
    		}
    	};

    	return [txt, between, flip, wc, w, slots, $$scope];
    }

    class Lab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1m, create_fragment$1m, safe_not_equal, { txt: 0, w: 4, between: 1, flip: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Lab",
    			options,
    			id: create_fragment$1m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*txt*/ ctx[0] === undefined && !('txt' in props)) {
    			console.warn("<Lab> was created without expected prop 'txt'");
    		}
    	}

    	get txt() {
    		throw new Error("<Lab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set txt(value) {
    		throw new Error("<Lab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get w() {
    		throw new Error("<Lab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set w(value) {
    		throw new Error("<Lab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get between() {
    		throw new Error("<Lab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set between(value) {
    		throw new Error("<Lab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flip() {
    		throw new Error("<Lab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flip(value) {
    		throw new Error("<Lab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/r2/R2Over.svelte generated by Svelte v3.44.3 */
    const file$O = "src/r2/R2Over.svelte";
    const get_extra_slot_changes$1 = dirty => ({});
    const get_extra_slot_context$1 = ctx => ({});
    const get_inner_slot_changes = dirty => ({});
    const get_inner_slot_context = ctx => ({});

    // (16:4) {#if show}
    function create_if_block_1$m(ctx) {
    	let r2;
    	let t;
    	let if_block_anchor;
    	let current;

    	r2 = new R2({
    			props: {
    				size: /*size*/ ctx[0],
    				fillh: /*fillh*/ ctx[2],
    				fillv: /*fillv*/ ctx[1],
    				raise: /*hide*/ ctx[4]
    			},
    			$$inline: true
    		});

    	let if_block = /*$$slots*/ ctx[7].inner && create_if_block_2$d(ctx);

    	const block = {
    		c: function create() {
    			create_component(r2.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			mount_component(r2, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const r2_changes = {};
    			if (dirty & /*size*/ 1) r2_changes.size = /*size*/ ctx[0];
    			if (dirty & /*fillh*/ 4) r2_changes.fillh = /*fillh*/ ctx[2];
    			if (dirty & /*fillv*/ 2) r2_changes.fillv = /*fillv*/ ctx[1];
    			if (dirty & /*hide*/ 16) r2_changes.raise = /*hide*/ ctx[4];
    			r2.$set(r2_changes);

    			if (/*$$slots*/ ctx[7].inner) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 128) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$d(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(r2.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(r2.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(r2, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$m.name,
    		type: "if",
    		source: "(16:4) {#if show}",
    		ctx
    	});

    	return block;
    }

    // (18:6) {#if $$slots.inner}
    function create_if_block_2$d(ctx) {
    	let div;
    	let current;
    	const inner_slot_template = /*#slots*/ ctx[8].inner;
    	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[9], get_inner_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (inner_slot) inner_slot.c();
    			attr_dev(div, "class", "r2-over-inner");
    			add_location(div, file$O, 18, 8, 456);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (inner_slot) {
    				inner_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (inner_slot) {
    				if (inner_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						inner_slot,
    						inner_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[9], dirty, get_inner_slot_changes),
    						get_inner_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(inner_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(inner_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (inner_slot) inner_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$d.name,
    		type: "if",
    		source: "(18:6) {#if $$slots.inner}",
    		ctx
    	});

    	return block;
    }

    // (29:4) {#if $$slots.extra}
    function create_if_block$E(ctx) {
    	let current;
    	const extra_slot_template = /*#slots*/ ctx[8].extra;
    	const extra_slot = create_slot(extra_slot_template, ctx, /*$$scope*/ ctx[9], get_extra_slot_context$1);

    	const block = {
    		c: function create() {
    			if (extra_slot) extra_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (extra_slot) {
    				extra_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (extra_slot) {
    				if (extra_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						extra_slot,
    						extra_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(extra_slot_template, /*$$scope*/ ctx[9], dirty, get_extra_slot_changes$1),
    						get_extra_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(extra_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(extra_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (extra_slot) extra_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$E.name,
    		type: "if",
    		source: "(29:4) {#if $$slots.extra}",
    		ctx
    	});

    	return block;
    }

    // (14:0) <FB leaf {expand} c="{c} r2-over">
    function create_default_slot$M(ctx) {
    	let div1;
    	let t0;
    	let div0;
    	let t1;
    	let current;
    	let if_block0 = /*show*/ ctx[5] && create_if_block_1$m(ctx);
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
    	let if_block1 = /*$$slots*/ ctx[7].extra && create_if_block$E(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "r2-inside");
    			add_location(div0, file$O, 24, 4, 563);
    			attr_dev(div1, "class", "r2-wrapper");
    			add_location(div1, file$O, 14, 2, 333);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			append_dev(div1, t1);
    			if (if_block1) if_block1.m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*show*/ ctx[5]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*show*/ 32) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$m(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*$$slots*/ ctx[7].extra) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 128) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$E(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(default_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(default_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (default_slot) default_slot.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$M.name,
    		type: "slot",
    		source: "(14:0) <FB leaf {expand} c=\\\"{c} r2-over\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1l(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				leaf: true,
    				expand: /*expand*/ ctx[6],
    				c: "" + (/*c*/ ctx[3] + " r2-over"),
    				$$slots: { default: [create_default_slot$M] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*expand*/ 64) fb_changes.expand = /*expand*/ ctx[6];
    			if (dirty & /*c*/ 8) fb_changes.c = "" + (/*c*/ ctx[3] + " r2-over");

    			if (dirty & /*$$scope, $$slots, size, fillh, fillv, hide, show*/ 695) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('R2Over', slots, ['inner','default','extra']);
    	const $$slots = compute_slots(slots);
    	let { size = 5 } = $$props;
    	let { fillv = false } = $$props;
    	let { fillh = false } = $$props;
    	let { c = '' } = $$props;
    	let { hide = false } = $$props;
    	let { show = true } = $$props;
    	let { expand = true } = $$props;
    	const writable_props = ['size', 'fillv', 'fillh', 'c', 'hide', 'show', 'expand'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<R2Over> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(0, size = $$props.size);
    		if ('fillv' in $$props) $$invalidate(1, fillv = $$props.fillv);
    		if ('fillh' in $$props) $$invalidate(2, fillh = $$props.fillh);
    		if ('c' in $$props) $$invalidate(3, c = $$props.c);
    		if ('hide' in $$props) $$invalidate(4, hide = $$props.hide);
    		if ('show' in $$props) $$invalidate(5, show = $$props.show);
    		if ('expand' in $$props) $$invalidate(6, expand = $$props.expand);
    		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		R2,
    		FB,
    		size,
    		fillv,
    		fillh,
    		c,
    		hide,
    		show,
    		expand
    	});

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(0, size = $$props.size);
    		if ('fillv' in $$props) $$invalidate(1, fillv = $$props.fillv);
    		if ('fillh' in $$props) $$invalidate(2, fillh = $$props.fillh);
    		if ('c' in $$props) $$invalidate(3, c = $$props.c);
    		if ('hide' in $$props) $$invalidate(4, hide = $$props.hide);
    		if ('show' in $$props) $$invalidate(5, show = $$props.show);
    		if ('expand' in $$props) $$invalidate(6, expand = $$props.expand);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*c*/ 8) {
    			if (Array.isArray(c)) c.join(' ');
    		}
    	};

    	return [size, fillv, fillh, c, hide, show, expand, $$slots, slots, $$scope];
    }

    class R2Over extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1l, create_fragment$1l, safe_not_equal, {
    			size: 0,
    			fillv: 1,
    			fillh: 2,
    			c: 3,
    			hide: 4,
    			show: 5,
    			expand: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "R2Over",
    			options,
    			id: create_fragment$1l.name
    		});
    	}

    	get size() {
    		throw new Error("<R2Over>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<R2Over>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillv() {
    		throw new Error("<R2Over>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillv(value) {
    		throw new Error("<R2Over>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fillh() {
    		throw new Error("<R2Over>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fillh(value) {
    		throw new Error("<R2Over>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get c() {
    		throw new Error("<R2Over>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set c(value) {
    		throw new Error("<R2Over>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hide() {
    		throw new Error("<R2Over>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hide(value) {
    		throw new Error("<R2Over>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get show() {
    		throw new Error("<R2Over>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set show(value) {
    		throw new Error("<R2Over>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expand() {
    		throw new Error("<R2Over>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expand(value) {
    		throw new Error("<R2Over>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function outclick(node) {
    	const handleClick =e=> {
    		if (!node.contains(event.target)) {
    			node.dispatchEvent(new CustomEvent("outclick"));
    		}
    	};

    	document.addEventListener("click", handleClick, true);

    	return {
    		destroy() {
    			document.removeEventListener("click", handleClick, true);
    		}
    	}
    }

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }

      return getRandomValues(rnds8);
    }

    var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

    function validate(uuid) {
      return typeof uuid === 'string' && REGEX.test(uuid);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    var byteToHex = [];

    for (var i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).substr(1));
    }

    function stringify$1(arr) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
      // of the following:
      // - One or more input array values don't map to a hex octet (leading to
      // "undefined" in the uuid)
      // - Invalid input values for the RFC `version` or `variant` fields

      if (!validate(uuid)) {
        throw TypeError('Stringified UUID is invalid');
      }

      return uuid;
    }

    function v4(options, buf, offset) {
      options = options || {};
      var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        offset = offset || 0;

        for (var i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }

        return buf;
      }

      return stringify$1(rnds);
    }

    /* src/doc/Input.svelte generated by Svelte v3.44.3 */
    const file$N = "src/doc/Input.svelte";
    const get_options_slot_changes = dirty => ({});
    const get_options_slot_context = ctx => ({});
    const get_buttons_slot_changes = dirty => ({});
    const get_buttons_slot_context = ctx => ({});
    const get_extra_slot_changes = dirty => ({});
    const get_extra_slot_context = ctx => ({});

    // (56:8) {#if lab}
    function create_if_block_4$3(ctx) {
    	let label;
    	let t;

    	const block = {
    		c: function create() {
    			label = element("label");
    			t = text(/*lab*/ ctx[4]);
    			attr_dev(label, "for", /*id*/ ctx[9]);
    			add_location(label, file$N, 56, 10, 1341);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*lab*/ 16) set_data_dev(t, /*lab*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(56:8) {#if lab}",
    		ctx
    	});

    	return block;
    }

    // (55:6) <FB zero {flip} c="fd-input fd-text">
    function create_default_slot_5$e(ctx) {
    	let t;
    	let input_1;
    	let mounted;
    	let dispose;
    	let if_block = /*lab*/ ctx[4] && create_if_block_4$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			input_1 = element("input");
    			attr_dev(input_1, "id", /*id*/ ctx[9]);
    			attr_dev(input_1, "type", "text");
    			attr_dev(input_1, "class", "r2-input doc-text");
    			toggle_class(input_1, "centered-input", /*center*/ ctx[3]);
    			add_location(input_1, file$N, 58, 8, 1393);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, input_1, anchor);
    			/*input_1_binding*/ ctx[17](input_1);
    			set_input_value(input_1, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input_1, "input", /*input_1_input_handler*/ ctx[18]),
    					listen_dev(input_1, "focus", /*onfocus*/ ctx[10], false, false, false),
    					listen_dev(input_1, "blur", /*onblur*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*lab*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_4$3(ctx);
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*value*/ 1 && input_1.value !== /*value*/ ctx[0]) {
    				set_input_value(input_1, /*value*/ ctx[0]);
    			}

    			if (dirty & /*center*/ 8) {
    				toggle_class(input_1, "centered-input", /*center*/ ctx[3]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(input_1);
    			/*input_1_binding*/ ctx[17](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$e.name,
    		type: "slot",
    		source: "(55:6) <FB zero {flip} c=\\\"fd-input fd-text\\\">",
    		ctx
    	});

    	return block;
    }

    // (65:6) {#if focused && $$slots.extra && useExtra}
    function create_if_block_3$9(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				leaf: true,
    				c: "input-dropdown",
    				slot: "extra",
    				$$slots: { default: [create_default_slot_4$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$9.name,
    		type: "if",
    		source: "(65:6) {#if focused && $$slots.extra && useExtra}",
    		ctx
    	});

    	return block;
    }

    // (66:8) <FB leaf c="input-dropdown" slot="extra">
    function create_default_slot_4$f(ctx) {
    	let current;
    	const extra_slot_template = /*#slots*/ ctx[16].extra;
    	const extra_slot = create_slot(extra_slot_template, ctx, /*$$scope*/ ctx[19], get_extra_slot_context);

    	const block = {
    		c: function create() {
    			if (extra_slot) extra_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (extra_slot) {
    				extra_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (extra_slot) {
    				if (extra_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
    					update_slot_base(
    						extra_slot,
    						extra_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(extra_slot_template, /*$$scope*/ ctx[19], dirty, get_extra_slot_changes),
    						get_extra_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(extra_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(extra_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (extra_slot) extra_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$f.name,
    		type: "slot",
    		source: "(66:8) <FB leaf c=\\\"input-dropdown\\\" slot=\\\"extra\\\">",
    		ctx
    	});

    	return block;
    }

    // (47:4) <R2Over size={0.4} fillv={true} c="flexinput {focused ? 'focused' : ''}">
    function create_default_slot_3$j(ctx) {
    	let fb;
    	let t;
    	let if_block_anchor;
    	let current;

    	fb = new FB({
    			props: {
    				zero: true,
    				flip: /*flip*/ ctx[5],
    				c: "fd-input fd-text",
    				$$slots: { default: [create_default_slot_5$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*focused*/ ctx[1] && /*$$slots*/ ctx[12].extra && /*useExtra*/ ctx[6] && create_if_block_3$9(ctx);

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};
    			if (dirty & /*flip*/ 32) fb_changes.flip = /*flip*/ ctx[5];

    			if (dirty & /*$$scope, input, value, center, lab*/ 524569) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);

    			if (/*focused*/ ctx[1] && /*$$slots*/ ctx[12].extra && /*useExtra*/ ctx[6]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*focused, $$slots, useExtra*/ 4162) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$j.name,
    		type: "slot",
    		source: "(47:4) <R2Over size={0.4} fillv={true} c=\\\"flexinput {focused ? 'focused' : ''}\\\">",
    		ctx
    	});

    	return block;
    }

    // (49:6) {#if text && !focused && !value}
    function create_if_block_2$c(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				center: true,
    				c: "input-label",
    				$$slots: { default: [create_default_slot_2$r] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, text*/ 524292) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$c.name,
    		type: "if",
    		source: "(49:6) {#if text && !focused && !value}",
    		ctx
    	});

    	return block;
    }

    // (50:8) <FB vert center c="input-label">
    function create_default_slot_2$r(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*text*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*text*/ 4) set_data_dev(t, /*text*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$r.name,
    		type: "slot",
    		source: "(50:8) <FB vert center c=\\\"input-label\\\">",
    		ctx
    	});

    	return block;
    }

    // (48:6) <svelte:fragment slot="inner">
    function create_inner_slot$2(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*text*/ ctx[2] && !/*focused*/ ctx[1] && !/*value*/ ctx[0] && create_if_block_2$c(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*text*/ ctx[2] && !/*focused*/ ctx[1] && !/*value*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*text, focused, value*/ 7) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_inner_slot$2.name,
    		type: "slot",
    		source: "(48:6) <svelte:fragment slot=\\\"inner\\\">",
    		ctx
    	});

    	return block;
    }

    // (71:4) {#if $$slots.buttons}
    function create_if_block_1$l(ctx) {
    	let current;
    	const buttons_slot_template = /*#slots*/ ctx[16].buttons;
    	const buttons_slot = create_slot(buttons_slot_template, ctx, /*$$scope*/ ctx[19], get_buttons_slot_context);

    	const block = {
    		c: function create() {
    			if (buttons_slot) buttons_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (buttons_slot) {
    				buttons_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (buttons_slot) {
    				if (buttons_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
    					update_slot_base(
    						buttons_slot,
    						buttons_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(buttons_slot_template, /*$$scope*/ ctx[19], dirty, get_buttons_slot_changes),
    						get_buttons_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(buttons_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(buttons_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (buttons_slot) buttons_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$l.name,
    		type: "if",
    		source: "(71:4) {#if $$slots.buttons}",
    		ctx
    	});

    	return block;
    }

    // (46:2) <FB>
    function create_default_slot_1$w(ctx) {
    	let r2over;
    	let t;
    	let if_block_anchor;
    	let current;

    	r2over = new R2Over({
    			props: {
    				size: 0.4,
    				fillv: true,
    				c: "flexinput " + (/*focused*/ ctx[1] ? 'focused' : ''),
    				$$slots: {
    					inner: [create_inner_slot$2],
    					default: [create_default_slot_3$j]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$$slots*/ ctx[12].buttons && create_if_block_1$l(ctx);

    	const block = {
    		c: function create() {
    			create_component(r2over.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			mount_component(r2over, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const r2over_changes = {};
    			if (dirty & /*focused*/ 2) r2over_changes.c = "flexinput " + (/*focused*/ ctx[1] ? 'focused' : '');

    			if (dirty & /*$$scope, text, focused, value, $$slots, useExtra, flip, input, center, lab*/ 528767) {
    				r2over_changes.$$scope = { dirty, ctx };
    			}

    			r2over.$set(r2over_changes);

    			if (/*$$slots*/ ctx[12].buttons) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 4096) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$l(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(r2over.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(r2over.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(r2over, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$w.name,
    		type: "slot",
    		source: "(46:2) <FB>",
    		ctx
    	});

    	return block;
    }

    // (75:2) {#if $$slots.options}
    function create_if_block$D(ctx) {
    	let current;
    	const options_slot_template = /*#slots*/ ctx[16].options;
    	const options_slot = create_slot(options_slot_template, ctx, /*$$scope*/ ctx[19], get_options_slot_context);

    	const block = {
    		c: function create() {
    			if (options_slot) options_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (options_slot) {
    				options_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (options_slot) {
    				if (options_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
    					update_slot_base(
    						options_slot,
    						options_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(options_slot_template, /*$$scope*/ ctx[19], dirty, get_options_slot_changes),
    						get_options_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(options_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(options_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (options_slot) options_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$D.name,
    		type: "if",
    		source: "(75:2) {#if $$slots.options}",
    		ctx
    	});

    	return block;
    }

    // (45:0) <FB vert>
    function create_default_slot$L(ctx) {
    	let fb;
    	let t;
    	let if_block_anchor;
    	let current;

    	fb = new FB({
    			props: {
    				$$slots: { default: [create_default_slot_1$w] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$$slots*/ ctx[12].options && create_if_block$D(ctx);

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, $$slots, focused, text, value, useExtra, flip, input, center, lab*/ 528767) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);

    			if (/*$$slots*/ ctx[12].options) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 4096) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$D(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$L.name,
    		type: "slot",
    		source: "(45:0) <FB vert>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1k(ctx) {
    	let div;
    	let fb;
    	let current;
    	let mounted;
    	let dispose;

    	fb = new FB({
    			props: {
    				vert: true,
    				$$slots: { default: [create_default_slot$L] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(fb.$$.fragment);
    			attr_dev(div, "class", "input-wrapper");
    			add_location(div, file$N, 43, 0, 929);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(fb, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(outclick.call(null, div)),
    					listen_dev(div, "outclick", /*exit*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, $$slots, focused, text, value, useExtra, flip, input, center, lab*/ 528767) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(fb);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Input', slots, ['extra','buttons','options']);
    	const $$slots = compute_slots(slots);
    	const id = v4();
    	const dispatch = createEventDispatcher();
    	let { value = '' } = $$props;
    	let { text = '' } = $$props;
    	let { mini = false } = $$props;
    	let { focused = false } = $$props;
    	let { center = false } = $$props;
    	let { lab = '' } = $$props;
    	let { flip = false } = $$props;
    	let { useExtra = true } = $$props;
    	let input;

    	const onfocus = () => {
    		$$invalidate(1, focused = true);
    		dispatch('focus');
    		if (input) input.select();
    	};

    	const onblur = () => {
    		if (focused) input.focus();
    	};

    	const exit = () => {
    		$$invalidate(1, focused = false);
    		input.blur();
    		dispatch('blur');
    	};

    	const erase = () => {
    		$$invalidate(0, value = '');
    	};

    	const quit = () => {
    		exit();
    		erase();
    	};

    	const edited = val => {
    		dispatch('edited', { val });
    	};

    	const writable_props = ['value', 'text', 'mini', 'focused', 'center', 'lab', 'flip', 'useExtra'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Input> was created with unknown prop '${key}'`);
    	});

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			input = $$value;
    			$$invalidate(8, input);
    		});
    	}

    	function input_1_input_handler() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	$$self.$$set = $$props => {
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('text' in $$props) $$invalidate(2, text = $$props.text);
    		if ('mini' in $$props) $$invalidate(13, mini = $$props.mini);
    		if ('focused' in $$props) $$invalidate(1, focused = $$props.focused);
    		if ('center' in $$props) $$invalidate(3, center = $$props.center);
    		if ('lab' in $$props) $$invalidate(4, lab = $$props.lab);
    		if ('flip' in $$props) $$invalidate(5, flip = $$props.flip);
    		if ('useExtra' in $$props) $$invalidate(6, useExtra = $$props.useExtra);
    		if ('$$scope' in $$props) $$invalidate(19, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		R2Over,
    		FB,
    		outclick,
    		createEventDispatcher,
    		v4,
    		id,
    		dispatch,
    		value,
    		text,
    		mini,
    		focused,
    		center,
    		lab,
    		flip,
    		useExtra,
    		input,
    		onfocus,
    		onblur,
    		exit,
    		erase,
    		quit,
    		edited
    	});

    	$$self.$inject_state = $$props => {
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('text' in $$props) $$invalidate(2, text = $$props.text);
    		if ('mini' in $$props) $$invalidate(13, mini = $$props.mini);
    		if ('focused' in $$props) $$invalidate(1, focused = $$props.focused);
    		if ('center' in $$props) $$invalidate(3, center = $$props.center);
    		if ('lab' in $$props) $$invalidate(4, lab = $$props.lab);
    		if ('flip' in $$props) $$invalidate(5, flip = $$props.flip);
    		if ('useExtra' in $$props) $$invalidate(6, useExtra = $$props.useExtra);
    		if ('input' in $$props) $$invalidate(8, input = $$props.input);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 1) {
    			edited(value);
    		}
    	};

    	return [
    		value,
    		focused,
    		text,
    		center,
    		lab,
    		flip,
    		useExtra,
    		exit,
    		input,
    		id,
    		onfocus,
    		onblur,
    		$$slots,
    		mini,
    		erase,
    		quit,
    		slots,
    		input_1_binding,
    		input_1_input_handler,
    		$$scope
    	];
    }

    class Input extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1k, create_fragment$1k, safe_not_equal, {
    			value: 0,
    			text: 2,
    			mini: 13,
    			focused: 1,
    			center: 3,
    			lab: 4,
    			flip: 5,
    			useExtra: 6,
    			exit: 7,
    			erase: 14,
    			quit: 15
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Input",
    			options,
    			id: create_fragment$1k.name
    		});
    	}

    	get value() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mini() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mini(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focused() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focused(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get center() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set center(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lab() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lab(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flip() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flip(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get useExtra() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set useExtra(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get exit() {
    		return this.$$.ctx[7];
    	}

    	set exit(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get erase() {
    		return this.$$.ctx[14];
    	}

    	set erase(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get quit() {
    		return this.$$.ctx[15];
    	}

    	set quit(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/doc/Check.svelte generated by Svelte v3.44.3 */
    const file$M = "src/doc/Check.svelte";

    // (12:2) {#if lab}
    function create_if_block$C(ctx) {
    	let label;
    	let t;

    	const block = {
    		c: function create() {
    			label = element("label");
    			t = text(/*lab*/ ctx[1]);
    			attr_dev(label, "for", /*id*/ ctx[4]);
    			add_location(label, file$M, 12, 4, 261);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*lab*/ 2) set_data_dev(t, /*lab*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$C.name,
    		type: "if",
    		source: "(12:2) {#if lab}",
    		ctx
    	});

    	return block;
    }

    // (11:0) <FB zero {flip} c="fd-input fd-check" {just}>
    function create_default_slot$K(ctx) {
    	let t;
    	let input;
    	let mounted;
    	let dispose;
    	let if_block = /*lab*/ ctx[1] && create_if_block$C(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			input = element("input");
    			attr_dev(input, "id", /*id*/ ctx[4]);
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "class", "doc-check");
    			add_location(input, file$M, 14, 2, 301);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, input, anchor);
    			input.checked = /*state*/ ctx[0];

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[5]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*lab*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$C(ctx);
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*state*/ 1) {
    				input.checked = /*state*/ ctx[0];
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$K.name,
    		type: "slot",
    		source: "(11:0) <FB zero {flip} c=\\\"fd-input fd-check\\\" {just}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1j(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				zero: true,
    				flip: /*flip*/ ctx[2],
    				c: "fd-input fd-check",
    				just: /*just*/ ctx[3],
    				$$slots: { default: [create_default_slot$K] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*flip*/ 4) fb_changes.flip = /*flip*/ ctx[2];
    			if (dirty & /*just*/ 8) fb_changes.just = /*just*/ ctx[3];

    			if (dirty & /*$$scope, state, lab*/ 67) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Check', slots, []);
    	const id = v4();
    	let { lab = null } = $$props;
    	let { flip = false } = $$props;
    	let { state = false } = $$props;
    	let { just = 'c' } = $$props;
    	const writable_props = ['lab', 'flip', 'state', 'just'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Check> was created with unknown prop '${key}'`);
    	});

    	function input_change_handler() {
    		state = this.checked;
    		$$invalidate(0, state);
    	}

    	$$self.$$set = $$props => {
    		if ('lab' in $$props) $$invalidate(1, lab = $$props.lab);
    		if ('flip' in $$props) $$invalidate(2, flip = $$props.flip);
    		if ('state' in $$props) $$invalidate(0, state = $$props.state);
    		if ('just' in $$props) $$invalidate(3, just = $$props.just);
    	};

    	$$self.$capture_state = () => ({ FB, v4, id, lab, flip, state, just });

    	$$self.$inject_state = $$props => {
    		if ('lab' in $$props) $$invalidate(1, lab = $$props.lab);
    		if ('flip' in $$props) $$invalidate(2, flip = $$props.flip);
    		if ('state' in $$props) $$invalidate(0, state = $$props.state);
    		if ('just' in $$props) $$invalidate(3, just = $$props.just);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [state, lab, flip, just, id, input_change_handler];
    }

    class Check extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, { lab: 1, flip: 2, state: 0, just: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Check",
    			options,
    			id: create_fragment$1j.name
    		});
    	}

    	get lab() {
    		throw new Error("<Check>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lab(value) {
    		throw new Error("<Check>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flip() {
    		throw new Error("<Check>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flip(value) {
    		throw new Error("<Check>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get state() {
    		throw new Error("<Check>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set state(value) {
    		throw new Error("<Check>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get just() {
    		throw new Error("<Check>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set just(value) {
    		throw new Error("<Check>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/doc/Text.svelte generated by Svelte v3.44.3 */
    const file$L = "src/doc/Text.svelte";

    // (43:2) {#if lab}
    function create_if_block_1$k(ctx) {
    	let label;
    	let t;

    	const block = {
    		c: function create() {
    			label = element("label");
    			t = text(/*lab*/ ctx[4]);
    			attr_dev(label, "for", /*id*/ ctx[8]);
    			add_location(label, file$L, 43, 4, 896);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*lab*/ 16) set_data_dev(t, /*lab*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$k.name,
    		type: "if",
    		source: "(43:2) {#if lab}",
    		ctx
    	});

    	return block;
    }

    // (46:2) <R2Over size="x" fillv={true} c="flexinput {focused ? 'focused' : ''}">
    function create_default_slot_2$q(ctx) {
    	let input_1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			attr_dev(input_1, "id", /*id*/ ctx[8]);
    			attr_dev(input_1, "type", "text");
    			attr_dev(input_1, "class", "r2-input doc-text");
    			toggle_class(input_1, "centered-input", /*centertxt*/ ctx[3]);
    			add_location(input_1, file$L, 53, 6, 1185);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    			/*input_1_binding*/ ctx[14](input_1);
    			set_input_value(input_1, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input_1, "input", /*input_1_input_handler*/ ctx[15]),
    					listen_dev(input_1, "focus", /*onfocus*/ ctx[9], false, false, false),
    					listen_dev(input_1, "blur", /*onblur*/ ctx[10], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*value*/ 1 && input_1.value !== /*value*/ ctx[0]) {
    				set_input_value(input_1, /*value*/ ctx[0]);
    			}

    			if (dirty & /*centertxt*/ 8) {
    				toggle_class(input_1, "centered-input", /*centertxt*/ ctx[3]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    			/*input_1_binding*/ ctx[14](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$q.name,
    		type: "slot",
    		source: "(46:2) <R2Over size=\\\"x\\\" fillv={true} c=\\\"flexinput {focused ? 'focused' : ''}\\\">",
    		ctx
    	});

    	return block;
    }

    // (48:4) {#if text && !focused && !value}
    function create_if_block$B(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				center: true,
    				c: "input-label",
    				$$slots: { default: [create_default_slot_1$v] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, text*/ 262148) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$B.name,
    		type: "if",
    		source: "(48:4) {#if text && !focused && !value}",
    		ctx
    	});

    	return block;
    }

    // (49:6) <FB vert center c="input-label">
    function create_default_slot_1$v(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*text*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*text*/ 4) set_data_dev(t, /*text*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$v.name,
    		type: "slot",
    		source: "(49:6) <FB vert center c=\\\"input-label\\\">",
    		ctx
    	});

    	return block;
    }

    // (47:4) <svelte:fragment slot="inner">
    function create_inner_slot$1(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*text*/ ctx[2] && !/*focused*/ ctx[1] && !/*value*/ ctx[0] && create_if_block$B(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*text*/ ctx[2] && !/*focused*/ ctx[1] && !/*value*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*text, focused, value*/ 7) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$B(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_inner_slot$1.name,
    		type: "slot",
    		source: "(47:4) <svelte:fragment slot=\\\"inner\\\">",
    		ctx
    	});

    	return block;
    }

    // (42:0) <FB zero {flip} c="fd-input fd-text" {center}>
    function create_default_slot$J(ctx) {
    	let t;
    	let r2over;
    	let current;
    	let if_block = /*lab*/ ctx[4] && create_if_block_1$k(ctx);

    	r2over = new R2Over({
    			props: {
    				size: "x",
    				fillv: true,
    				c: "flexinput " + (/*focused*/ ctx[1] ? 'focused' : ''),
    				$$slots: {
    					inner: [create_inner_slot$1],
    					default: [create_default_slot_2$q]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(r2over.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(r2over, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*lab*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$k(ctx);
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const r2over_changes = {};
    			if (dirty & /*focused*/ 2) r2over_changes.c = "flexinput " + (/*focused*/ ctx[1] ? 'focused' : '');

    			if (dirty & /*$$scope, text, focused, value, input, centertxt*/ 262287) {
    				r2over_changes.$$scope = { dirty, ctx };
    			}

    			r2over.$set(r2over_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(r2over.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(r2over.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(r2over, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$J.name,
    		type: "slot",
    		source: "(42:0) <FB zero {flip} c=\\\"fd-input fd-text\\\" {center}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1i(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				zero: true,
    				flip: /*flip*/ ctx[5],
    				c: "fd-input fd-text",
    				center: /*center*/ ctx[6],
    				$$slots: { default: [create_default_slot$J] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*flip*/ 32) fb_changes.flip = /*flip*/ ctx[5];
    			if (dirty & /*center*/ 64) fb_changes.center = /*center*/ ctx[6];

    			if (dirty & /*$$scope, focused, text, value, input, centertxt, lab*/ 262303) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	const id = v4();
    	const dispatch = createEventDispatcher();
    	let { value = '' } = $$props;
    	let { text = '' } = $$props;
    	let { focused = false } = $$props;
    	let { centertxt = false } = $$props;
    	let { lab = '' } = $$props;
    	let { flip = false } = $$props;
    	let { center = true } = $$props;
    	let input;

    	const onfocus = () => {
    		$$invalidate(1, focused = true);
    		dispatch('focus');
    		if (input) input.select();
    	};

    	const onblur = () => {
    		exit();
    	};

    	const exit = () => {
    		$$invalidate(1, focused = false);
    		input.blur();
    		dispatch('blur');
    	};

    	const erase = () => {
    		$$invalidate(0, value = '');
    	};

    	const quit = () => {
    		exit();
    		erase();
    	};

    	const edited = val => {
    		dispatch('edited', { val });
    	};

    	const writable_props = ['value', 'text', 'focused', 'centertxt', 'lab', 'flip', 'center'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			input = $$value;
    			$$invalidate(7, input);
    		});
    	}

    	function input_1_input_handler() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	$$self.$$set = $$props => {
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('text' in $$props) $$invalidate(2, text = $$props.text);
    		if ('focused' in $$props) $$invalidate(1, focused = $$props.focused);
    		if ('centertxt' in $$props) $$invalidate(3, centertxt = $$props.centertxt);
    		if ('lab' in $$props) $$invalidate(4, lab = $$props.lab);
    		if ('flip' in $$props) $$invalidate(5, flip = $$props.flip);
    		if ('center' in $$props) $$invalidate(6, center = $$props.center);
    	};

    	$$self.$capture_state = () => ({
    		R2Over,
    		FB,
    		v4,
    		id,
    		createEventDispatcher,
    		dispatch,
    		value,
    		text,
    		focused,
    		centertxt,
    		lab,
    		flip,
    		center,
    		input,
    		onfocus,
    		onblur,
    		exit,
    		erase,
    		quit,
    		edited
    	});

    	$$self.$inject_state = $$props => {
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('text' in $$props) $$invalidate(2, text = $$props.text);
    		if ('focused' in $$props) $$invalidate(1, focused = $$props.focused);
    		if ('centertxt' in $$props) $$invalidate(3, centertxt = $$props.centertxt);
    		if ('lab' in $$props) $$invalidate(4, lab = $$props.lab);
    		if ('flip' in $$props) $$invalidate(5, flip = $$props.flip);
    		if ('center' in $$props) $$invalidate(6, center = $$props.center);
    		if ('input' in $$props) $$invalidate(7, input = $$props.input);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 1) {
    			edited(value);
    		}
    	};

    	return [
    		value,
    		focused,
    		text,
    		centertxt,
    		lab,
    		flip,
    		center,
    		input,
    		id,
    		onfocus,
    		onblur,
    		exit,
    		erase,
    		quit,
    		input_1_binding,
    		input_1_input_handler
    	];
    }

    class Text$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, {
    			value: 0,
    			text: 2,
    			focused: 1,
    			centertxt: 3,
    			lab: 4,
    			flip: 5,
    			center: 6,
    			exit: 11,
    			erase: 12,
    			quit: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1i.name
    		});
    	}

    	get value() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focused() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focused(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get centertxt() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set centertxt(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lab() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lab(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flip() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flip(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get center() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set center(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get exit() {
    		return this.$$.ctx[11];
    	}

    	set exit(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get erase() {
    		return this.$$.ctx[12];
    	}

    	set erase(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get quit() {
    		return this.$$.ctx[13];
    	}

    	set quit(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/doc/Numeric.svelte generated by Svelte v3.44.3 */
    const file$K = "src/doc/Numeric.svelte";

    function create_fragment$1h(ctx) {
    	let div;
    	let text_1;
    	let div_class_value;
    	let current;

    	let text_1_props = {
    		centertxt: true,
    		value: /*user*/ ctx[3],
    		lab: /*lab*/ ctx[1]
    	};

    	text_1 = new Text$1({ props: text_1_props, $$inline: true });
    	/*text_1_binding*/ ctx[10](text_1);
    	text_1.$on("edited", /*edited*/ ctx[4]);
    	text_1.$on("focus", /*focus*/ ctx[5]);
    	text_1.$on("blur", /*blur*/ ctx[6]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(text_1.$$.fragment);
    			attr_dev(div, "class", div_class_value = "numeric-input in" + /*w*/ ctx[0]);
    			add_location(div, file$K, 38, 0, 766);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(text_1, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const text_1_changes = {};
    			if (dirty & /*user*/ 8) text_1_changes.value = /*user*/ ctx[3];
    			if (dirty & /*lab*/ 2) text_1_changes.lab = /*lab*/ ctx[1];
    			text_1.$set(text_1_changes);

    			if (!current || dirty & /*w*/ 1 && div_class_value !== (div_class_value = "numeric-input in" + /*w*/ ctx[0])) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*text_1_binding*/ ctx[10](null);
    			destroy_component(text_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Numeric', slots, []);
    	const setcontrols = getContext('setcontrols');
    	let input;
    	let { val = 0 } = $$props;
    	let { min = 0 } = $$props;
    	let { max = 100 } = $$props;
    	let { w = 2 } = $$props;
    	let { lab = '' } = $$props;
    	let user = val;

    	const controls = (m, e) => {
    		if (e.key == 'Enter') {
    			if (input) input.exit();
    		}
    	};

    	const edited = e => {
    		$$invalidate(3, user = e.detail.val);
    	};

    	const focus = () => {
    		setcontrols(controls);
    	};

    	const blur = () => {
    		setcontrols();
    		set();
    	};

    	const set = () => {
    		const u = parseInt(user) || 0;
    		if (u > max) $$invalidate(7, val = max); else if (u < min) $$invalidate(7, val = min); else $$invalidate(7, val = u);
    		$$invalidate(3, user = val);
    	};

    	const writable_props = ['val', 'min', 'max', 'w', 'lab'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Numeric> was created with unknown prop '${key}'`);
    	});

    	function text_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			input = $$value;
    			$$invalidate(2, input);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('val' in $$props) $$invalidate(7, val = $$props.val);
    		if ('min' in $$props) $$invalidate(9, min = $$props.min);
    		if ('max' in $$props) $$invalidate(8, max = $$props.max);
    		if ('w' in $$props) $$invalidate(0, w = $$props.w);
    		if ('lab' in $$props) $$invalidate(1, lab = $$props.lab);
    	};

    	$$self.$capture_state = () => ({
    		Text: Text$1,
    		getContext,
    		setcontrols,
    		input,
    		val,
    		min,
    		max,
    		w,
    		lab,
    		user,
    		controls,
    		edited,
    		focus,
    		blur,
    		set
    	});

    	$$self.$inject_state = $$props => {
    		if ('input' in $$props) $$invalidate(2, input = $$props.input);
    		if ('val' in $$props) $$invalidate(7, val = $$props.val);
    		if ('min' in $$props) $$invalidate(9, min = $$props.min);
    		if ('max' in $$props) $$invalidate(8, max = $$props.max);
    		if ('w' in $$props) $$invalidate(0, w = $$props.w);
    		if ('lab' in $$props) $$invalidate(1, lab = $$props.lab);
    		if ('user' in $$props) $$invalidate(3, user = $$props.user);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*max, min*/ 768) {
    			if (max <= min) $$invalidate(8, max = min + 1);
    		}

    		if ($$self.$$.dirty & /*val, min, max*/ 896) {
    			if (val < min) $$invalidate(7, val = min); else if (val > max) $$invalidate(7, val = max);
    		}
    	};

    	return [w, lab, input, user, edited, focus, blur, val, max, min, text_1_binding];
    }

    class Numeric extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, { val: 7, min: 9, max: 8, w: 0, lab: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Numeric",
    			options,
    			id: create_fragment$1h.name
    		});
    	}

    	get val() {
    		throw new Error("<Numeric>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set val(value) {
    		throw new Error("<Numeric>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<Numeric>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<Numeric>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<Numeric>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<Numeric>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get w() {
    		throw new Error("<Numeric>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set w(value) {
    		throw new Error("<Numeric>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lab() {
    		throw new Error("<Numeric>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lab(value) {
    		throw new Error("<Numeric>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/SearchEmph.svelte generated by Svelte v3.44.3 */

    const file$J = "src/SearchEmph.svelte";

    // (22:2) {:else}
    function create_else_block$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*text*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*text*/ 1) set_data_dev(t, /*text*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$j.name,
    		type: "else",
    		source: "(22:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (20:2) {#if center}
    function create_if_block$A(ctx) {
    	let span;
    	let t;
    	let if_block1_anchor;
    	let if_block0 = /*left*/ ctx[1] && create_if_block_2$b(ctx);
    	let if_block1 = /*right*/ ctx[3] && create_if_block_1$j(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			span = element("span");
    			t = text(/*center*/ ctx[2]);
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty$1();
    			attr_dev(span, "class", "emph-center");
    			add_location(span, file$J, 20, 54, 391);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*left*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$b(ctx);
    					if_block0.c();
    					if_block0.m(span.parentNode, span);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*center*/ 4) set_data_dev(t, /*center*/ ctx[2]);

    			if (/*right*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$j(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(span);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$A.name,
    		type: "if",
    		source: "(20:2) {#if center}",
    		ctx
    	});

    	return block;
    }

    // (21:2) {#if left}
    function create_if_block_2$b(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*left*/ ctx[1]);
    			attr_dev(span, "class", "emph-left");
    			add_location(span, file$J, 20, 12, 349);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*left*/ 2) set_data_dev(t, /*left*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$b.name,
    		type: "if",
    		source: "(21:2) {#if left}",
    		ctx
    	});

    	return block;
    }

    // (21:95) {#if right}
    function create_if_block_1$j(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*right*/ ctx[3]);
    			attr_dev(span, "class", "emph-right");
    			add_location(span, file$J, 20, 106, 443);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*right*/ 8) set_data_dev(t, /*right*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$j.name,
    		type: "if",
    		source: "(21:95) {#if right}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1g(ctx) {
    	let span;

    	function select_block_type(ctx, dirty) {
    		if (/*center*/ ctx[2]) return create_if_block$A;
    		return create_else_block$j;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if_block.c();
    			attr_dev(span, "class", "emphatic");
    			add_location(span, file$J, 18, 0, 298);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if_block.m(span, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SearchEmph', slots, []);
    	let { text = '' } = $$props;
    	let left = null;
    	let center = null;
    	let right = null;

    	const set = () => {
    		$$invalidate(1, left = null);
    		$$invalidate(2, center = null);
    		$$invalidate(3, right = null);

    		if (typeof text != 'string') {
    			$$invalidate(1, left = text[0]);
    			$$invalidate(2, center = text[1]);
    			$$invalidate(3, right = text[2]);
    		}
    	};

    	const writable_props = ['text'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SearchEmph> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('text' in $$props) $$invalidate(0, text = $$props.text);
    	};

    	$$self.$capture_state = () => ({ text, left, center, right, set });

    	$$self.$inject_state = $$props => {
    		if ('text' in $$props) $$invalidate(0, text = $$props.text);
    		if ('left' in $$props) $$invalidate(1, left = $$props.left);
    		if ('center' in $$props) $$invalidate(2, center = $$props.center);
    		if ('right' in $$props) $$invalidate(3, right = $$props.right);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*text*/ 1) {
    			set();
    		}
    	};

    	return [text, left, center, right];
    }

    class SearchEmph extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1g, create_fragment$1g, safe_not_equal, { text: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SearchEmph",
    			options,
    			id: create_fragment$1g.name
    		});
    	}

    	get text() {
    		throw new Error("<SearchEmph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<SearchEmph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/SearchBar.svelte generated by Svelte v3.44.3 */

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[53] = list[i];
    	return child_ctx;
    }

    // (139:32) {#if preview}
    function create_if_block_2$a(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				c: "search-preview-wrapper",
    				$$slots: { default: [create_default_slot_3$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[0] & /*query, $modifiers, sb, exists, gb, createin, $haslogin, result*/ 112131 | dirty[1] & /*$$scope*/ 33554432) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(139:32) {#if preview}",
    		ctx
    	});

    	return block;
    }

    // (141:4) {#if result.items}
    function create_if_block_4$2(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				c: "search-preview",
    				$$slots: { default: [create_default_slot_8$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[0] & /*result*/ 2 | dirty[1] & /*$$scope*/ 33554432) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(141:4) {#if result.items}",
    		ctx
    	});

    	return block;
    }

    // (145:7) <Link does={quit} space={item.namespace} title={item.plain} nored>
    function create_default_slot_10$6(ctx) {
    	let searchemph;
    	let current;

    	searchemph = new SearchEmph({
    			props: { text: /*item*/ ctx[53].title },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(searchemph.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(searchemph, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const searchemph_changes = {};
    			if (dirty[0] & /*result*/ 2) searchemph_changes.text = /*item*/ ctx[53].title;
    			searchemph.$set(searchemph_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(searchemph.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(searchemph.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(searchemph, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$6.name,
    		type: "slot",
    		source: "(145:7) <Link does={quit} space={item.namespace} title={item.plain} nored>",
    		ctx
    	});

    	return block;
    }

    // (144:6) <FB leaf line c="search-preview-item">
    function create_default_slot_9$6(ctx) {
    	let link;
    	let t;
    	let current;

    	link = new Link$1({
    			props: {
    				does: /*quit*/ ctx[21],
    				space: /*item*/ ctx[53].namespace,
    				title: /*item*/ ctx[53].plain,
    				nored: true,
    				$$slots: { default: [create_default_slot_10$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty[0] & /*result*/ 2) link_changes.space = /*item*/ ctx[53].namespace;
    			if (dirty[0] & /*result*/ 2) link_changes.title = /*item*/ ctx[53].plain;

    			if (dirty[0] & /*result*/ 2 | dirty[1] & /*$$scope*/ 33554432) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$6.name,
    		type: "slot",
    		source: "(144:6) <FB leaf line c=\\\"search-preview-item\\\">",
    		ctx
    	});

    	return block;
    }

    // (143:5) {#each result.items as item}
    function create_each_block$d(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				leaf: true,
    				line: true,
    				c: "search-preview-item",
    				$$slots: { default: [create_default_slot_9$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[0] & /*result*/ 2 | dirty[1] & /*$$scope*/ 33554432) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(143:5) {#each result.items as item}",
    		ctx
    	});

    	return block;
    }

    // (142:4) <FB vert c="search-preview">
    function create_default_slot_8$6(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*result*/ ctx[1].items;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*quit, result*/ 2097154) {
    				each_value = /*result*/ ctx[1].items;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$6.name,
    		type: "slot",
    		source: "(142:4) <FB vert c=\\\"search-preview\\\">",
    		ctx
    	});

    	return block;
    }

    // (160:6) {:else}
    function create_else_block$i(ctx) {
    	let link;
    	let current;

    	let link_props = {
    		global: true,
    		does: /*quit*/ ctx[21],
    		space: /*createin*/ ctx[15],
    		title: /*query*/ ctx[0],
    		disable: !/*query*/ ctx[0] || !/*$haslogin*/ ctx[16],
    		marked: /*$modifiers*/ ctx[9].Shift,
    		$$slots: { default: [create_default_slot_7$a] },
    		$$scope: { ctx }
    	};

    	link = new Link$1({ props: link_props, $$inline: true });
    	/*link_binding_2*/ ctx[35](link);

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty[0] & /*createin*/ 32768) link_changes.space = /*createin*/ ctx[15];
    			if (dirty[0] & /*query*/ 1) link_changes.title = /*query*/ ctx[0];
    			if (dirty[0] & /*query, $haslogin*/ 65537) link_changes.disable = !/*query*/ ctx[0] || !/*$haslogin*/ ctx[16];
    			if (dirty[0] & /*$modifiers*/ 512) link_changes.marked = /*$modifiers*/ ctx[9].Shift;

    			if (dirty[1] & /*$$scope*/ 33554432) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*link_binding_2*/ ctx[35](null);
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$i.name,
    		type: "else",
    		source: "(160:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (152:6) {#if exists}
    function create_if_block_3$8(ctx) {
    	let link;
    	let current;

    	let link_props = {
    		global: true,
    		does: /*quit*/ ctx[21],
    		space: /*exists*/ ctx[10].namespace,
    		title: /*exists*/ ctx[10].title,
    		marked: /*$modifiers*/ ctx[9].Shift,
    		$$slots: { default: [create_default_slot_6$a] },
    		$$scope: { ctx }
    	};

    	link = new Link$1({ props: link_props, $$inline: true });
    	/*link_binding_1*/ ctx[34](link);

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty[0] & /*exists*/ 1024) link_changes.space = /*exists*/ ctx[10].namespace;
    			if (dirty[0] & /*exists*/ 1024) link_changes.title = /*exists*/ ctx[10].title;
    			if (dirty[0] & /*$modifiers*/ 512) link_changes.marked = /*$modifiers*/ ctx[9].Shift;

    			if (dirty[1] & /*$$scope*/ 33554432) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*link_binding_1*/ ctx[34](null);
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$8.name,
    		type: "if",
    		source: "(152:6) {#if exists}",
    		ctx
    	});

    	return block;
    }

    // (161:8) <Link global does={quit}        space={createin}        title={query}        disable={!query || !$haslogin}        marked={$modifiers.Shift}        bind:this={gb}>
    function create_default_slot_7$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("CREATE");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$a.name,
    		type: "slot",
    		source: "(161:8) <Link global does={quit}        space={createin}        title={query}        disable={!query || !$haslogin}        marked={$modifiers.Shift}        bind:this={gb}>",
    		ctx
    	});

    	return block;
    }

    // (153:8) <Link global does={quit}        space={exists.namespace}        title={exists.title}        marked={$modifiers.Shift}        bind:this={gb}>
    function create_default_slot_6$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("GO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$a.name,
    		type: "slot",
    		source: "(153:8) <Link global does={quit}        space={exists.namespace}        title={exists.title}        marked={$modifiers.Shift}        bind:this={gb}>",
    		ctx
    	});

    	return block;
    }

    // (170:5) <Link does={quit}       nst="CPB:search" sub={[query]}       disable={!query}       marked={!$modifiers.Shift}       bind:this={sb}>
    function create_default_slot_5$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("SEARCH");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$d.name,
    		type: "slot",
    		source: "(170:5) <Link does={quit}       nst=\\\"CPB:search\\\" sub={[query]}       disable={!query}       marked={!$modifiers.Shift}       bind:this={sb}>",
    		ctx
    	});

    	return block;
    }

    // (151:4) <FB around c="search-controls">
    function create_default_slot_4$e(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let link;
    	let current;
    	const if_block_creators = [create_if_block_3$8, create_else_block$i];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*exists*/ ctx[10]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	let link_props = {
    		does: /*quit*/ ctx[21],
    		nst: "CPB:search",
    		sub: [/*query*/ ctx[0]],
    		disable: !/*query*/ ctx[0],
    		marked: !/*$modifiers*/ ctx[9].Shift,
    		$$slots: { default: [create_default_slot_5$d] },
    		$$scope: { ctx }
    	};

    	link = new Link$1({ props: link_props, $$inline: true });
    	/*link_binding_3*/ ctx[36](link);

    	const block = {
    		c: function create() {
    			if_block.c();
    			t = space();
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(t.parentNode, t);
    			}

    			const link_changes = {};
    			if (dirty[0] & /*query*/ 1) link_changes.sub = [/*query*/ ctx[0]];
    			if (dirty[0] & /*query*/ 1) link_changes.disable = !/*query*/ ctx[0];
    			if (dirty[0] & /*$modifiers*/ 512) link_changes.marked = !/*$modifiers*/ ctx[9].Shift;

    			if (dirty[1] & /*$$scope*/ 33554432) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t);
    			/*link_binding_3*/ ctx[36](null);
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$e.name,
    		type: "slot",
    		source: "(151:4) <FB around c=\\\"search-controls\\\">",
    		ctx
    	});

    	return block;
    }

    // (140:3) <FB vert c="search-preview-wrapper">
    function create_default_slot_3$i(ctx) {
    	let t;
    	let fb;
    	let current;
    	let if_block = /*result*/ ctx[1].items && create_if_block_4$2(ctx);

    	fb = new FB({
    			props: {
    				around: true,
    				c: "search-controls",
    				$$slots: { default: [create_default_slot_4$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*result*/ ctx[1].items) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*result*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_4$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const fb_changes = {};

    			if (dirty[0] & /*query, $modifiers, sb, exists, gb, createin, $haslogin*/ 112129 | dirty[1] & /*$$scope*/ 33554432) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$i.name,
    		type: "slot",
    		source: "(140:3) <FB vert c=\\\"search-preview-wrapper\\\">",
    		ctx
    	});

    	return block;
    }

    // (139:2) <svelte:fragment slot="extra">
    function create_extra_slot(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*preview*/ ctx[4] && create_if_block_2$a(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*preview*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*preview*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_extra_slot.name,
    		type: "slot",
    		source: "(139:2) <svelte:fragment slot=\\\"extra\\\">",
    		ctx
    	});

    	return block;
    }

    // (180:34) {#if !preview}
    function create_if_block_1$i(ctx) {
    	let link;
    	let current;

    	let link_props = {
    		does: /*quit*/ ctx[21],
    		nst: "CPB:search",
    		sub: [/*query*/ ctx[0]],
    		disable: !/*query*/ ctx[0],
    		marked: !/*$modifiers*/ ctx[9].Shift,
    		opt: /*searchOpt*/ ctx[14],
    		$$slots: { default: [create_default_slot_2$p] },
    		$$scope: { ctx }
    	};

    	link = new Link$1({ props: link_props, $$inline: true });
    	/*link_binding*/ ctx[33](link);

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty[0] & /*query*/ 1) link_changes.sub = [/*query*/ ctx[0]];
    			if (dirty[0] & /*query*/ 1) link_changes.disable = !/*query*/ ctx[0];
    			if (dirty[0] & /*$modifiers*/ 512) link_changes.marked = !/*$modifiers*/ ctx[9].Shift;
    			if (dirty[0] & /*searchOpt*/ 16384) link_changes.opt = /*searchOpt*/ ctx[14];

    			if (dirty[1] & /*$$scope*/ 33554432) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*link_binding*/ ctx[33](null);
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$i.name,
    		type: "if",
    		source: "(180:34) {#if !preview}",
    		ctx
    	});

    	return block;
    }

    // (181:3) <Link does={quit}     nst="CPB:search" sub={[query]}     disable={!query}     marked={!$modifiers.Shift}     bind:this={sb}     opt={searchOpt}     >
    function create_default_slot_2$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("SEARCH");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$p.name,
    		type: "slot",
    		source: "(181:3) <Link does={quit}     nst=\\\"CPB:search\\\" sub={[query]}     disable={!query}     marked={!$modifiers.Shift}     bind:this={sb}     opt={searchOpt}     >",
    		ctx
    	});

    	return block;
    }

    // (180:2) <svelte:fragment slot="buttons">
    function create_buttons_slot(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = !/*preview*/ ctx[4] && create_if_block_1$i(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*preview*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*preview*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$i(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_buttons_slot.name,
    		type: "slot",
    		source: "(180:2) <svelte:fragment slot=\\\"buttons\\\">",
    		ctx
    	});

    	return block;
    }

    // (191:34) {#if options}
    function create_if_block$z(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				line: true,
    				$$slots: { default: [create_default_slot_1$u] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[0] & /*szOpt, inhOpt, bodyOpt, titleOpt*/ 396 | dirty[1] & /*$$scope*/ 33554432) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$z.name,
    		type: "if",
    		source: "(191:34) {#if options}",
    		ctx
    	});

    	return block;
    }

    // (192:3) <FB line>
    function create_default_slot_1$u(ctx) {
    	let check0;
    	let updating_state;
    	let t0;
    	let check1;
    	let updating_state_1;
    	let t1;
    	let fb0;
    	let t2;
    	let check2;
    	let updating_state_2;
    	let t3;
    	let fb1;
    	let t4;
    	let numeric;
    	let updating_val;
    	let current;

    	function check0_state_binding(value) {
    		/*check0_state_binding*/ ctx[29](value);
    	}

    	let check0_props = { lab: "TITLES" };

    	if (/*titleOpt*/ ctx[7] !== void 0) {
    		check0_props.state = /*titleOpt*/ ctx[7];
    	}

    	check0 = new Check({ props: check0_props, $$inline: true });
    	binding_callbacks.push(() => bind(check0, 'state', check0_state_binding));

    	function check1_state_binding(value) {
    		/*check1_state_binding*/ ctx[30](value);
    	}

    	let check1_props = { lab: "BODY" };

    	if (/*bodyOpt*/ ctx[8] !== void 0) {
    		check1_props.state = /*bodyOpt*/ ctx[8];
    	}

    	check1 = new Check({ props: check1_props, $$inline: true });
    	binding_callbacks.push(() => bind(check1, 'state', check1_state_binding));

    	fb0 = new FB({
    			props: { leaf: true, spacer: 1 },
    			$$inline: true
    		});

    	function check2_state_binding(value) {
    		/*check2_state_binding*/ ctx[31](value);
    	}

    	let check2_props = { lab: "HISTORY" };

    	if (/*inhOpt*/ ctx[2] !== void 0) {
    		check2_props.state = /*inhOpt*/ ctx[2];
    	}

    	check2 = new Check({ props: check2_props, $$inline: true });
    	binding_callbacks.push(() => bind(check2, 'state', check2_state_binding));
    	fb1 = new FB({ props: { expand: true }, $$inline: true });

    	function numeric_val_binding(value) {
    		/*numeric_val_binding*/ ctx[32](value);
    	}

    	let numeric_props = {
    		double: true,
    		min: 5,
    		max: 50,
    		lab: "RESULTS"
    	};

    	if (/*szOpt*/ ctx[3] !== void 0) {
    		numeric_props.val = /*szOpt*/ ctx[3];
    	}

    	numeric = new Numeric({ props: numeric_props, $$inline: true });
    	binding_callbacks.push(() => bind(numeric, 'val', numeric_val_binding));

    	const block = {
    		c: function create() {
    			create_component(check0.$$.fragment);
    			t0 = space();
    			create_component(check1.$$.fragment);
    			t1 = space();
    			create_component(fb0.$$.fragment);
    			t2 = space();
    			create_component(check2.$$.fragment);
    			t3 = space();
    			create_component(fb1.$$.fragment);
    			t4 = space();
    			create_component(numeric.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(check0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(check1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(check2, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(numeric, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const check0_changes = {};

    			if (!updating_state && dirty[0] & /*titleOpt*/ 128) {
    				updating_state = true;
    				check0_changes.state = /*titleOpt*/ ctx[7];
    				add_flush_callback(() => updating_state = false);
    			}

    			check0.$set(check0_changes);
    			const check1_changes = {};

    			if (!updating_state_1 && dirty[0] & /*bodyOpt*/ 256) {
    				updating_state_1 = true;
    				check1_changes.state = /*bodyOpt*/ ctx[8];
    				add_flush_callback(() => updating_state_1 = false);
    			}

    			check1.$set(check1_changes);
    			const check2_changes = {};

    			if (!updating_state_2 && dirty[0] & /*inhOpt*/ 4) {
    				updating_state_2 = true;
    				check2_changes.state = /*inhOpt*/ ctx[2];
    				add_flush_callback(() => updating_state_2 = false);
    			}

    			check2.$set(check2_changes);
    			const numeric_changes = {};

    			if (!updating_val && dirty[0] & /*szOpt*/ 8) {
    				updating_val = true;
    				numeric_changes.val = /*szOpt*/ ctx[3];
    				add_flush_callback(() => updating_val = false);
    			}

    			numeric.$set(numeric_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(check0.$$.fragment, local);
    			transition_in(check1.$$.fragment, local);
    			transition_in(fb0.$$.fragment, local);
    			transition_in(check2.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(numeric.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(check0.$$.fragment, local);
    			transition_out(check1.$$.fragment, local);
    			transition_out(fb0.$$.fragment, local);
    			transition_out(check2.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(numeric.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(check0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(check1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(check2, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(numeric, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$u.name,
    		type: "slot",
    		source: "(192:3) <FB line>",
    		ctx
    	});

    	return block;
    }

    // (191:2) <svelte:fragment slot="options">
    function create_options_slot(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*options*/ ctx[5] && create_if_block$z(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*options*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*options*/ 32) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$z(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_options_slot.name,
    		type: "slot",
    		source: "(191:2) <svelte:fragment slot=\\\"options\\\">",
    		ctx
    	});

    	return block;
    }

    // (130:0) <FB vert zero c="search-bar r2-s4">
    function create_default_slot$I(ctx) {
    	let input_1;
    	let updating_focused;
    	let current;

    	function input_1_focused_binding(value) {
    		/*input_1_focused_binding*/ ctx[38](value);
    	}

    	let input_1_props = {
    		value: /*query*/ ctx[0],
    		useExtra: /*preview*/ ctx[4],
    		text: "SEARCH",
    		$$slots: {
    			options: [create_options_slot],
    			buttons: [create_buttons_slot],
    			extra: [create_extra_slot]
    		},
    		$$scope: { ctx }
    	};

    	if (/*focused*/ ctx[6] !== void 0) {
    		input_1_props.focused = /*focused*/ ctx[6];
    	}

    	input_1 = new Input({ props: input_1_props, $$inline: true });
    	/*input_1_binding*/ ctx[37](input_1);
    	binding_callbacks.push(() => bind(input_1, 'focused', input_1_focused_binding));
    	input_1.$on("edited", /*edited*/ ctx[22]);

    	const block = {
    		c: function create() {
    			create_component(input_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(input_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const input_1_changes = {};
    			if (dirty[0] & /*query*/ 1) input_1_changes.value = /*query*/ ctx[0];
    			if (dirty[0] & /*preview*/ 16) input_1_changes.useExtra = /*preview*/ ctx[4];

    			if (dirty[0] & /*szOpt, inhOpt, bodyOpt, titleOpt, options, query, $modifiers, searchOpt, sb, preview, exists, gb, createin, $haslogin, result*/ 128959 | dirty[1] & /*$$scope*/ 33554432) {
    				input_1_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_focused && dirty[0] & /*focused*/ 64) {
    				updating_focused = true;
    				input_1_changes.focused = /*focused*/ ctx[6];
    				add_flush_callback(() => updating_focused = false);
    			}

    			input_1.$set(input_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*input_1_binding*/ ctx[37](null);
    			destroy_component(input_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$I.name,
    		type: "slot",
    		source: "(130:0) <FB vert zero c=\\\"search-bar r2-s4\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1f(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				zero: true,
    				c: "search-bar r2-s4",
    				$$slots: { default: [create_default_slot$I] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[0] & /*query, preview, input, focused, szOpt, inhOpt, bodyOpt, titleOpt, options, $modifiers, searchOpt, sb, exists, gb, createin, $haslogin, result*/ 131071 | dirty[1] & /*$$scope*/ 33554432) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1f($$self, $$props, $$invalidate) {
    	let markcg;
    	let marksearch;
    	let createin;
    	let $rc;
    	let $loc;
    	let $modifiers;
    	let $haslogin;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SearchBar', slots, []);
    	const dispatch = createEventDispatcher();
    	const rc = getContext('rc');
    	validate_store(rc, 'rc');
    	component_subscribe($$self, rc, value => $$invalidate(27, $rc = value));
    	const gs = getContext('gs');
    	const path = getContext('path');
    	const loc = getContext('loc');
    	validate_store(loc, 'loc');
    	component_subscribe($$self, loc, value => $$invalidate(28, $loc = value));
    	const fullsearch = getContext('fullsearch');
    	const modifiers = getContext('modifiers');
    	validate_store(modifiers, 'modifiers');
    	component_subscribe($$self, modifiers, value => $$invalidate(9, $modifiers = value));
    	const setcontrols = getContext('setcontrols');
    	const haslogin = getContext('haslogin');
    	validate_store(haslogin, 'haslogin');
    	component_subscribe($$self, haslogin, value => $$invalidate(16, $haslogin = value));
    	let { query = '' } = $$props;
    	let { preview = false } = $$props;
    	let { options = false } = $$props;
    	let { auto = false } = $$props;
    	let { result = [] } = $$props;
    	let exists = false;
    	let focused;
    	let timer = null;
    	let input;
    	let gb, sb;
    	let fresh = true;
    	let { inf = 'title,body' } = $$props;
    	let titleOpt, bodyOpt;

    	if (inf) {
    		titleOpt = inf.split(',').indexOf('title') > -1;
    		bodyOpt = inf.split(',').indexOf('body') > -1;
    	} else {
    		titleOpt = true;
    		bodyOpt = true;
    	}

    	let { inhOpt = false } = $$props;
    	let { szOpt = 25 } = $$props;
    	let { pgOpt = 1 } = $$props;

    	const controls = (m, e) => {
    		if (e.key == 'Enter') {
    			if (preview) {
    				if (e.getModifierState('Shift')) gb.trigger(); else sb.trigger();
    			} else {
    				sb.trigger();
    			}
    		} else if (e.key == 'Escape') {
    			exit();
    		}
    	};

    	const exit = () => {
    		if (input) input.exit();
    	};

    	const erase = () => {
    		input.erase();
    	};

    	const quit = () => input.quit();

    	const search = () => {
    		if (!query || query == '') {
    			$$invalidate(1, result = []);
    			timer = null;
    			dispatch('done');
    		} else {
    			fullsearch(query, searchOpt).then(res => {
    				dispatch('done');

    				if (res.err == 0) {
    					$$invalidate(1, result = res.val);
    					timer = null;
    					$$invalidate(26, fresh = false);
    				}
    			});
    		}
    	};

    	const delay = () => {
    		if (timer) clearTimeout(timer);
    		timer = setTimeout(search, 500);
    	};

    	const edited = e => {
    		$$invalidate(0, query = e.detail.val);
    	};

    	let searchOpt = {};

    	const mkopts = () => {
    		const f = [];
    		if (titleOpt) f.push('title');
    		if (bodyOpt) f.push('body');
    		const o = {};
    		if (szOpt != $rc.searchDefaults.sz) o.sz = szOpt;
    		if (f.join(',') != $rc.searchDefaults.inf.join(',')) o.inf = f;
    		if (inhOpt != $rc.searchDefaults.inh) o.inh = inhOpt;
    		if (pgOpt != $rc.searchDefaults.pg) o.pg = pgOpt;
    		$$invalidate(14, searchOpt = o);
    	};

    	const writable_props = [
    		'query',
    		'preview',
    		'options',
    		'auto',
    		'result',
    		'inf',
    		'inhOpt',
    		'szOpt',
    		'pgOpt'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SearchBar> was created with unknown prop '${key}'`);
    	});

    	function check0_state_binding(value) {
    		titleOpt = value;
    		$$invalidate(7, titleOpt);
    	}

    	function check1_state_binding(value) {
    		bodyOpt = value;
    		$$invalidate(8, bodyOpt);
    	}

    	function check2_state_binding(value) {
    		inhOpt = value;
    		$$invalidate(2, inhOpt);
    	}

    	function numeric_val_binding(value) {
    		szOpt = value;
    		$$invalidate(3, szOpt);
    	}

    	function link_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			sb = $$value;
    			$$invalidate(13, sb);
    		});
    	}

    	function link_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			gb = $$value;
    			$$invalidate(12, gb);
    		});
    	}

    	function link_binding_2($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			gb = $$value;
    			$$invalidate(12, gb);
    		});
    	}

    	function link_binding_3($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			sb = $$value;
    			$$invalidate(13, sb);
    		});
    	}

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			input = $$value;
    			$$invalidate(11, input);
    		});
    	}

    	function input_1_focused_binding(value) {
    		focused = value;
    		$$invalidate(6, focused);
    	}

    	$$self.$$set = $$props => {
    		if ('query' in $$props) $$invalidate(0, query = $$props.query);
    		if ('preview' in $$props) $$invalidate(4, preview = $$props.preview);
    		if ('options' in $$props) $$invalidate(5, options = $$props.options);
    		if ('auto' in $$props) $$invalidate(24, auto = $$props.auto);
    		if ('result' in $$props) $$invalidate(1, result = $$props.result);
    		if ('inf' in $$props) $$invalidate(25, inf = $$props.inf);
    		if ('inhOpt' in $$props) $$invalidate(2, inhOpt = $$props.inhOpt);
    		if ('szOpt' in $$props) $$invalidate(3, szOpt = $$props.szOpt);
    		if ('pgOpt' in $$props) $$invalidate(23, pgOpt = $$props.pgOpt);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		Doc,
    		Line: Line$1,
    		Lab,
    		Link: Link$1,
    		Input,
    		Check,
    		Numeric,
    		SearchEmph,
    		getContext,
    		createEventDispatcher,
    		dispatch,
    		rc,
    		gs,
    		path,
    		loc,
    		fullsearch,
    		modifiers,
    		setcontrols,
    		haslogin,
    		query,
    		preview,
    		options,
    		auto,
    		result,
    		exists,
    		focused,
    		timer,
    		input,
    		gb,
    		sb,
    		fresh,
    		inf,
    		titleOpt,
    		bodyOpt,
    		inhOpt,
    		szOpt,
    		pgOpt,
    		controls,
    		exit,
    		erase,
    		quit,
    		search,
    		delay,
    		edited,
    		searchOpt,
    		mkopts,
    		createin,
    		marksearch,
    		markcg,
    		$rc,
    		$loc,
    		$modifiers,
    		$haslogin
    	});

    	$$self.$inject_state = $$props => {
    		if ('query' in $$props) $$invalidate(0, query = $$props.query);
    		if ('preview' in $$props) $$invalidate(4, preview = $$props.preview);
    		if ('options' in $$props) $$invalidate(5, options = $$props.options);
    		if ('auto' in $$props) $$invalidate(24, auto = $$props.auto);
    		if ('result' in $$props) $$invalidate(1, result = $$props.result);
    		if ('exists' in $$props) $$invalidate(10, exists = $$props.exists);
    		if ('focused' in $$props) $$invalidate(6, focused = $$props.focused);
    		if ('timer' in $$props) timer = $$props.timer;
    		if ('input' in $$props) $$invalidate(11, input = $$props.input);
    		if ('gb' in $$props) $$invalidate(12, gb = $$props.gb);
    		if ('sb' in $$props) $$invalidate(13, sb = $$props.sb);
    		if ('fresh' in $$props) $$invalidate(26, fresh = $$props.fresh);
    		if ('inf' in $$props) $$invalidate(25, inf = $$props.inf);
    		if ('titleOpt' in $$props) $$invalidate(7, titleOpt = $$props.titleOpt);
    		if ('bodyOpt' in $$props) $$invalidate(8, bodyOpt = $$props.bodyOpt);
    		if ('inhOpt' in $$props) $$invalidate(2, inhOpt = $$props.inhOpt);
    		if ('szOpt' in $$props) $$invalidate(3, szOpt = $$props.szOpt);
    		if ('pgOpt' in $$props) $$invalidate(23, pgOpt = $$props.pgOpt);
    		if ('searchOpt' in $$props) $$invalidate(14, searchOpt = $$props.searchOpt);
    		if ('createin' in $$props) $$invalidate(15, createin = $$props.createin);
    		if ('marksearch' in $$props) marksearch = $$props.marksearch;
    		if ('markcg' in $$props) markcg = $$props.markcg;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*result, query*/ 3) {
    			if (result.length) {
    				$$invalidate(10, exists = false);

    				result.forEach(i => {
    					if (i.title == query) $$invalidate(10, exists = i);
    				});
    			}
    		}

    		if ($$self.$$.dirty[0] & /*$modifiers*/ 512) {
    			markcg = !!$modifiers.Shift;
    		}

    		if ($$self.$$.dirty[0] & /*$modifiers*/ 512) {
    			marksearch = !$modifiers.Shift;
    		}

    		if ($$self.$$.dirty[0] & /*focused*/ 64) {
    			if (focused) {
    				setcontrols(controls);
    			} else {
    				setcontrols();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*pgOpt*/ 8388608) {
    			if (typeof pgOpt != 'number') $$invalidate(23, pgOpt = parseInt(pgOpt));
    		}

    		if ($$self.$$.dirty[0] & /*titleOpt, bodyOpt, szOpt, inhOpt*/ 396) {
    			mkopts();
    		}

    		if ($$self.$$.dirty[0] & /*auto, query, fresh*/ 83886081) {
    			if (auto) delay(); else if (fresh && query) search();
    		}

    		if ($$self.$$.dirty[0] & /*$loc, $rc*/ 402653184) {
    			$$invalidate(15, createin = $loc.namespace && $loc.namespace != $rc.syskey
    			? $loc.namespace
    			: $rc.defns);
    		}
    	};

    	return [
    		query,
    		result,
    		inhOpt,
    		szOpt,
    		preview,
    		options,
    		focused,
    		titleOpt,
    		bodyOpt,
    		$modifiers,
    		exists,
    		input,
    		gb,
    		sb,
    		searchOpt,
    		createin,
    		$haslogin,
    		rc,
    		loc,
    		modifiers,
    		haslogin,
    		quit,
    		edited,
    		pgOpt,
    		auto,
    		inf,
    		fresh,
    		$rc,
    		$loc,
    		check0_state_binding,
    		check1_state_binding,
    		check2_state_binding,
    		numeric_val_binding,
    		link_binding,
    		link_binding_1,
    		link_binding_2,
    		link_binding_3,
    		input_1_binding,
    		input_1_focused_binding
    	];
    }

    class SearchBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$1f,
    			create_fragment$1f,
    			safe_not_equal,
    			{
    				query: 0,
    				preview: 4,
    				options: 5,
    				auto: 24,
    				result: 1,
    				inf: 25,
    				inhOpt: 2,
    				szOpt: 3,
    				pgOpt: 23
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SearchBar",
    			options,
    			id: create_fragment$1f.name
    		});
    	}

    	get query() {
    		throw new Error("<SearchBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set query(value) {
    		throw new Error("<SearchBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get preview() {
    		throw new Error("<SearchBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set preview(value) {
    		throw new Error("<SearchBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<SearchBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<SearchBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get auto() {
    		throw new Error("<SearchBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set auto(value) {
    		throw new Error("<SearchBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get result() {
    		throw new Error("<SearchBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set result(value) {
    		throw new Error("<SearchBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inf() {
    		throw new Error("<SearchBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inf(value) {
    		throw new Error("<SearchBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inhOpt() {
    		throw new Error("<SearchBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inhOpt(value) {
    		throw new Error("<SearchBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get szOpt() {
    		throw new Error("<SearchBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set szOpt(value) {
    		throw new Error("<SearchBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pgOpt() {
    		throw new Error("<SearchBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pgOpt(value) {
    		throw new Error("<SearchBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/util/Separated.svelte generated by Svelte v3.44.3 */
    const file$I = "src/util/Separated.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    const get_default_slot_changes$2 = dirty => ({ item: dirty & /*data*/ 8 });
    const get_default_slot_context$2 = ctx => ({ item: /*item*/ ctx[8] });
    const get_separator_slot_changes = dirty => ({ item: dirty & /*data*/ 8 });
    const get_separator_slot_context = ctx => ({ item: /*item*/ ctx[8] });

    // (14:4) {#if i > 0}
    function create_if_block$y(ctx) {
    	let current;
    	const separator_slot_template = /*#slots*/ ctx[6].separator;
    	const separator_slot = create_slot(separator_slot_template, ctx, /*$$scope*/ ctx[7], get_separator_slot_context);
    	const separator_slot_or_fallback = separator_slot || fallback_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (separator_slot_or_fallback) separator_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (separator_slot_or_fallback) {
    				separator_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (separator_slot) {
    				if (separator_slot.p && (!current || dirty & /*$$scope, data*/ 136)) {
    					update_slot_base(
    						separator_slot,
    						separator_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(separator_slot_template, /*$$scope*/ ctx[7], dirty, get_separator_slot_changes),
    						get_separator_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(separator_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(separator_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (separator_slot_or_fallback) separator_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$y.name,
    		type: "if",
    		source: "(14:4) {#if i > 0}",
    		ctx
    	});

    	return block;
    }

    // (15:29)          
    function fallback_block$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "·";
    			attr_dev(div, "class", "separator");
    			add_location(div, file$I, 15, 8, 345);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(15:29)          ",
    		ctx
    	});

    	return block;
    }

    // (13:2) {#each data as item, i}
    function create_each_block$c(ctx) {
    	let t;
    	let current;
    	let if_block = /*i*/ ctx[10] > 0 && create_if_block$y(ctx);
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context$2);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*i*/ ctx[10] > 0) if_block.p(ctx, dirty);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, data*/ 136)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, get_default_slot_changes$2),
    						get_default_slot_context$2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(13:2) {#each data as item, i}",
    		ctx
    	});

    	return block;
    }

    // (12:0) <FB c="separated" {line} {fw} {expand}>
    function create_default_slot$H(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*data*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$$scope, data*/ 136) {
    				each_value = /*data*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$H.name,
    		type: "slot",
    		source: "(12:0) <FB c=\\\"separated\\\" {line} {fw} {expand}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1e(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: "separated",
    				line: /*line*/ ctx[0],
    				fw: /*fw*/ ctx[1],
    				expand: /*expand*/ ctx[2],
    				$$slots: { default: [create_default_slot$H] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*line*/ 1) fb_changes.line = /*line*/ ctx[0];
    			if (dirty & /*fw*/ 2) fb_changes.fw = /*fw*/ ctx[1];
    			if (dirty & /*expand*/ 4) fb_changes.expand = /*expand*/ ctx[2];

    			if (dirty & /*$$scope, data*/ 136) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1e($$self, $$props, $$invalidate) {
    	let data;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Separated', slots, ['separator','default']);
    	let { items = [] } = $$props;
    	let { limit = null } = $$props;
    	let { line = "n" } = $$props;
    	let { fw = 4 } = $$props;
    	let { expand = false } = $$props;
    	const writable_props = ['items', 'limit', 'line', 'fw', 'expand'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Separated> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('items' in $$props) $$invalidate(4, items = $$props.items);
    		if ('limit' in $$props) $$invalidate(5, limit = $$props.limit);
    		if ('line' in $$props) $$invalidate(0, line = $$props.line);
    		if ('fw' in $$props) $$invalidate(1, fw = $$props.fw);
    		if ('expand' in $$props) $$invalidate(2, expand = $$props.expand);
    		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ FB, items, limit, line, fw, expand, data });

    	$$self.$inject_state = $$props => {
    		if ('items' in $$props) $$invalidate(4, items = $$props.items);
    		if ('limit' in $$props) $$invalidate(5, limit = $$props.limit);
    		if ('line' in $$props) $$invalidate(0, line = $$props.line);
    		if ('fw' in $$props) $$invalidate(1, fw = $$props.fw);
    		if ('expand' in $$props) $$invalidate(2, expand = $$props.expand);
    		if ('data' in $$props) $$invalidate(3, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*limit, items*/ 48) {
    			$$invalidate(3, data = limit ? items.slice(0, limit) : items);
    		}
    	};

    	return [line, fw, expand, data, items, limit, slots, $$scope];
    }

    class Separated extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {
    			items: 4,
    			limit: 5,
    			line: 0,
    			fw: 1,
    			expand: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Separated",
    			options,
    			id: create_fragment$1e.name
    		});
    	}

    	get items() {
    		throw new Error("<Separated>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Separated>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get limit() {
    		throw new Error("<Separated>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set limit(value) {
    		throw new Error("<Separated>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get line() {
    		throw new Error("<Separated>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set line(value) {
    		throw new Error("<Separated>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fw() {
    		throw new Error("<Separated>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fw(value) {
    		throw new Error("<Separated>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expand() {
    		throw new Error("<Separated>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expand(value) {
    		throw new Error("<Separated>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Headframe.svelte generated by Svelte v3.44.3 */

    // (30:1) {#if $ui <= 1}
    function create_if_block_3$7(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				$$slots: { default: [create_default_slot_13$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$7.name,
    		type: "if",
    		source: "(30:1) {#if $ui <= 1}",
    		ctx
    	});

    	return block;
    }

    // (32:3) <Separated line="s2" fw={6} items={bookmarks} let:item={item}>
    function create_default_slot_16$3(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: { nst: /*item*/ ctx[9] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*item*/ 512) link_changes.nst = /*item*/ ctx[9];
    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$3.name,
    		type: "slot",
    		source: "(32:3) <Separated line=\\\"s2\\\" fw={6} items={bookmarks} let:item={item}>",
    		ctx
    	});

    	return block;
    }

    // (36:3) <FB line="s2" fw={7}>
    function create_default_slot_15$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("RECENT");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$3.name,
    		type: "slot",
    		source: "(36:3) <FB line=\\\"s2\\\" fw={7}>",
    		ctx
    	});

    	return block;
    }

    // (37:3) <Separated line="s2" fw={6} items={bookmarks} let:item={item}>
    function create_default_slot_14$3(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: { nst: /*item*/ ctx[9] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*item*/ 512) link_changes.nst = /*item*/ ctx[9];
    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$3.name,
    		type: "slot",
    		source: "(37:3) <Separated line=\\\"s2\\\" fw={6} items={bookmarks} let:item={item}>",
    		ctx
    	});

    	return block;
    }

    // (31:2) <FB>
    function create_default_slot_13$3(ctx) {
    	let separated0;
    	let t0;
    	let fb0;
    	let t1;
    	let fb1;
    	let t2;
    	let separated1;
    	let current;

    	separated0 = new Separated({
    			props: {
    				line: "s2",
    				fw: 6,
    				items: /*bookmarks*/ ctx[4],
    				$$slots: {
    					default: [
    						create_default_slot_16$3,
    						({ item }) => ({ 9: item }),
    						({ item }) => item ? 512 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb0 = new FB({ props: { expand: true }, $$inline: true });

    	fb1 = new FB({
    			props: {
    				line: "s2",
    				fw: 7,
    				$$slots: { default: [create_default_slot_15$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	separated1 = new Separated({
    			props: {
    				line: "s2",
    				fw: 6,
    				items: /*bookmarks*/ ctx[4],
    				$$slots: {
    					default: [
    						create_default_slot_14$3,
    						({ item }) => ({ 9: item }),
    						({ item }) => item ? 512 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(separated0.$$.fragment);
    			t0 = space();
    			create_component(fb0.$$.fragment);
    			t1 = space();
    			create_component(fb1.$$.fragment);
    			t2 = space();
    			create_component(separated1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(separated0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(separated1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const separated0_changes = {};

    			if (dirty & /*$$scope, item*/ 1536) {
    				separated0_changes.$$scope = { dirty, ctx };
    			}

    			separated0.$set(separated0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    			const separated1_changes = {};

    			if (dirty & /*$$scope, item*/ 1536) {
    				separated1_changes.$$scope = { dirty, ctx };
    			}

    			separated1.$set(separated1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(separated0.$$.fragment, local);
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(separated1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(separated0.$$.fragment, local);
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(separated1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(separated0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(separated1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$3.name,
    		type: "slot",
    		source: "(31:2) <FB>",
    		ctx
    	});

    	return block;
    }

    // (49:2) {:else}
    function create_else_block$h(ctx) {
    	let logo;
    	let current;
    	logo = new Logo({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(logo.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(logo, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(logo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(logo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(logo, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$h.name,
    		type: "else",
    		source: "(49:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (44:2) {#if $ui <= 1}
    function create_if_block_2$9(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				zero: true,
    				$$slots: { default: [create_default_slot_12$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(44:2) {#if $ui <= 1}",
    		ctx
    	});

    	return block;
    }

    // (45:3) <FB vert zero>
    function create_default_slot_12$3(ctx) {
    	let logo;
    	let t;
    	let userbar;
    	let current;
    	logo = new Logo({ $$inline: true });

    	userbar = new UserBar({
    			props: { mini: true, generic: true },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(logo.$$.fragment);
    			t = space();
    			create_component(userbar.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(logo, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(userbar, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(logo.$$.fragment, local);
    			transition_in(userbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(logo.$$.fragment, local);
    			transition_out(userbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(logo, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(userbar, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$3.name,
    		type: "slot",
    		source: "(45:3) <FB vert zero>",
    		ctx
    	});

    	return block;
    }

    // (56:5) {#if $state.namespace}
    function create_if_block_1$h(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				title: true,
    				line: "s2",
    				fw: 6,
    				c: "title-sub",
    				$$slots: { default: [create_default_slot_11$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, $state*/ 1026) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(56:5) {#if $state.namespace}",
    		ctx
    	});

    	return block;
    }

    // (57:9) <FB title line="s2" fw={6} c="title-sub">
    function create_default_slot_11$5(ctx) {
    	let t_value = /*$state*/ ctx[1].namespace + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$state*/ 2 && t_value !== (t_value = /*$state*/ ctx[1].namespace + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$5.name,
    		type: "slot",
    		source: "(57:9) <FB title line=\\\"s2\\\" fw={6} c=\\\"title-sub\\\">",
    		ctx
    	});

    	return block;
    }

    // (59:8) <FB vc line="s4" fw={6}>
    function create_default_slot_10$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("▶");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$5.name,
    		type: "slot",
    		source: "(59:8) <FB vc line=\\\"s4\\\" fw={6}>",
    		ctx
    	});

    	return block;
    }

    // (55:4) <FB ve>
    function create_default_slot_9$5(ctx) {
    	let t;
    	let fb;
    	let current;
    	let if_block = /*$state*/ ctx[1].namespace && create_if_block_1$h(ctx);

    	fb = new FB({
    			props: {
    				vc: true,
    				line: "s4",
    				fw: 6,
    				$$slots: { default: [create_default_slot_10$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$state*/ ctx[1].namespace) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$state*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$5.name,
    		type: "slot",
    		source: "(55:4) <FB ve>",
    		ctx
    	});

    	return block;
    }

    // (63:5) <FB line="s2">
    function create_default_slot_8$5(ctx) {
    	let messenger;
    	let current;
    	messenger = new Messenger({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(messenger.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(messenger, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(messenger.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(messenger.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(messenger, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$5.name,
    		type: "slot",
    		source: "(63:5) <FB line=\\\"s2\\\">",
    		ctx
    	});

    	return block;
    }

    // (62:4) <FB vert center>
    function create_default_slot_7$9(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				line: "s2",
    				$$slots: { default: [create_default_slot_8$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$9.name,
    		type: "slot",
    		source: "(62:4) <FB vert center>",
    		ctx
    	});

    	return block;
    }

    // (65:4) {#if $ui <= 1}
    function create_if_block$x(ctx) {
    	let searchbar;
    	let current;

    	searchbar = new SearchBar({
    			props: {
    				preview: true,
    				auto: true,
    				inf: "title",
    				szOpt: 5
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(searchbar.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(searchbar, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(searchbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(searchbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(searchbar, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$x.name,
    		type: "if",
    		source: "(65:4) {#if $ui <= 1}",
    		ctx
    	});

    	return block;
    }

    // (54:3) <FB expand c={$ui <= 1 ? "base-head-upper" : ''}>
    function create_default_slot_6$9(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let fb2;
    	let t2;
    	let if_block_anchor;
    	let current;

    	fb0 = new FB({
    			props: {
    				ve: true,
    				$$slots: { default: [create_default_slot_9$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({ props: { expand: true }, $$inline: true });

    	fb2 = new FB({
    			props: {
    				vert: true,
    				center: true,
    				$$slots: { default: [create_default_slot_7$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$ui*/ ctx[0] <= 1 && create_if_block$x(ctx);

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    			create_component(fb2.$$.fragment);
    			t2 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb2, target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope, $state*/ 1026) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb2_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				fb2_changes.$$scope = { dirty, ctx };
    			}

    			fb2.$set(fb2_changes);

    			if (/*$ui*/ ctx[0] <= 1) {
    				if (if_block) {
    					if (dirty & /*$ui*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$x(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(fb2.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(fb2.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb2, detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$9.name,
    		type: "slot",
    		source: "(54:3) <FB expand c={$ui <= 1 ? \\\"base-head-upper\\\" : ''}>",
    		ctx
    	});

    	return block;
    }

    // (69:4) <FB title line="b3" fw={8} c="title-main">
    function create_default_slot_5$c(ctx) {
    	let t_value = /*$state*/ ctx[1].title + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$state*/ 2 && t_value !== (t_value = /*$state*/ ctx[1].title + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$c.name,
    		type: "slot",
    		source: "(69:4) <FB title line=\\\"b3\\\" fw={8} c=\\\"title-main\\\">",
    		ctx
    	});

    	return block;
    }

    // (70:4) <FB vert end>
    function create_default_slot_4$d(ctx) {
    	let titlecontrols;
    	let current;
    	titlecontrols = new TitleControls({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(titlecontrols.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(titlecontrols, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(titlecontrols.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(titlecontrols.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(titlecontrols, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$d.name,
    		type: "slot",
    		source: "(70:4) <FB vert end>",
    		ctx
    	});

    	return block;
    }

    // (68:3) <FB between>
    function create_default_slot_3$h(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				title: true,
    				line: "b3",
    				fw: 8,
    				c: "title-main",
    				$$slots: { default: [create_default_slot_5$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				vert: true,
    				end: true,
    				$$slots: { default: [create_default_slot_4$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope, $state*/ 1026) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$h.name,
    		type: "slot",
    		source: "(68:3) <FB between>",
    		ctx
    	});

    	return block;
    }

    // (53:2) <FB expand vert zero>
    function create_default_slot_2$o(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				expand: true,
    				c: /*$ui*/ ctx[0] <= 1 ? "base-head-upper" : '',
    				$$slots: { default: [create_default_slot_6$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				between: true,
    				$$slots: { default: [create_default_slot_3$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};
    			if (dirty & /*$ui*/ 1) fb0_changes.c = /*$ui*/ ctx[0] <= 1 ? "base-head-upper" : '';

    			if (dirty & /*$$scope, $ui, $state*/ 1027) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope, $state*/ 1026) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$o.name,
    		type: "slot",
    		source: "(53:2) <FB expand vert zero>",
    		ctx
    	});

    	return block;
    }

    // (43:1) <FB>
    function create_default_slot_1$t(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let fb;
    	let current;
    	const if_block_creators = [create_if_block_2$9, create_else_block$h];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$ui*/ ctx[0] <= 1) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	fb = new FB({
    			props: {
    				expand: true,
    				vert: true,
    				zero: true,
    				$$slots: { default: [create_default_slot_2$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if_block.c();
    			t = space();
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(t.parentNode, t);
    			}

    			const fb_changes = {};

    			if (dirty & /*$$scope, $state, $ui*/ 1027) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$t.name,
    		type: "slot",
    		source: "(43:1) <FB>",
    		ctx
    	});

    	return block;
    }

    // (28:0) <FB vert c="head-frame">
    function create_default_slot$G(ctx) {
    	let t;
    	let fb;
    	let current;
    	let if_block = /*$ui*/ ctx[0] <= 1 && create_if_block_3$7(ctx);

    	fb = new FB({
    			props: {
    				$$slots: { default: [create_default_slot_1$t] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$ui*/ ctx[0] <= 1) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$ui*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const fb_changes = {};

    			if (dirty & /*$$scope, $state, $ui*/ 1027) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$G.name,
    		type: "slot",
    		source: "(28:0) <FB vert c=\\\"head-frame\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1d(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				c: "head-frame",
    				$$slots: { default: [create_default_slot$G] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, $state, $ui*/ 1027) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	let $ui;
    	let $state;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Headframe', slots, []);
    	const gs = getContext('gs');
    	const path = getContext('path');
    	const session = getContext('session');
    	const hassess = getContext('hassess');
    	const state = getContext('state');
    	validate_store(state, 'state');
    	component_subscribe($$self, state, value => $$invalidate(1, $state = value));
    	const ui = getContext('ui');
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, value => $$invalidate(0, $ui = value));

    	let bookmarks = [
    		'Home',
    		'foo',
    		'bar',
    		'CPB:test',
    		'CPB:forms',
    		'CPB:user',
    		'CPB:login',
    		'scop:uli',
    		'foo:bar',
    		'foo:baz'
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Headframe> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		QR,
    		Link: Link$1,
    		FB,
    		Strike,
    		UUID,
    		Logo,
    		Bookmarks: Bookmarks$1,
    		UserBar,
    		TitleControls,
    		Messenger,
    		SearchBar,
    		Separated,
    		getContext,
    		gs,
    		path,
    		session,
    		hassess,
    		state,
    		ui,
    		bookmarks,
    		$ui,
    		$state
    	});

    	$$self.$inject_state = $$props => {
    		if ('bookmarks' in $$props) $$invalidate(4, bookmarks = $$props.bookmarks);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$ui, $state, state, ui, bookmarks];
    }

    class Headframe extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Headframe",
    			options,
    			id: create_fragment$1d.name
    		});
    	}
    }

    /* src/ContentControls.svelte generated by Svelte v3.44.3 */

    // (39:4) <Link nolink does={handlers[item.name]}>
    function create_default_slot_2$n(ctx) {
    	let t_value = /*item*/ ctx[6].label + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*item*/ 64 && t_value !== (t_value = /*item*/ ctx[6].label + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$n.name,
    		type: "slot",
    		source: "(39:4) <Link nolink does={handlers[item.name]}>",
    		ctx
    	});

    	return block;
    }

    // (38:2) <Separated items={controls} line="s1" let:item={item}>
    function create_default_slot_1$s(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				nolink: true,
    				does: /*handlers*/ ctx[2][/*item*/ ctx[6].name],
    				$$slots: { default: [create_default_slot_2$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*item*/ 64) link_changes.does = /*handlers*/ ctx[2][/*item*/ ctx[6].name];

    			if (dirty & /*$$scope, item*/ 192) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$s.name,
    		type: "slot",
    		source: "(38:2) <Separated items={controls} line=\\\"s1\\\" let:item={item}>",
    		ctx
    	});

    	return block;
    }

    // (37:0) <FB c="content-controls" end>
    function create_default_slot$F(ctx) {
    	let separated;
    	let current;

    	separated = new Separated({
    			props: {
    				items: /*controls*/ ctx[0],
    				line: "s1",
    				$$slots: {
    					default: [
    						create_default_slot_1$s,
    						({ item }) => ({ 6: item }),
    						({ item }) => item ? 64 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(separated.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(separated, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const separated_changes = {};
    			if (dirty & /*controls*/ 1) separated_changes.items = /*controls*/ ctx[0];

    			if (dirty & /*$$scope, item*/ 192) {
    				separated_changes.$$scope = { dirty, ctx };
    			}

    			separated.$set(separated_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(separated.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(separated.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(separated, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$F.name,
    		type: "slot",
    		source: "(37:0) <FB c=\\\"content-controls\\\" end>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1c(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: "content-controls",
    				end: true,
    				$$slots: { default: [create_default_slot$F] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, controls*/ 129) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1c($$self, $$props, $$invalidate) {
    	let $haslogin;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ContentControls', slots, []);
    	const haslogin = getContext('haslogin');
    	validate_store(haslogin, 'haslogin');
    	component_subscribe($$self, haslogin, value => $$invalidate(3, $haslogin = value));

    	class Control {
    		constructor(name, label) {
    			this.name = name;
    			this.label = label || name;
    		}
    	}

    	let controls = [];

    	const handlers = {
    		bookmark: () => {
    			
    		},
    		move: () => {
    			
    		},
    		delete: () => {
    			
    		},
    		duplicate: () => {
    			
    		}
    	};

    	const mkcontrols = () => {
    		const c = [];

    		if ($haslogin) {
    			c.push(new Control('bookmark'));
    			c.push(new Control('move'));
    			c.push(new Control('delete'));
    			c.push(new Control('duplicate'));
    		}

    		$$invalidate(0, controls = c);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ContentControls> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		FB,
    		Link: Link$1,
    		Separated,
    		getContext,
    		haslogin,
    		Control,
    		controls,
    		handlers,
    		mkcontrols,
    		$haslogin
    	});

    	$$self.$inject_state = $$props => {
    		if ('controls' in $$props) $$invalidate(0, controls = $$props.controls);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$haslogin*/ 8) {
    			mkcontrols();
    		}
    	};

    	return [controls, haslogin, handlers, $haslogin];
    }

    class ContentControls extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContentControls",
    			options,
    			id: create_fragment$1c.name
    		});
    	}
    }

    /* src/util/Tabulate.svelte generated by Svelte v3.44.3 */

    const { Object: Object_1$2 } = globals;

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (38:10) {:else}
    function create_else_block$g(ctx) {
    	let strike;
    	let current;
    	strike = new Strike({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(strike.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(strike, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(strike.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(strike.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(strike, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$g.name,
    		type: "else",
    		source: "(38:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (34:10) {#if pair}
    function create_if_block$w(ctx) {
    	let fb0;
    	let t0;
    	let strike;
    	let t1;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				c: "cpbtab-key",
    				$$slots: { default: [create_default_slot_4$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	strike = new Strike({ $$inline: true });

    	fb1 = new FB({
    			props: {
    				c: "cpbtab-val",
    				$$slots: { default: [create_default_slot_3$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(strike.$$.fragment);
    			t1 = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(strike, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope, chunks*/ 16386) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope, chunks*/ 16386) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(strike.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(strike.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(strike, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(34:10) {#if pair}",
    		ctx
    	});

    	return block;
    }

    // (35:12) <FB c="cpbtab-key">
    function create_default_slot_4$c(ctx) {
    	let t_value = /*pair*/ ctx[11][0] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chunks*/ 2 && t_value !== (t_value = /*pair*/ ctx[11][0] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$c.name,
    		type: "slot",
    		source: "(35:12) <FB c=\\\"cpbtab-key\\\">",
    		ctx
    	});

    	return block;
    }

    // (37:12) <FB c="cpbtab-val">
    function create_default_slot_3$g(ctx) {
    	let t_value = /*pair*/ ctx[11][1] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chunks*/ 2 && t_value !== (t_value = /*pair*/ ctx[11][1] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$g.name,
    		type: "slot",
    		source: "(37:12) <FB c=\\\"cpbtab-val\\\">",
    		ctx
    	});

    	return block;
    }

    // (33:8) <FB {line} c="cpbtab-row">
    function create_default_slot_2$m(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$w, create_else_block$g];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*pair*/ ctx[11]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$m.name,
    		type: "slot",
    		source: "(33:8) <FB {line} c=\\\"cpbtab-row\\\">",
    		ctx
    	});

    	return block;
    }

    // (32:6) {#each chunk as pair}
    function create_each_block_1$4(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				line: /*line*/ ctx[0],
    				c: "cpbtab-row",
    				$$slots: { default: [create_default_slot_2$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};
    			if (dirty & /*line*/ 1) fb_changes.line = /*line*/ ctx[0];

    			if (dirty & /*$$scope, chunks*/ 16386) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(32:6) {#each chunk as pair}",
    		ctx
    	});

    	return block;
    }

    // (31:4) <FB vert c="cpbtab-col col{ci+1}">
    function create_default_slot_1$r(ctx) {
    	let t;
    	let current;
    	let each_value_1 = /*chunk*/ ctx[8];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*line, chunks*/ 3) {
    				each_value_1 = /*chunk*/ ctx[8];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$r.name,
    		type: "slot",
    		source: "(31:4) <FB vert c=\\\"cpbtab-col col{ci+1}\\\">",
    		ctx
    	});

    	return block;
    }

    // (30:2) {#each chunks as chunk, ci}
    function create_each_block$b(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				c: "cpbtab-col col" + (/*ci*/ ctx[10] + 1),
    				$$slots: { default: [create_default_slot_1$r] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, chunks, line*/ 16387) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(30:2) {#each chunks as chunk, ci}",
    		ctx
    	});

    	return block;
    }

    // (29:0) <FB c="cpbtab cols-{cols} {usec}" around>
    function create_default_slot$E(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*chunks*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chunks, line*/ 3) {
    				each_value = /*chunks*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$E.name,
    		type: "slot",
    		source: "(29:0) <FB c=\\\"cpbtab cols-{cols} {usec}\\\" around>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1b(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: "cpbtab cols-" + /*cols*/ ctx[2] + " " + /*usec*/ ctx[3],
    				around: true,
    				$$slots: { default: [create_default_slot$E] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*cols, usec*/ 12) fb_changes.c = "cpbtab cols-" + /*cols*/ ctx[2] + " " + /*usec*/ ctx[3];

    			if (dirty & /*$$scope, chunks, line*/ 16387) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tabulate', slots, []);
    	let { data = {} } = $$props;
    	let { rows = 3 } = $$props;
    	let { line = 'n' } = $$props;
    	let { usew = 9 } = $$props;
    	let chunks = [];
    	let cols = 0;
    	let usec = '';

    	const parse = () => {
    		const entries = Object.entries(data);
    		$$invalidate(1, chunks = []);

    		for (let i = 0; i < entries.length; i += rows) {
    			const chunk = entries.slice(i, i + rows);
    			const short = rows - chunk.length;
    			[...Array(short).keys()].forEach(s => chunk.push(null));
    			chunks.push(chunk);
    		}

    		$$invalidate(2, cols = chunks.length);
    	};

    	const writable_props = ['data', 'rows', 'line', 'usew'];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tabulate> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('data' in $$props) $$invalidate(4, data = $$props.data);
    		if ('rows' in $$props) $$invalidate(5, rows = $$props.rows);
    		if ('line' in $$props) $$invalidate(0, line = $$props.line);
    		if ('usew' in $$props) $$invalidate(6, usew = $$props.usew);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		Strike,
    		data,
    		rows,
    		line,
    		usew,
    		chunks,
    		cols,
    		usec,
    		parse
    	});

    	$$self.$inject_state = $$props => {
    		if ('data' in $$props) $$invalidate(4, data = $$props.data);
    		if ('rows' in $$props) $$invalidate(5, rows = $$props.rows);
    		if ('line' in $$props) $$invalidate(0, line = $$props.line);
    		if ('usew' in $$props) $$invalidate(6, usew = $$props.usew);
    		if ('chunks' in $$props) $$invalidate(1, chunks = $$props.chunks);
    		if ('cols' in $$props) $$invalidate(2, cols = $$props.cols);
    		if ('usec' in $$props) $$invalidate(3, usec = $$props.usec);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data, rows*/ 48) {
    			parse();
    		}

    		if ($$self.$$.dirty & /*usew*/ 64) {
    			$$invalidate(3, usec = `tab${usew * 10}`);
    		}
    	};

    	return [line, chunks, cols, usec, data, rows, usew];
    }

    class Tabulate extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, { data: 4, rows: 5, line: 0, usew: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabulate",
    			options,
    			id: create_fragment$1b.name
    		});
    	}

    	get data() {
    		throw new Error("<Tabulate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Tabulate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rows() {
    		throw new Error("<Tabulate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rows(value) {
    		throw new Error("<Tabulate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get line() {
    		throw new Error("<Tabulate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set line(value) {
    		throw new Error("<Tabulate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get usew() {
    		throw new Error("<Tabulate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set usew(value) {
    		throw new Error("<Tabulate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * @preserve date-and-time (c) KNOWLEDGECODE | MIT
     */

    var locales = {},
        plugins = {},
        lang$1 = 'en',
        _res = {
            MMMM: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
            MMM: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            dddd: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            ddd: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            dd: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
            A: ['AM', 'PM']
        },
        _formatter = {
            YYYY: function (d/*, formatString*/) { return ('000' + d.getFullYear()).slice(-4); },
            YY: function (d/*, formatString*/) { return ('0' + d.getFullYear()).slice(-2); },
            Y: function (d/*, formatString*/) { return '' + d.getFullYear(); },
            MMMM: function (d/*, formatString*/) { return this.res.MMMM[d.getMonth()]; },
            MMM: function (d/*, formatString*/) { return this.res.MMM[d.getMonth()]; },
            MM: function (d/*, formatString*/) { return ('0' + (d.getMonth() + 1)).slice(-2); },
            M: function (d/*, formatString*/) { return '' + (d.getMonth() + 1); },
            DD: function (d/*, formatString*/) { return ('0' + d.getDate()).slice(-2); },
            D: function (d/*, formatString*/) { return '' + d.getDate(); },
            HH: function (d/*, formatString*/) { return ('0' + d.getHours()).slice(-2); },
            H: function (d/*, formatString*/) { return '' + d.getHours(); },
            A: function (d/*, formatString*/) { return this.res.A[d.getHours() > 11 | 0]; },
            hh: function (d/*, formatString*/) { return ('0' + (d.getHours() % 12 || 12)).slice(-2); },
            h: function (d/*, formatString*/) { return '' + (d.getHours() % 12 || 12); },
            mm: function (d/*, formatString*/) { return ('0' + d.getMinutes()).slice(-2); },
            m: function (d/*, formatString*/) { return '' + d.getMinutes(); },
            ss: function (d/*, formatString*/) { return ('0' + d.getSeconds()).slice(-2); },
            s: function (d/*, formatString*/) { return '' + d.getSeconds(); },
            SSS: function (d/*, formatString*/) { return ('00' + d.getMilliseconds()).slice(-3); },
            SS: function (d/*, formatString*/) { return ('0' + (d.getMilliseconds() / 10 | 0)).slice(-2); },
            S: function (d/*, formatString*/) { return '' + (d.getMilliseconds() / 100 | 0); },
            dddd: function (d/*, formatString*/) { return this.res.dddd[d.getDay()]; },
            ddd: function (d/*, formatString*/) { return this.res.ddd[d.getDay()]; },
            dd: function (d/*, formatString*/) { return this.res.dd[d.getDay()]; },
            Z: function (d/*, formatString*/) {
                var offset = d.getTimezoneOffset() / 0.6 | 0;
                return (offset > 0 ? '-' : '+') + ('000' + Math.abs(offset - (offset % 100 * 0.4 | 0))).slice(-4);
            },
            post: function (str) { return str; },
            res: _res
        },
        _parser = {
            YYYY: function (str/*, formatString */) { return this.exec(/^\d{4}/, str); },
            Y: function (str/*, formatString */) { return this.exec(/^\d{1,4}/, str); },
            MMMM: function (str/*, formatString */) {
                var result = this.find(this.res.MMMM, str);
                result.value++;
                return result;
            },
            MMM: function (str/*, formatString */) {
                var result = this.find(this.res.MMM, str);
                result.value++;
                return result;
            },
            MM: function (str/*, formatString */) { return this.exec(/^\d\d/, str); },
            M: function (str/*, formatString */) { return this.exec(/^\d\d?/, str); },
            DD: function (str/*, formatString */) { return this.exec(/^\d\d/, str); },
            D: function (str/*, formatString */) { return this.exec(/^\d\d?/, str); },
            HH: function (str/*, formatString */) { return this.exec(/^\d\d/, str); },
            H: function (str/*, formatString */) { return this.exec(/^\d\d?/, str); },
            A: function (str/*, formatString */) { return this.find(this.res.A, str); },
            hh: function (str/*, formatString */) { return this.exec(/^\d\d/, str); },
            h: function (str/*, formatString */) { return this.exec(/^\d\d?/, str); },
            mm: function (str/*, formatString */) { return this.exec(/^\d\d/, str); },
            m: function (str/*, formatString */) { return this.exec(/^\d\d?/, str); },
            ss: function (str/*, formatString */) { return this.exec(/^\d\d/, str); },
            s: function (str/*, formatString */) { return this.exec(/^\d\d?/, str); },
            SSS: function (str/*, formatString */) { return this.exec(/^\d{1,3}/, str); },
            SS: function (str/*, formatString */) {
                var result = this.exec(/^\d\d?/, str);
                result.value *= 10;
                return result;
            },
            S: function (str/*, formatString */) {
                var result = this.exec(/^\d/, str);
                result.value *= 100;
                return result;
            },
            Z: function (str/*, formatString */) {
                var result = this.exec(/^[\+-]\d{2}[0-5]\d/, str);
                result.value = (result.value / 100 | 0) * -60 - result.value % 100;
                return result;
            },
            h12: function (h, a) { return (h === 12 ? 0 : h) + a * 12; },
            exec: function (re, str) {
                var result = (re.exec(str) || [''])[0];
                return { value: result | 0, length: result.length };
            },
            find: function (array, str) {
                var index = -1, length = 0;

                for (var i = 0, len = array.length, item; i < len; i++) {
                    item = array[i];
                    if (!str.indexOf(item) && item.length > length) {
                        index = i;
                        length = item.length;
                    }
                }
                return { value: index, length: length };
            },
            pre: function (str) { return str; },
            res: _res
        },
        extend = function (base, props, override, res) {
            var obj = {}, key;

            for (key in base) {
                obj[key] = base[key];
            }
            for (key in props || {}) {
                if (!(!!override ^ !!obj[key])) {
                    obj[key] = props[key];
                }
            }
            if (res) {
                obj.res = res;
            }
            return obj;
        },
        proto = {
            _formatter: _formatter,
            _parser: _parser
        },
        localized_proto,
        date;

    /**
     * Compiling a format string
     * @param {string} formatString - a format string
     * @returns {Array.<string>} a compiled object
     */
    proto.compile = function (formatString) {
        var re = /\[([^\[\]]|\[[^\[\]]*])*]|([A-Za-z])\2+|\.{3}|./g, keys, pattern = [formatString];

        while ((keys = re.exec(formatString))) {
            pattern[pattern.length] = keys[0];
        }
        return pattern;
    };

    /**
     * Formatting a Date and Time
     * @param {Date} dateObj - a Date object
     * @param {string|Array.<string>} arg - a format string or its compiled object
     * @param {boolean} [utc] - output as UTC
     * @returns {string} a formatted string
     */
    proto.format = function (dateObj, arg, utc) {
        var ctx = this || date, pattern = typeof arg === 'string' ? ctx.compile(arg) : arg,
            offset = dateObj.getTimezoneOffset(),
            d = ctx.addMinutes(dateObj, utc ? offset : 0),
            formatter = ctx._formatter, str = '';

        d.getTimezoneOffset = function () { return utc ? 0 : offset; };
        for (var i = 1, len = pattern.length, token; i < len; i++) {
            token = pattern[i];
            str += formatter[token] ? formatter.post(formatter[token](d, pattern[0])) : token.replace(/\[(.*)]/, '$1');
        }
        return str;
    };

    /**
     * Pre-parsing a Date and Time string
     * @param {string} dateString - a date string
     * @param {string|Array.<string>} arg - a format string or its compiled object
     * @returns {Object} a date structure
     */
    proto.preparse = function (dateString, arg) {
        var ctx = this || date, pattern = typeof arg === 'string' ? ctx.compile(arg) : arg,
            dt = { Y: 1970, M: 1, D: 1, H: 0, A: 0, h: 0, m: 0, s: 0, S: 0, Z: 0, _index: 0, _length: 0, _match: 0 },
            comment = /\[(.*)]/, parser = ctx._parser, offset = 0;

        dateString = parser.pre(dateString);
        for (var i = 1, len = pattern.length, token, result; i < len; i++) {
            token = pattern[i];
            if (parser[token]) {
                result = parser[token](dateString.slice(offset), pattern[0]);
                if (!result.length) {
                    break;
                }
                offset += result.length;
                dt[result.token || token.charAt(0)] = result.value;
                dt._match++;
            } else if (token === dateString.charAt(offset) || token === ' ') {
                offset++;
            } else if (comment.test(token) && !dateString.slice(offset).indexOf(comment.exec(token)[1])) {
                offset += token.length - 2;
            } else if (token === '...') {
                offset = dateString.length;
                break;
            } else {
                break;
            }
        }
        dt.H = dt.H || parser.h12(dt.h, dt.A);
        dt._index = offset;
        dt._length = dateString.length;
        return dt;
    };

    /**
     * Parsing a Date and Time string
     * @param {string} dateString - a date string
     * @param {string|Array.<string>} arg - a format string or its compiled object
     * @param {boolean} [utc] - input as UTC
     * @returns {Date} a constructed date
     */
    proto.parse = function (dateString, arg, utc) {
        var ctx = this || date, dt = ctx.preparse(dateString, arg);

        if (ctx.isValid(dt)) {
            dt.M -= dt.Y < 100 ? 22801 : 1; // 22801 = 1900 * 12 + 1
            if (utc || dt.Z) {
                return new Date(Date.UTC(dt.Y, dt.M, dt.D, dt.H, dt.m + dt.Z, dt.s, dt.S));
            }
            return new Date(dt.Y, dt.M, dt.D, dt.H, dt.m, dt.s, dt.S);
        }
        return new Date(NaN);
    };

    /**
     * Validation
     * @param {Object|string} arg1 - a date structure or a date string
     * @param {string|Array.<string>} [arg2] - a format string or its compiled object
     * @returns {boolean} whether the date string is a valid date
     */
    proto.isValid = function (arg1, arg2) {
        var ctx = this || date, dt = typeof arg1 === 'string' ? ctx.preparse(arg1, arg2) : arg1,
            last = [31, 28 + ctx.isLeapYear(dt.Y) | 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][dt.M - 1];

        return !(
            dt._index < 1 || dt._length < 1 || dt._index - dt._length || dt._match < 1 ||
            dt.Y < 1 || dt.Y > 9999 || dt.M < 1 || dt.M > 12 || dt.D < 1 || dt.D > last ||
            dt.H < 0 || dt.H > 23 || dt.m < 0 || dt.m > 59 || dt.s < 0 || dt.s > 59 || dt.S < 0 || dt.S > 999 ||
            dt.Z < -720 || dt.Z > 840
        );
    };

    /**
     * Transforming a Date and Time string
     * @param {string} dateString - a date string
     * @param {string|Array.<string>} arg1 - a format string or its compiled object
     * @param {string|Array.<string>} arg2 - a transformed format string or its compiled object
     * @param {boolean} [utc] - output as UTC
     * @returns {string} a formatted string
     */
    proto.transform = function (dateString, arg1, arg2, utc) {
        const ctx = this || date;
        return ctx.format(ctx.parse(dateString, arg1), arg2, utc);
    };

    /**
     * Adding years
     * @param {Date} dateObj - a date object
     * @param {number} years - number of years to add
     * @returns {Date} a date after adding the value
     */
    proto.addYears = function (dateObj, years) {
        return (this || date).addMonths(dateObj, years * 12);
    };

    /**
     * Adding months
     * @param {Date} dateObj - a date object
     * @param {number} months - number of months to add
     * @returns {Date} a date after adding the value
     */
    proto.addMonths = function (dateObj, months) {
        var d = new Date(dateObj.getTime());

        d.setMonth(d.getMonth() + months);
        return d;
    };

    /**
     * Adding days
     * @param {Date} dateObj - a date object
     * @param {number} days - number of days to add
     * @returns {Date} a date after adding the value
     */
    proto.addDays = function (dateObj, days) {
        var d = new Date(dateObj.getTime());

        d.setDate(d.getDate() + days);
        return d;
    };

    /**
     * Adding hours
     * @param {Date} dateObj - a date object
     * @param {number} hours - number of hours to add
     * @returns {Date} a date after adding the value
     */
    proto.addHours = function (dateObj, hours) {
        return (this || date).addMinutes(dateObj, hours * 60);
    };

    /**
     * Adding minutes
     * @param {Date} dateObj - a date object
     * @param {number} minutes - number of minutes to add
     * @returns {Date} a date after adding the value
     */
    proto.addMinutes = function (dateObj, minutes) {
        return (this || date).addSeconds(dateObj, minutes * 60);
    };

    /**
     * Adding seconds
     * @param {Date} dateObj - a date object
     * @param {number} seconds - number of seconds to add
     * @returns {Date} a date after adding the value
     */
    proto.addSeconds = function (dateObj, seconds) {
        return (this || date).addMilliseconds(dateObj, seconds * 1000);
    };

    /**
     * Adding milliseconds
     * @param {Date} dateObj - a date object
     * @param {number} milliseconds - number of milliseconds to add
     * @returns {Date} a date after adding the value
     */
    proto.addMilliseconds = function (dateObj, milliseconds) {
        return new Date(dateObj.getTime() + milliseconds);
    };

    /**
     * Subtracting two dates
     * @param {Date} date1 - a Date object
     * @param {Date} date2 - a Date object
     * @returns {Object} a result object subtracting date2 from date1
     */
    proto.subtract = function (date1, date2) {
        var delta = date1.getTime() - date2.getTime();

        return {
            toMilliseconds: function () {
                return delta;
            },
            toSeconds: function () {
                return delta / 1000;
            },
            toMinutes: function () {
                return delta / 60000;
            },
            toHours: function () {
                return delta / 3600000;
            },
            toDays: function () {
                return delta / 86400000;
            }
        };
    };

    /**
     * Whether year is leap year
     * @param {number} y - year
     * @returns {boolean} whether year is leap year
     */
    proto.isLeapYear = function (y) {
        return (!(y % 4) && !!(y % 100)) || !(y % 400);
    };

    /**
     * Comparison of two dates
     * @param {Date} date1 - a Date object
     * @param {Date} date2 - a Date object
     * @returns {boolean} whether the two dates are the same day (time is ignored)
     */
    proto.isSameDay = function (date1, date2) {
        return date1.toDateString() === date2.toDateString();
    };

    /**
     * Defining new locale
     * @param {string} code - language code
     * @param {Function} locale - locale installer
     * @returns {string} current language code
     */
    proto.locale = function (code, locale) {
        if (!locales[code]) {
            locales[code] = locale;
        }
    };

    /**
     * Defining new plugin
     * @param {string} name - plugin name
     * @param {Function} plugin - plugin installer
     * @returns {void}
     */
    proto.plugin = function (name, plugin) {
        if (!plugins[name]) {
            plugins[name] = plugin;
        }
    };

    localized_proto = extend(proto);
    date = extend(proto);

    /**
     * Changing locale
     * @param {Function|string} [locale] - locale object | language code
     * @returns {string} current language code
     */
    date.locale = function (locale) {
        var install = typeof locale === 'function' ? locale : date.locale[locale];

        if (!install) {
            return lang$1;
        }
        lang$1 = install(proto);

        var extension = locales[lang$1] || {};
        var res = extend(_res, extension.res, true);
        var formatter = extend(_formatter, extension.formatter, true, res);
        var parser = extend(_parser, extension.parser, true, res);

        date._formatter = localized_proto._formatter = formatter;
        date._parser = localized_proto._parser = parser;

        for (var plugin in plugins) {
            date.extend(plugins[plugin]);
        }

        return lang$1;
    };

    /**
     * Feature extension
     * @param {Object} extension - extension object
     * @returns {void}
     */
    date.extend = function (extension) {
        var res = extend(date._parser.res, extension.res);
        var extender = extension.extender || {};

        date._formatter = extend(date._formatter, extension.formatter, false, res);
        date._parser = extend(date._parser, extension.parser, false, res);

        for (var key in extender) {
            if (!date[key]) {
                date[key] = extender[key];
            }
        }
    };

    /**
     * Importing plugin
     * @param {Function|string} plugin - plugin object | plugin name
     * @returns {void}
     */
    date.plugin = function (plugin) {
        var install = typeof plugin === 'function' ? plugin : date.plugin[plugin];

        if (install) {
            date.extend(plugins[install(proto, localized_proto)] || {});
        }
    };

    var date$1 = date;

    /* src/Titleframe.svelte generated by Svelte v3.44.3 */

    // (40:1) {#if $haspage}
    function create_if_block$v(ctx) {
    	let contentcontrols;
    	let t;
    	let fb;
    	let current;
    	contentcontrols = new ContentControls({ $$inline: true });

    	fb = new FB({
    			props: {
    				$$slots: { default: [create_default_slot_1$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(contentcontrols.$$.fragment);
    			t = space();
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(contentcontrols, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, permac, $page, data, vpermac*/ 32797) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contentcontrols.$$.fragment, local);
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contentcontrols.$$.fragment, local);
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(contentcontrols, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(40:1) {#if $haspage}",
    		ctx
    	});

    	return block;
    }

    // (44:3) <FB expand vert center>
    function create_default_slot_2$l(ctx) {
    	let tabulate;
    	let current;

    	tabulate = new Tabulate({
    			props: { data: /*data*/ ctx[4], line: "s1" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tabulate.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tabulate, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tabulate_changes = {};
    			if (dirty & /*data*/ 16) tabulate_changes.data = /*data*/ ctx[4];
    			tabulate.$set(tabulate_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabulate.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabulate.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tabulate, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$l.name,
    		type: "slot",
    		source: "(44:3) <FB expand vert center>",
    		ctx
    	});

    	return block;
    }

    // (42:2) <FB>
    function create_default_slot_1$q(ctx) {
    	let qr0;
    	let t0;
    	let fb;
    	let t1;
    	let qr1;
    	let current;

    	qr0 = new QR({
    			props: {
    				data: /*vpermac*/ ctx[3],
    				ver: 3,
    				scale: 2,
    				uuid: /*$page*/ ctx[0].val.uuid,
    				title: "Version Permalink"
    			},
    			$$inline: true
    		});

    	fb = new FB({
    			props: {
    				expand: true,
    				vert: true,
    				center: true,
    				$$slots: { default: [create_default_slot_2$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	qr1 = new QR({
    			props: {
    				data: /*permac*/ ctx[2],
    				ver: 3,
    				scale: 2,
    				uuid: /*$page*/ ctx[0].val.pageUuid,
    				title: "Page Permalink"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(qr0.$$.fragment);
    			t0 = space();
    			create_component(fb.$$.fragment);
    			t1 = space();
    			create_component(qr1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(qr0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(qr1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const qr0_changes = {};
    			if (dirty & /*vpermac*/ 8) qr0_changes.data = /*vpermac*/ ctx[3];
    			if (dirty & /*$page*/ 1) qr0_changes.uuid = /*$page*/ ctx[0].val.uuid;
    			qr0.$set(qr0_changes);
    			const fb_changes = {};

    			if (dirty & /*$$scope, data*/ 32784) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    			const qr1_changes = {};
    			if (dirty & /*permac*/ 4) qr1_changes.data = /*permac*/ ctx[2];
    			if (dirty & /*$page*/ 1) qr1_changes.uuid = /*$page*/ ctx[0].val.pageUuid;
    			qr1.$set(qr1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(qr0.$$.fragment, local);
    			transition_in(fb.$$.fragment, local);
    			transition_in(qr1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(qr0.$$.fragment, local);
    			transition_out(fb.$$.fragment, local);
    			transition_out(qr1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(qr0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(qr1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$q.name,
    		type: "slot",
    		source: "(42:2) <FB>",
    		ctx
    	});

    	return block;
    }

    // (39:0) <FB vert c="title-frame">
    function create_default_slot$D(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$haspage*/ ctx[1] && create_if_block$v(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$haspage*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$haspage*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$v(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$D.name,
    		type: "slot",
    		source: "(39:0) <FB vert c=\\\"title-frame\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1a(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				c: "title-frame",
    				$$slots: { default: [create_default_slot$D] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, permac, $page, data, vpermac, $haspage*/ 32799) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	let data;
    	let $pageinfo;
    	let $page;
    	let $haspage;
    	let $gs;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Titleframe', slots, []);
    	const gs = getContext('gs');
    	validate_store(gs, 'gs');
    	component_subscribe($$self, gs, value => $$invalidate(12, $gs = value));
    	const page = getContext('page');
    	validate_store(page, 'page');
    	component_subscribe($$self, page, value => $$invalidate(0, $page = value));
    	const haspage = getContext('haspage');
    	validate_store(haspage, 'haspage');
    	component_subscribe($$self, haspage, value => $$invalidate(1, $haspage = value));
    	const pageinfo = getContext('pageinfo');
    	validate_store(pageinfo, 'pageinfo');
    	component_subscribe($$self, pageinfo, value => $$invalidate(11, $pageinfo = value));
    	const crop = u => u.match(/.*?\/\/(.*)/)[1];
    	let perma, vperma, permac, vpermac;

    	const fmtdate = s => {
    		const d = new Date(s);
    		return date$1.format(d, 'MM-DD-YYYY');
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Titleframe> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		FB,
    		QR,
    		ContentControls,
    		Tabulate,
    		date: date$1,
    		getContext,
    		gs,
    		page,
    		haspage,
    		pageinfo,
    		crop,
    		perma,
    		vperma,
    		permac,
    		vpermac,
    		fmtdate,
    		data,
    		$pageinfo,
    		$page,
    		$haspage,
    		$gs
    	});

    	$$self.$inject_state = $$props => {
    		if ('perma' in $$props) $$invalidate(9, perma = $$props.perma);
    		if ('vperma' in $$props) $$invalidate(10, vperma = $$props.vperma);
    		if ('permac' in $$props) $$invalidate(2, permac = $$props.permac);
    		if ('vpermac' in $$props) $$invalidate(3, vpermac = $$props.vpermac);
    		if ('data' in $$props) $$invalidate(4, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$haspage, $gs, $page, perma, vperma*/ 5635) {
    			if ($haspage) {
    				$$invalidate(9, perma = $gs.full($page.val.pageUuid));
    				$$invalidate(10, vperma = $gs.full($page.val.uuid));
    				$$invalidate(2, permac = crop(perma));
    				$$invalidate(3, vpermac = crop(vperma));
    			}
    		}

    		if ($$self.$$.dirty & /*$haspage, $page, $pageinfo*/ 2051) {
    			$$invalidate(4, data = $haspage
    			? {
    					author: $page.val.user.handle,
    					version: $page.val.vnum,
    					creator: $page.val.page.user.handle,
    					words: $pageinfo.wc,
    					time: $pageinfo.time,
    					views: $page.val.views,
    					created: fmtdate($page.val.page.createdAt),
    					edited: fmtdate($page.val.createdAt),
    					links: $pageinfo.links
    				}
    			: {});
    		}
    	};

    	return [
    		$page,
    		$haspage,
    		permac,
    		vpermac,
    		data,
    		gs,
    		page,
    		haspage,
    		pageinfo,
    		perma,
    		vperma,
    		$pageinfo,
    		$gs
    	];
    }

    class Titleframe extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Titleframe",
    			options,
    			id: create_fragment$1a.name
    		});
    	}
    }

    /* src/util/Generic.svelte generated by Svelte v3.44.3 */

    const { console: console_1$5 } = globals;

    // (14:0) {#if cmp}
    function create_if_block$u(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*cmp*/ ctx[0];

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*cmp*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(14:0) {#if cmp}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$19(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*cmp*/ ctx[0] && create_if_block$u(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*cmp*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*cmp*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$u(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$19.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$19($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Generic', slots, []);
    	const finishload = getContext('finishload');
    	let { cmp } = $$props;

    	afterUpdate(() => {
    		if (cmp) {
    			console.log('baz!!!');
    			console.log(cmp);
    			finishload();
    		}
    	});

    	const writable_props = ['cmp'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$5.warn(`<Generic> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('cmp' in $$props) $$invalidate(0, cmp = $$props.cmp);
    	};

    	$$self.$capture_state = () => ({ afterUpdate, getContext, finishload, cmp });

    	$$self.$inject_state = $$props => {
    		if ('cmp' in $$props) $$invalidate(0, cmp = $$props.cmp);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [cmp];
    }

    class Generic extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$19, create_fragment$19, safe_not_equal, { cmp: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Generic",
    			options,
    			id: create_fragment$19.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*cmp*/ ctx[0] === undefined && !('cmp' in props)) {
    			console_1$5.warn("<Generic> was created without expected prop 'cmp'");
    		}
    	}

    	get cmp() {
    		throw new Error("<Generic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cmp(value) {
    		throw new Error("<Generic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Bodyframe.svelte generated by Svelte v3.44.3 */

    // (26:2) {#if !$state.loading}
    function create_if_block$t(ctx) {
    	let generic;
    	let current;

    	generic = new Generic({
    			props: { cmp: /*$component*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(generic.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(generic, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const generic_changes = {};
    			if (dirty & /*$component*/ 4) generic_changes.cmp = /*$component*/ ctx[2];
    			generic.$set(generic_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(generic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(generic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(generic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(26:2) {#if !$state.loading}",
    		ctx
    	});

    	return block;
    }

    // (25:0) <FB vert expand {c}>
    function create_default_slot$C(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = !/*$state*/ ctx[1].loading && create_if_block$t(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*$state*/ ctx[1].loading) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$state*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$t(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$C.name,
    		type: "slot",
    		source: "(25:0) <FB vert expand {c}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$18(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				expand: true,
    				c: /*c*/ ctx[0],
    				$$slots: { default: [create_default_slot$C] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*c*/ 1) fb_changes.c = /*c*/ ctx[0];

    			if (dirty & /*$$scope, $component, $state*/ 2054) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$18.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$18($$self, $$props, $$invalidate) {
    	let $loc;
    	let $rc;
    	let $state;
    	let $component;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Bodyframe', slots, []);
    	const rc = getContext('rc');
    	validate_store(rc, 'rc');
    	component_subscribe($$self, rc, value => $$invalidate(8, $rc = value));
    	const loc = getContext('loc');
    	validate_store(loc, 'loc');
    	component_subscribe($$self, loc, value => $$invalidate(7, $loc = value));
    	const haslogin = getContext('haslogin');
    	const state = getContext('state');
    	validate_store(state, 'state');
    	component_subscribe($$self, state, value => $$invalidate(1, $state = value));
    	const component = getContext('component');
    	validate_store(component, 'component');
    	component_subscribe($$self, component, value => $$invalidate(2, $component = value));
    	let c = [];

    	const classify = () => {
    		$$invalidate(0, c = []);

    		if ($loc.namespace == $rc.syskey) {
    			c.push('special-page');
    			c.push(`${$loc.title}-special`);
    		} else {
    			c.push('content-page');
    			c.push(`namespace-${$loc.namespace}`);
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Bodyframe> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Generic,
    		FB,
    		getContext,
    		rc,
    		loc,
    		haslogin,
    		state,
    		component,
    		c,
    		classify,
    		$loc,
    		$rc,
    		$state,
    		$component
    	});

    	$$self.$inject_state = $$props => {
    		if ('c' in $$props) $$invalidate(0, c = $$props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$loc*/ 128) {
    			classify();
    		}
    	};

    	return [c, $state, $component, rc, loc, state, component, $loc];
    }

    class Bodyframe extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$18, create_fragment$18, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Bodyframe",
    			options,
    			id: create_fragment$18.name
    		});
    	}
    }

    /* src/Balance.svelte generated by Svelte v3.44.3 */
    const file$H = "src/Balance.svelte";

    // (28:2) {#if a}
    function create_if_block_1$g(ctx) {
    	let pipe;
    	let current;

    	pipe = new Pipe({
    			props: { expand: true, vert: /*vert*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pipe.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pipe, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pipe_changes = {};
    			if (dirty & /*vert*/ 2) pipe_changes.vert = /*vert*/ ctx[1];
    			pipe.$set(pipe_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pipe.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pipe.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pipe, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(28:2) {#if a}",
    		ctx
    	});

    	return block;
    }

    // (30:2) {#if b}
    function create_if_block$s(ctx) {
    	let pipe;
    	let current;

    	pipe = new Pipe({
    			props: { expand: true, vert: /*vert*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pipe.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pipe, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pipe_changes = {};
    			if (dirty & /*vert*/ 2) pipe_changes.vert = /*vert*/ ctx[1];
    			pipe.$set(pipe_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pipe.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pipe.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pipe, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(30:2) {#if b}",
    		ctx
    	});

    	return block;
    }

    // (27:0) <FB {expand} {vert} zero>
    function create_default_slot$B(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*a*/ ctx[2] && create_if_block_1$g(ctx);
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
    	let if_block1 = /*b*/ ctx[3] && create_if_block$s(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (default_slot) default_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty$1();
    			attr_dev(div, "class", /*c*/ ctx[4]);
    			add_location(div, file$H, 28, 2, 568);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			insert_dev(target, t1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*a*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*a*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$g(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*c*/ 16) {
    				attr_dev(div, "class", /*c*/ ctx[4]);
    			}

    			if (/*b*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*b*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$s(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(default_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(default_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$B.name,
    		type: "slot",
    		source: "(27:0) <FB {expand} {vert} zero>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$17(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				expand: /*expand*/ ctx[0],
    				vert: /*vert*/ ctx[1],
    				zero: true,
    				$$slots: { default: [create_default_slot$B] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*expand*/ 1) fb_changes.expand = /*expand*/ ctx[0];
    			if (dirty & /*vert*/ 2) fb_changes.vert = /*vert*/ ctx[1];

    			if (dirty & /*$$scope, vert, b, c, a*/ 542) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$17.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$17($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Balance', slots, ['default']);
    	let { left = false } = $$props;
    	let { right = false } = $$props;
    	let { center = false } = $$props;
    	let { expand = false } = $$props;
    	let { vert = false } = $$props;
    	let a = false;
    	let b = false;
    	let c = '';
    	const writable_props = ['left', 'right', 'center', 'expand', 'vert'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Balance> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('left' in $$props) $$invalidate(6, left = $$props.left);
    		if ('right' in $$props) $$invalidate(7, right = $$props.right);
    		if ('center' in $$props) $$invalidate(5, center = $$props.center);
    		if ('expand' in $$props) $$invalidate(0, expand = $$props.expand);
    		if ('vert' in $$props) $$invalidate(1, vert = $$props.vert);
    		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		Pipe,
    		left,
    		right,
    		center,
    		expand,
    		vert,
    		a,
    		b,
    		c
    	});

    	$$self.$inject_state = $$props => {
    		if ('left' in $$props) $$invalidate(6, left = $$props.left);
    		if ('right' in $$props) $$invalidate(7, right = $$props.right);
    		if ('center' in $$props) $$invalidate(5, center = $$props.center);
    		if ('expand' in $$props) $$invalidate(0, expand = $$props.expand);
    		if ('vert' in $$props) $$invalidate(1, vert = $$props.vert);
    		if ('a' in $$props) $$invalidate(2, a = $$props.a);
    		if ('b' in $$props) $$invalidate(3, b = $$props.b);
    		if ('c' in $$props) $$invalidate(4, c = $$props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*left, right, center*/ 224) {
    			if (!left && !right && !center) $$invalidate(5, center = true);
    		}

    		if ($$self.$$.dirty & /*left, right, center, a, c, b*/ 252) {
    			{
    				$$invalidate(4, c = []);

    				if (left) $$invalidate(3, b = true); else if (right) $$invalidate(2, a = true); else if (center) {
    					$$invalidate(2, a = true);
    					$$invalidate(3, b = true);
    				}

    				if (a) c.push('balance-left');
    				if (b) c.push('balance-right');
    				$$invalidate(4, c = c.join(' '));
    			}
    		}
    	};

    	return [expand, vert, a, b, c, center, left, right, slots, $$scope];
    }

    class Balance extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$17, create_fragment$17, safe_not_equal, {
    			left: 6,
    			right: 7,
    			center: 5,
    			expand: 0,
    			vert: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Balance",
    			options,
    			id: create_fragment$17.name
    		});
    	}

    	get left() {
    		throw new Error("<Balance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set left(value) {
    		throw new Error("<Balance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get right() {
    		throw new Error("<Balance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set right(value) {
    		throw new Error("<Balance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get center() {
    		throw new Error("<Balance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set center(value) {
    		throw new Error("<Balance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expand() {
    		throw new Error("<Balance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expand(value) {
    		throw new Error("<Balance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vert() {
    		throw new Error("<Balance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vert(value) {
    		throw new Error("<Balance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/MaybeUUID.svelte generated by Svelte v3.44.3 */

    // (13:0) {:else}
    function create_else_block$f(ctx) {
    	let balance;
    	let current;

    	balance = new Balance({
    			props: {
    				left: /*left*/ ctx[0],
    				right: /*right*/ ctx[1],
    				$$slots: { default: [create_default_slot$A] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(balance.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(balance, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const balance_changes = {};
    			if (dirty & /*left*/ 1) balance_changes.left = /*left*/ ctx[0];
    			if (dirty & /*right*/ 2) balance_changes.right = /*right*/ ctx[1];

    			if (dirty & /*$$scope, uuid*/ 20) {
    				balance_changes.$$scope = { dirty, ctx };
    			}

    			balance.$set(balance_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(balance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(balance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(balance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$f.name,
    		type: "else",
    		source: "(13:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (11:0) {#if valid}
    function create_if_block$r(ctx) {
    	let uuid_1;
    	let current;

    	uuid_1 = new UUID({
    			props: { link: /*uuid*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(uuid_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(uuid_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const uuid_1_changes = {};
    			if (dirty & /*uuid*/ 4) uuid_1_changes.link = /*uuid*/ ctx[2];
    			uuid_1.$set(uuid_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(uuid_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(uuid_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(uuid_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(11:0) {#if valid}",
    		ctx
    	});

    	return block;
    }

    // (14:26) <UUID>
    function create_default_slot_1$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*uuid*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*uuid*/ 4) set_data_dev(t, /*uuid*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$p.name,
    		type: "slot",
    		source: "(14:26) <UUID>",
    		ctx
    	});

    	return block;
    }

    // (14:2) <Balance {left} {right}>
    function create_default_slot$A(ctx) {
    	let uuid_1;
    	let current;

    	uuid_1 = new UUID({
    			props: {
    				$$slots: { default: [create_default_slot_1$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(uuid_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(uuid_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const uuid_1_changes = {};

    			if (dirty & /*$$scope, uuid*/ 20) {
    				uuid_1_changes.$$scope = { dirty, ctx };
    			}

    			uuid_1.$set(uuid_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(uuid_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(uuid_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(uuid_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$A.name,
    		type: "slot",
    		source: "(14:2) <Balance {left} {right}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$16(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$r, create_else_block$f];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*valid*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$16($$self, $$props, $$invalidate) {
    	let valid;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MaybeUUID', slots, []);
    	let { left = false } = $$props;
    	let { right = false } = $$props;
    	let { uuid } = $$props;
    	const writable_props = ['left', 'right', 'uuid'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MaybeUUID> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('left' in $$props) $$invalidate(0, left = $$props.left);
    		if ('right' in $$props) $$invalidate(1, right = $$props.right);
    		if ('uuid' in $$props) $$invalidate(2, uuid = $$props.uuid);
    	};

    	$$self.$capture_state = () => ({
    		UUID,
    		Balance,
    		isuu: util.isuu,
    		left,
    		right,
    		uuid,
    		valid
    	});

    	$$self.$inject_state = $$props => {
    		if ('left' in $$props) $$invalidate(0, left = $$props.left);
    		if ('right' in $$props) $$invalidate(1, right = $$props.right);
    		if ('uuid' in $$props) $$invalidate(2, uuid = $$props.uuid);
    		if ('valid' in $$props) $$invalidate(3, valid = $$props.valid);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*uuid*/ 4) {
    			$$invalidate(3, valid = util.isuu(uuid));
    		}
    	};

    	return [left, right, uuid, valid];
    }

    class MaybeUUID extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$16, safe_not_equal, { left: 0, right: 1, uuid: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MaybeUUID",
    			options,
    			id: create_fragment$16.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*uuid*/ ctx[2] === undefined && !('uuid' in props)) {
    			console.warn("<MaybeUUID> was created without expected prop 'uuid'");
    		}
    	}

    	get left() {
    		throw new Error("<MaybeUUID>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set left(value) {
    		throw new Error("<MaybeUUID>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get right() {
    		throw new Error("<MaybeUUID>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set right(value) {
    		throw new Error("<MaybeUUID>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get uuid() {
    		throw new Error("<MaybeUUID>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set uuid(value) {
    		throw new Error("<MaybeUUID>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Footer.svelte generated by Svelte v3.44.3 */
    const file$G = "src/Footer.svelte";

    // (20:2) {:else}
    function create_else_block$e(ctx) {
    	let pipe;
    	let current;
    	pipe = new Pipe({ props: { expand: true }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(pipe.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pipe, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pipe.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pipe.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pipe, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$e.name,
    		type: "else",
    		source: "(20:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (17:2) {#if $state.content}
    function create_if_block_3$6(ctx) {
    	let maybeuuid0;
    	let t;
    	let maybeuuid1;
    	let current;

    	maybeuuid0 = new MaybeUUID({
    			props: {
    				right: true,
    				uuid: /*$page*/ ctx[1].val.pageUuid
    			},
    			$$inline: true
    		});

    	maybeuuid1 = new MaybeUUID({
    			props: {
    				right: true,
    				uuid: /*$page*/ ctx[1].val.prevUuid
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(maybeuuid0.$$.fragment);
    			t = space();
    			create_component(maybeuuid1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(maybeuuid0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(maybeuuid1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const maybeuuid0_changes = {};
    			if (dirty & /*$page*/ 2) maybeuuid0_changes.uuid = /*$page*/ ctx[1].val.pageUuid;
    			maybeuuid0.$set(maybeuuid0_changes);
    			const maybeuuid1_changes = {};
    			if (dirty & /*$page*/ 2) maybeuuid1_changes.uuid = /*$page*/ ctx[1].val.prevUuid;
    			maybeuuid1.$set(maybeuuid1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(maybeuuid0.$$.fragment, local);
    			transition_in(maybeuuid1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(maybeuuid0.$$.fragment, local);
    			transition_out(maybeuuid1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(maybeuuid0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(maybeuuid1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(17:2) {#if $state.content}",
    		ctx
    	});

    	return block;
    }

    // (16:2) <FB vert>
    function create_default_slot_5$b(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_3$6, create_else_block$e];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$state*/ ctx[0].content) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$b.name,
    		type: "slot",
    		source: "(16:2) <FB vert>",
    		ctx
    	});

    	return block;
    }

    // (24:2) <FB expand vert center>
    function create_default_slot_4$b(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "❤";
    			attr_dev(div, "class", "heartmark");
    			add_location(div, file$G, 24, 4, 659);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$b.name,
    		type: "slot",
    		source: "(24:2) <FB expand vert center>",
    		ctx
    	});

    	return block;
    }

    // (32:27) 
    function create_if_block_2$8(ctx) {
    	let maybeuuid0;
    	let t;
    	let maybeuuid1;
    	let current;

    	maybeuuid0 = new MaybeUUID({
    			props: {
    				left: true,
    				uuid: /*$page*/ ctx[1].val.uuid
    			},
    			$$inline: true
    		});

    	maybeuuid1 = new MaybeUUID({
    			props: {
    				left: true,
    				uuid: /*$page*/ ctx[1].val.nextUuid
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(maybeuuid0.$$.fragment);
    			t = space();
    			create_component(maybeuuid1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(maybeuuid0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(maybeuuid1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const maybeuuid0_changes = {};
    			if (dirty & /*$page*/ 2) maybeuuid0_changes.uuid = /*$page*/ ctx[1].val.uuid;
    			maybeuuid0.$set(maybeuuid0_changes);
    			const maybeuuid1_changes = {};
    			if (dirty & /*$page*/ 2) maybeuuid1_changes.uuid = /*$page*/ ctx[1].val.nextUuid;
    			maybeuuid1.$set(maybeuuid1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(maybeuuid0.$$.fragment, local);
    			transition_in(maybeuuid1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(maybeuuid0.$$.fragment, local);
    			transition_out(maybeuuid1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(maybeuuid0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(maybeuuid1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(32:27) ",
    		ctx
    	});

    	return block;
    }

    // (30:27) 
    function create_if_block_1$f(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				self: true,
    				global: true,
    				first: /*postdraft*/ ctx[3],
    				opt: { edit: undefined },
    				$$slots: { default: [create_default_slot_3$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(30:27) ",
    		ctx
    	});

    	return block;
    }

    // (28:2) {#if $state.creating}
    function create_if_block$q(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				self: true,
    				global: true,
    				first: /*postdraft*/ ctx[3],
    				$$slots: { default: [create_default_slot_2$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(28:2) {#if $state.creating}",
    		ctx
    	});

    	return block;
    }

    // (31:3) <Link self global first={postdraft} opt={{edit: undefined}}>
    function create_default_slot_3$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("SAVE");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$f.name,
    		type: "slot",
    		source: "(31:3) <Link self global first={postdraft} opt={{edit: undefined}}>",
    		ctx
    	});

    	return block;
    }

    // (29:3) <Link self global first={postdraft}>
    function create_default_slot_2$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("CREATE");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$k.name,
    		type: "slot",
    		source: "(29:3) <Link self global first={postdraft}>",
    		ctx
    	});

    	return block;
    }

    // (27:2) <FB vert>
    function create_default_slot_1$o(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$q, create_if_block_1$f, create_if_block_2$8];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$state*/ ctx[0].creating) return 0;
    		if (/*$state*/ ctx[0].editing) return 1;
    		if (/*$state*/ ctx[0].content) return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_1(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$o.name,
    		type: "slot",
    		source: "(27:2) <FB vert>",
    		ctx
    	});

    	return block;
    }

    // (15:0) <FB c="footer">
    function create_default_slot$z(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let fb2;
    	let current;

    	fb0 = new FB({
    			props: {
    				vert: true,
    				$$slots: { default: [create_default_slot_5$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				expand: true,
    				vert: true,
    				center: true,
    				$$slots: { default: [create_default_slot_4$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb2 = new FB({
    			props: {
    				vert: true,
    				$$slots: { default: [create_default_slot_1$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    			create_component(fb2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope, $page, $state*/ 259) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    			const fb2_changes = {};

    			if (dirty & /*$$scope, $state, $page*/ 259) {
    				fb2_changes.$$scope = { dirty, ctx };
    			}

    			fb2.$set(fb2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(fb2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(fb2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$z.name,
    		type: "slot",
    		source: "(15:0) <FB c=\\\"footer\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$15(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: "footer",
    				$$slots: { default: [create_default_slot$z] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, $state, $page*/ 259) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$15($$self, $$props, $$invalidate) {
    	let $state;
    	let $page;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Footer', slots, []);
    	const page = getContext('page');
    	validate_store(page, 'page');
    	component_subscribe($$self, page, value => $$invalidate(1, $page = value));
    	const haspage = getContext('haspage');
    	const editing = getContext('editing');
    	const creating = getContext('creating');
    	const postdraft = getContext('postdraft');
    	const state = getContext('state');
    	validate_store(state, 'state');
    	component_subscribe($$self, state, value => $$invalidate(0, $state = value));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Footer> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		FB,
    		Link: Link$1,
    		Pipe,
    		MaybeUUID,
    		getContext,
    		page,
    		haspage,
    		editing,
    		creating,
    		postdraft,
    		state,
    		$state,
    		$page
    	});

    	return [$state, $page, page, postdraft, state];
    }

    class Footer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$15, create_fragment$15, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Footer",
    			options,
    			id: create_fragment$15.name
    		});
    	}
    }

    /* src/wideui/WUIModule.svelte generated by Svelte v3.44.3 */
    const get_body_slot_changes$1 = dirty => ({});
    const get_body_slot_context$1 = ctx => ({});
    const get_controls_slot_changes = dirty => ({});
    const get_controls_slot_context = ctx => ({});
    const get_title_slot_changes$1 = dirty => ({});
    const get_title_slot_context$1 = ctx => ({});

    // (17:4) {#if $$slots.title}
    function create_if_block_2$7(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				title: true,
    				line: "n",
    				fw: 7,
    				c: "wui-title",
    				$$slots: { default: [create_default_slot_3$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(17:4) {#if $$slots.title}",
    		ctx
    	});

    	return block;
    }

    // (18:6) <FB title line="n" fw={7} c="wui-title">
    function create_default_slot_3$e(ctx) {
    	let current;
    	const title_slot_template = /*#slots*/ ctx[3].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[4], get_title_slot_context$1);

    	const block = {
    		c: function create() {
    			if (title_slot) title_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (title_slot) {
    				title_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (title_slot) {
    				if (title_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[4], dirty, get_title_slot_changes$1),
    						get_title_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$e.name,
    		type: "slot",
    		source: "(18:6) <FB title line=\\\"n\\\" fw={7} c=\\\"wui-title\\\">",
    		ctx
    	});

    	return block;
    }

    // (23:4) {#if $$slots.controls}
    function create_if_block_1$e(ctx) {
    	let current;
    	const controls_slot_template = /*#slots*/ ctx[3].controls;
    	const controls_slot = create_slot(controls_slot_template, ctx, /*$$scope*/ ctx[4], get_controls_slot_context);

    	const block = {
    		c: function create() {
    			if (controls_slot) controls_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (controls_slot) {
    				controls_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (controls_slot) {
    				if (controls_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						controls_slot,
    						controls_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(controls_slot_template, /*$$scope*/ ctx[4], dirty, get_controls_slot_changes),
    						get_controls_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(controls_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(controls_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (controls_slot) controls_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(23:4) {#if $$slots.controls}",
    		ctx
    	});

    	return block;
    }

    // (16:2) <FB c="wui-head">
    function create_default_slot_2$j(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*$$slots*/ ctx[1].title && create_if_block_2$7(ctx);
    	let if_block1 = /*$$slots*/ ctx[1].controls && create_if_block_1$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$$slots*/ ctx[1].title) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$$slots*/ ctx[1].controls) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$e(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$j.name,
    		type: "slot",
    		source: "(16:2) <FB c=\\\"wui-head\\\">",
    		ctx
    	});

    	return block;
    }

    // (28:2) {#if $$slots.body}
    function create_if_block$p(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				c: "wui-body",
    				$$slots: { default: [create_default_slot_1$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(28:2) {#if $$slots.body}",
    		ctx
    	});

    	return block;
    }

    // (29:4) <FB vert c="wui-body">
    function create_default_slot_1$n(ctx) {
    	let current;
    	const body_slot_template = /*#slots*/ ctx[3].body;
    	const body_slot = create_slot(body_slot_template, ctx, /*$$scope*/ ctx[4], get_body_slot_context$1);

    	const block = {
    		c: function create() {
    			if (body_slot) body_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (body_slot) {
    				body_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (body_slot) {
    				if (body_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						body_slot,
    						body_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(body_slot_template, /*$$scope*/ ctx[4], dirty, get_body_slot_changes$1),
    						get_body_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(body_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(body_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (body_slot) body_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$n.name,
    		type: "slot",
    		source: "(29:4) <FB vert c=\\\"wui-body\\\">",
    		ctx
    	});

    	return block;
    }

    // (14:0) <FB vert c={ic}>
    function create_default_slot$y(ctx) {
    	let fb;
    	let t;
    	let if_block_anchor;
    	let current;

    	fb = new FB({
    			props: {
    				c: "wui-head",
    				$$slots: { default: [create_default_slot_2$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$$slots*/ ctx[1].body && create_if_block$p(ctx);

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, $$slots*/ 18) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);

    			if (/*$$slots*/ ctx[1].body) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$p(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$y.name,
    		type: "slot",
    		source: "(14:0) <FB vert c={ic}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$14(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				c: /*ic*/ ctx[0],
    				$$slots: { default: [create_default_slot$y] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*ic*/ 1) fb_changes.c = /*ic*/ ctx[0];

    			if (dirty & /*$$scope, $$slots*/ 18) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$14($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('WUIModule', slots, ['title','controls','body']);
    	const $$slots = compute_slots(slots);
    	let { c = [] } = $$props;
    	let ic = [];

    	const mkc = () => {
    		$$invalidate(0, ic = ['wui-module', ...c]);
    	};

    	const writable_props = ['c'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<WUIModule> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('c' in $$props) $$invalidate(2, c = $$props.c);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ FB, c, ic, mkc });

    	$$self.$inject_state = $$props => {
    		if ('c' in $$props) $$invalidate(2, c = $$props.c);
    		if ('ic' in $$props) $$invalidate(0, ic = $$props.ic);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*c*/ 4) {
    			mkc();
    		}
    	};

    	return [ic, $$slots, c, slots, $$scope];
    }

    class WUIModule extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$14, create_fragment$14, safe_not_equal, { c: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WUIModule",
    			options,
    			id: create_fragment$14.name
    		});
    	}

    	get c() {
    		throw new Error("<WUIModule>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set c(value) {
    		throw new Error("<WUIModule>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/wideui/WUIButton.svelte generated by Svelte v3.44.3 */

    // (5:0) <FB vc line="s3" fw={5}>
    function create_default_slot$x(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[0].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$x.name,
    		type: "slot",
    		source: "(5:0) <FB vc line=\\\"s3\\\" fw={5}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$13(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vc: true,
    				line: "s3",
    				fw: 5,
    				$$slots: { default: [create_default_slot$x] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$13($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('WUIButton', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<WUIButton> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ FB });
    	return [slots, $$scope];
    }

    class WUIButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$13, create_fragment$13, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WUIButton",
    			options,
    			id: create_fragment$13.name
    		});
    	}
    }

    /* src/util/List.svelte generated by Svelte v3.44.3 */

    const file$F = "src/util/List.svelte";

    // (21:0) {:else}
    function create_else_block$d(ctx) {
    	let ul;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			attr_dev(ul, "class", /*cls*/ ctx[1]);
    			add_location(ul, file$F, 21, 2, 347);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cls*/ 2) {
    				attr_dev(ul, "class", /*cls*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$d.name,
    		type: "else",
    		source: "(21:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (17:0) {#if ordered}
    function create_if_block$o(ctx) {
    	let ol;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			ol = element("ol");
    			if (default_slot) default_slot.c();
    			attr_dev(ol, "class", /*cls*/ ctx[1]);
    			add_location(ol, file$F, 17, 2, 294);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ol, anchor);

    			if (default_slot) {
    				default_slot.m(ol, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cls*/ 2) {
    				attr_dev(ol, "class", /*cls*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ol);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(17:0) {#if ordered}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$12(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$o, create_else_block$d];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*ordered*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('List', slots, ['default']);
    	let { root = false } = $$props;
    	let { ordered = true } = $$props;
    	let { depth = 1 } = $$props;
    	let { c = [] } = $$props;
    	let cls = '';

    	const mkcls = () => {
    		const c2 = [`list-d${depth}`, ...c];
    		if (root) c2.push(root);
    		$$invalidate(1, cls = c2.join(' '));
    	};

    	const writable_props = ['root', 'ordered', 'depth', 'c'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<List> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('root' in $$props) $$invalidate(2, root = $$props.root);
    		if ('ordered' in $$props) $$invalidate(0, ordered = $$props.ordered);
    		if ('depth' in $$props) $$invalidate(3, depth = $$props.depth);
    		if ('c' in $$props) $$invalidate(4, c = $$props.c);
    		if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ root, ordered, depth, c, cls, mkcls });

    	$$self.$inject_state = $$props => {
    		if ('root' in $$props) $$invalidate(2, root = $$props.root);
    		if ('ordered' in $$props) $$invalidate(0, ordered = $$props.ordered);
    		if ('depth' in $$props) $$invalidate(3, depth = $$props.depth);
    		if ('c' in $$props) $$invalidate(4, c = $$props.c);
    		if ('cls' in $$props) $$invalidate(1, cls = $$props.cls);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*root, depth, c*/ 28) {
    			mkcls();
    		}
    	};

    	return [ordered, cls, root, depth, c, $$scope, slots];
    }

    class List$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$12, create_fragment$12, safe_not_equal, { root: 2, ordered: 0, depth: 3, c: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List",
    			options,
    			id: create_fragment$12.name
    		});
    	}

    	get root() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set root(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ordered() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ordered(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get depth() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set depth(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get c() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set c(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    /* src/util/Treelike.svelte generated by Svelte v3.44.3 */
    const file$E = "src/util/Treelike.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    const get_default_slot_changes_2 = dirty => ({ item: dirty & /*items*/ 1 });
    const get_default_slot_context_2 = ctx => ({ item: /*item*/ ctx[9] });
    const get_default_slot_changes_1 = dirty => ({ item: dirty & /*i*/ 4096 });
    const get_default_slot_context_1 = ctx => ({ item: /*i*/ ctx[12] });
    const get_default_slot_changes$1 = dirty => ({ item: dirty & /*items*/ 1 });
    const get_default_slot_context$1 = ctx => ({ item: /*item*/ ctx[9][0] });

    // (28:0) {#if !$treecut || depth <= $treecut}
    function create_if_block$n(ctx) {
    	let list;
    	let current;

    	list = new List$1({
    			props: {
    				ordered: /*ordered*/ ctx[1],
    				root: /*root*/ ctx[2],
    				depth: /*depth*/ ctx[3],
    				$$slots: { default: [create_default_slot$w] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(list.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(list, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const list_changes = {};
    			if (dirty & /*ordered*/ 2) list_changes.ordered = /*ordered*/ ctx[1];
    			if (dirty & /*root*/ 4) list_changes.root = /*root*/ ctx[2];
    			if (dirty & /*depth*/ 8) list_changes.depth = /*depth*/ ctx[3];

    			if (dirty & /*$$scope, items*/ 257) {
    				list_changes.$$scope = { dirty, ctx };
    			}

    			list.$set(list_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(list.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(list.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(list, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(28:0) {#if !$treecut || depth <= $treecut}",
    		ctx
    	});

    	return block;
    }

    // (37:6) {:else}
    function create_else_block$c(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context_2);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, items*/ 257)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, get_default_slot_changes_2),
    						get_default_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(37:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (32:6) {#if Array.isArray(item) && typeof(item[1]) != 'number'}
    function create_if_block_1$d(ctx) {
    	let t;
    	let treelike;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context$1);

    	treelike = new Treelike({
    			props: {
    				items: /*item*/ ctx[9].slice(1),
    				$$slots: {
    					default: [
    						create_default_slot_1$m,
    						({ item: i }) => ({ 12: i }),
    						({ item: i }) => i ? 4096 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    			t = space();
    			create_component(treelike.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			mount_component(treelike, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, items*/ 257)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, get_default_slot_changes$1),
    						get_default_slot_context$1
    					);
    				}
    			}

    			const treelike_changes = {};
    			if (dirty & /*items*/ 1) treelike_changes.items = /*item*/ ctx[9].slice(1);

    			if (dirty & /*$$scope, i*/ 4352) {
    				treelike_changes.$$scope = { dirty, ctx };
    			}

    			treelike.$set(treelike_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(treelike.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(treelike.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(treelike, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(32:6) {#if Array.isArray(item) && typeof(item[1]) != 'number'}",
    		ctx
    	});

    	return block;
    }

    // (34:8) <svelte:self items={item.slice(1)} let:item={i}>
    function create_default_slot_1$m(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context_1);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, i*/ 4352)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, get_default_slot_changes_1),
    						get_default_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$m.name,
    		type: "slot",
    		source: "(34:8) <svelte:self items={item.slice(1)} let:item={i}>",
    		ctx
    	});

    	return block;
    }

    // (30:2) {#each items as item}
    function create_each_block$a(ctx) {
    	let li;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let current;
    	const if_block_creators = [create_if_block_1$d, create_else_block$c];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (show_if == null || dirty & /*items*/ 1) show_if = !!(Array.isArray(/*item*/ ctx[9]) && typeof /*item*/ ctx[9][1] != 'number');
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			li = element("li");
    			if_block.c();
    			t = space();
    			add_location(li, file$E, 30, 4, 764);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			if_blocks[current_block_type_index].m(li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(li, t);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(30:2) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    // (29:0) <List {ordered} {root} {depth}>
    function create_default_slot$w(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*items*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items, $$scope, i, Array*/ 4353) {
    				each_value = /*items*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$w.name,
    		type: "slot",
    		source: "(29:0) <List {ordered} {root} {depth}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$11(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = (!/*$treecut*/ ctx[5] || /*depth*/ ctx[3] <= /*$treecut*/ ctx[5]) && create_if_block$n(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*$treecut*/ ctx[5] || /*depth*/ ctx[3] <= /*$treecut*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$treecut, depth*/ 40) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$n(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	let $treecut,
    		$$unsubscribe_treecut = noop,
    		$$subscribe_treecut = () => ($$unsubscribe_treecut(), $$unsubscribe_treecut = subscribe(treecut, $$value => $$invalidate(5, $treecut = $$value)), treecut);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_treecut());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Treelike', slots, ['default']);
    	let { items = [] } = $$props;
    	let { ordered = true } = $$props;
    	let { cutoff = null } = $$props;
    	let root = false;
    	let depth = 1;
    	let treecut;

    	if (!hasContext('treelikeroot')) {
    		root = 'treelike';
    		$$subscribe_treecut(treecut = writable(null));
    		setContext('treecut', treecut);
    		setContext('treelikeroot', true);
    		setContext('treedepth', 1);
    	} else {
    		$$subscribe_treecut(treecut = getContext('treecut'));
    		depth = getContext('treedepth') + 1;
    		setContext('treedepth', depth);
    	}

    	const writable_props = ['items', 'ordered', 'cutoff'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Treelike> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('items' in $$props) $$invalidate(0, items = $$props.items);
    		if ('ordered' in $$props) $$invalidate(1, ordered = $$props.ordered);
    		if ('cutoff' in $$props) $$invalidate(6, cutoff = $$props.cutoff);
    		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		List: List$1,
    		setContext,
    		hasContext,
    		getContext,
    		writable,
    		items,
    		ordered,
    		cutoff,
    		root,
    		depth,
    		treecut,
    		$treecut
    	});

    	$$self.$inject_state = $$props => {
    		if ('items' in $$props) $$invalidate(0, items = $$props.items);
    		if ('ordered' in $$props) $$invalidate(1, ordered = $$props.ordered);
    		if ('cutoff' in $$props) $$invalidate(6, cutoff = $$props.cutoff);
    		if ('root' in $$props) $$invalidate(2, root = $$props.root);
    		if ('depth' in $$props) $$invalidate(3, depth = $$props.depth);
    		if ('treecut' in $$props) $$subscribe_treecut($$invalidate(4, treecut = $$props.treecut));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*root, cutoff*/ 68) {
    			if (root) set_store_value(treecut, $treecut = cutoff && cutoff < 1 ? 1 : cutoff, $treecut);
    		}
    	};

    	return [items, ordered, root, depth, treecut, $treecut, cutoff, slots, $$scope];
    }

    class Treelike extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$11, create_fragment$11, safe_not_equal, { items: 0, ordered: 1, cutoff: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Treelike",
    			options,
    			id: create_fragment$11.name
    		});
    	}

    	get items() {
    		throw new Error("<Treelike>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Treelike>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ordered() {
    		throw new Error("<Treelike>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ordered(value) {
    		throw new Error("<Treelike>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cutoff() {
    		throw new Error("<Treelike>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cutoff(value) {
    		throw new Error("<Treelike>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * marked - a markdown parser
     * Copyright (c) 2011-2022, Christopher Jeffrey. (MIT Licensed)
     * https://github.com/markedjs/marked
     */

    /**
     * DO NOT EDIT THIS FILE
     * The code in this file is generated from files in ./src/
     */

    function getDefaults() {
      return {
        baseUrl: null,
        breaks: false,
        extensions: null,
        gfm: true,
        headerIds: true,
        headerPrefix: '',
        highlight: null,
        langPrefix: 'language-',
        mangle: true,
        pedantic: false,
        renderer: null,
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartLists: false,
        smartypants: false,
        tokenizer: null,
        walkTokens: null,
        xhtml: false
      };
    }

    let defaults = getDefaults();

    function changeDefaults(newDefaults) {
      defaults = newDefaults;
    }

    /**
     * Helpers
     */
    const escapeTest = /[&<>"']/;
    const escapeReplace = /[&<>"']/g;
    const escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
    const escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
    const escapeReplacements = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    const getEscapeReplacement = (ch) => escapeReplacements[ch];
    function escape(html, encode) {
      if (encode) {
        if (escapeTest.test(html)) {
          return html.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html)) {
          return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }

      return html;
    }

    const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

    function unescape$1(html) {
      // explicitly match decimal, hex, and named HTML entities
      return html.replace(unescapeTest, (_, n) => {
        n = n.toLowerCase();
        if (n === 'colon') return ':';
        if (n.charAt(0) === '#') {
          return n.charAt(1) === 'x'
            ? String.fromCharCode(parseInt(n.substring(2), 16))
            : String.fromCharCode(+n.substring(1));
        }
        return '';
      });
    }

    const caret$2 = /(^|[^\[])\^/g;
    function edit(regex, opt) {
      regex = regex.source || regex;
      opt = opt || '';
      const obj = {
        replace: (name, val) => {
          val = val.source || val;
          val = val.replace(caret$2, '$1');
          regex = regex.replace(name, val);
          return obj;
        },
        getRegex: () => {
          return new RegExp(regex, opt);
        }
      };
      return obj;
    }

    const nonWordAndColonTest = /[^\w:]/g;
    const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    function cleanUrl(sanitize, base, href) {
      if (sanitize) {
        let prot;
        try {
          prot = decodeURIComponent(unescape$1(href))
            .replace(nonWordAndColonTest, '')
            .toLowerCase();
        } catch (e) {
          return null;
        }
        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, '%');
      } catch (e) {
        return null;
      }
      return href;
    }

    const baseUrls = {};
    const justDomain = /^[^:]+:\/*[^/]*$/;
    const protocol = /^([^:]+:)[\s\S]*$/;
    const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

    function resolveUrl(base, href) {
      if (!baseUrls[' ' + base]) {
        // we can ignore everything in base after the last slash of its path component,
        // but we might need to add _that_
        // https://tools.ietf.org/html/rfc3986#section-3
        if (justDomain.test(base)) {
          baseUrls[' ' + base] = base + '/';
        } else {
          baseUrls[' ' + base] = rtrim(base, '/', true);
        }
      }
      base = baseUrls[' ' + base];
      const relativeBase = base.indexOf(':') === -1;

      if (href.substring(0, 2) === '//') {
        if (relativeBase) {
          return href;
        }
        return base.replace(protocol, '$1') + href;
      } else if (href.charAt(0) === '/') {
        if (relativeBase) {
          return href;
        }
        return base.replace(domain, '$1') + href;
      } else {
        return base + href;
      }
    }

    const noopTest = { exec: function noopTest() {} };

    function merge(obj) {
      let i = 1,
        target,
        key;

      for (; i < arguments.length; i++) {
        target = arguments[i];
        for (key in target) {
          if (Object.prototype.hasOwnProperty.call(target, key)) {
            obj[key] = target[key];
          }
        }
      }

      return obj;
    }

    function splitCells(tableRow, count) {
      // ensure that every cell-delimiting pipe has a space
      // before it to distinguish it from an escaped pipe
      const row = tableRow.replace(/\|/g, (match, offset, str) => {
          let escaped = false,
            curr = offset;
          while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
          if (escaped) {
            // odd number of slashes means | is escaped
            // so we leave it alone
            return '|';
          } else {
            // add space before unescaped |
            return ' |';
          }
        }),
        cells = row.split(/ \|/);
      let i = 0;

      // First/last cell in a row cannot be empty if it has no leading/trailing pipe
      if (!cells[0].trim()) { cells.shift(); }
      if (cells.length > 0 && !cells[cells.length - 1].trim()) { cells.pop(); }

      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count) cells.push('');
      }

      for (; i < cells.length; i++) {
        // leading or trailing whitespace is ignored per the gfm spec
        cells[i] = cells[i].trim().replace(/\\\|/g, '|');
      }
      return cells;
    }

    // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
    // /c*$/ is vulnerable to REDOS.
    // invert: Remove suffix of non-c chars instead. Default falsey.
    function rtrim(str, c, invert) {
      const l = str.length;
      if (l === 0) {
        return '';
      }

      // Length of suffix matching the invert condition.
      let suffLen = 0;

      // Step left until we fail to match the invert condition.
      while (suffLen < l) {
        const currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && !invert) {
          suffLen++;
        } else if (currChar !== c && invert) {
          suffLen++;
        } else {
          break;
        }
      }

      return str.substr(0, l - suffLen);
    }

    function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
        return -1;
      }
      const l = str.length;
      let level = 0,
        i = 0;
      for (; i < l; i++) {
        if (str[i] === '\\') {
          i++;
        } else if (str[i] === b[0]) {
          level++;
        } else if (str[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }

    function checkSanitizeDeprecation(opt) {
      if (opt && opt.sanitize && !opt.silent) {
        console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
      }
    }

    // copied from https://stackoverflow.com/a/5450113/806777
    function repeatString(pattern, count) {
      if (count < 1) {
        return '';
      }
      let result = '';
      while (count > 1) {
        if (count & 1) {
          result += pattern;
        }
        count >>= 1;
        pattern += pattern;
      }
      return result + pattern;
    }

    function outputLink(cap, link, raw, lexer) {
      const href = link.href;
      const title = link.title ? escape(link.title) : null;
      const text = cap[1].replace(/\\([\[\]])/g, '$1');

      if (cap[0].charAt(0) !== '!') {
        lexer.state.inLink = true;
        const token = {
          type: 'link',
          raw,
          href,
          title,
          text,
          tokens: lexer.inlineTokens(text, [])
        };
        lexer.state.inLink = false;
        return token;
      } else {
        return {
          type: 'image',
          raw,
          href,
          title,
          text: escape(text)
        };
      }
    }

    function indentCodeCompensation(raw, text) {
      const matchIndentToCode = raw.match(/^(\s+)(?:```)/);

      if (matchIndentToCode === null) {
        return text;
      }

      const indentToCode = matchIndentToCode[1];

      return text
        .split('\n')
        .map(node => {
          const matchIndentInNode = node.match(/^\s+/);
          if (matchIndentInNode === null) {
            return node;
          }

          const [indentInNode] = matchIndentInNode;

          if (indentInNode.length >= indentToCode.length) {
            return node.slice(indentToCode.length);
          }

          return node;
        })
        .join('\n');
    }

    /**
     * Tokenizer
     */
    class Tokenizer$1 {
      constructor(options) {
        this.options = options || defaults;
      }

      space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
          return {
            type: 'space',
            raw: cap[0]
          };
        }
      }

      code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ {1,4}/gm, '');
          return {
            type: 'code',
            raw: cap[0],
            codeBlockStyle: 'indented',
            text: !this.options.pedantic
              ? rtrim(text, '\n')
              : text
          };
        }
      }

      fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
          const raw = cap[0];
          const text = indentCodeCompensation(raw, cap[3] || '');

          return {
            type: 'code',
            raw,
            lang: cap[2] ? cap[2].trim() : cap[2],
            text
          };
        }
      }

      heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
          let text = cap[2].trim();

          // remove trailing #s
          if (/#$/.test(text)) {
            const trimmed = rtrim(text, '#');
            if (this.options.pedantic) {
              text = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              // CommonMark requires space before trailing #s
              text = trimmed.trim();
            }
          }

          const token = {
            type: 'heading',
            raw: cap[0],
            depth: cap[1].length,
            text: text,
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }

      hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: 'hr',
            raw: cap[0]
          };
        }
      }

      blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ *> ?/gm, '');

          return {
            type: 'blockquote',
            raw: cap[0],
            tokens: this.lexer.blockTokens(text, []),
            text
          };
        }
      }

      list(src) {
        let cap = this.rules.block.list.exec(src);
        if (cap) {
          let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine,
            line, nextLine, rawLine, itemContents, endEarly;

          let bull = cap[1].trim();
          const isordered = bull.length > 1;

          const list = {
            type: 'list',
            raw: '',
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : '',
            loose: false,
            items: []
          };

          bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;

          if (this.options.pedantic) {
            bull = isordered ? bull : '[*+-]';
          }

          // Get next list item
          const itemRegex = new RegExp(`^( {0,3}${bull})((?: [^\\n]*)?(?:\\n|$))`);

          // Check if current bullet point can start a new List Item
          while (src) {
            endEarly = false;
            if (!(cap = itemRegex.exec(src))) {
              break;
            }

            if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)
              break;
            }

            raw = cap[0];
            src = src.substring(raw.length);

            line = cap[2].split('\n', 1)[0];
            nextLine = src.split('\n', 1)[0];

            if (this.options.pedantic) {
              indent = 2;
              itemContents = line.trimLeft();
            } else {
              indent = cap[2].search(/[^ ]/); // Find first non-space char
              indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
              itemContents = line.slice(indent);
              indent += cap[1].length;
            }

            blankLine = false;

            if (!line && /^ *$/.test(nextLine)) { // Items begin with at most one blank line
              raw += nextLine + '\n';
              src = src.substring(nextLine.length + 1);
              endEarly = true;
            }

            if (!endEarly) {
              const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])`);

              // Check if following lines should be included in List Item
              while (src) {
                rawLine = src.split('\n', 1)[0];
                line = rawLine;

                // Re-align to follow commonmark nesting rules
                if (this.options.pedantic) {
                  line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');
                }

                // End list item if found start of new bullet
                if (nextBulletRegex.test(line)) {
                  break;
                }

                if (line.search(/[^ ]/) >= indent || !line.trim()) { // Dedent if possible
                  itemContents += '\n' + line.slice(indent);
                } else if (!blankLine) { // Until blank line, item doesn't need indentation
                  itemContents += '\n' + line;
                } else { // Otherwise, improper indentation ends this item
                  break;
                }

                if (!blankLine && !line.trim()) { // Check if current line is blank
                  blankLine = true;
                }

                raw += rawLine + '\n';
                src = src.substring(rawLine.length + 1);
              }
            }

            if (!list.loose) {
              // If the previous item ended with a blank line, the list is loose
              if (endsWithBlankLine) {
                list.loose = true;
              } else if (/\n *\n *$/.test(raw)) {
                endsWithBlankLine = true;
              }
            }

            // Check for task list items
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.exec(itemContents);
              if (istask) {
                ischecked = istask[0] !== '[ ] ';
                itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
              }
            }

            list.items.push({
              type: 'list_item',
              raw: raw,
              task: !!istask,
              checked: ischecked,
              loose: false,
              text: itemContents
            });

            list.raw += raw;
          }

          // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
          list.items[list.items.length - 1].raw = raw.trimRight();
          list.items[list.items.length - 1].text = itemContents.trimRight();
          list.raw = list.raw.trimRight();

          const l = list.items.length;

          // Item child tokens handled here at end because we needed to have the final item to trim it first
          for (i = 0; i < l; i++) {
            this.lexer.state.top = false;
            list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
            const spacers = list.items[i].tokens.filter(t => t.type === 'space');
            const hasMultipleLineBreaks = spacers.every(t => {
              const chars = t.raw.split('');
              let lineBreaks = 0;
              for (const char of chars) {
                if (char === '\n') {
                  lineBreaks += 1;
                }
                if (lineBreaks > 1) {
                  return true;
                }
              }

              return false;
            });

            if (!list.loose && spacers.length && hasMultipleLineBreaks) {
              // Having a single line break doesn't mean a list is loose. A single line break is terminating the last list item
              list.loose = true;
              list.items[i].loose = true;
            }
          }

          return list;
        }
      }

      html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
          const token = {
            type: 'html',
            raw: cap[0],
            pre: !this.options.sanitizer
              && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
            text: cap[0]
          };
          if (this.options.sanitize) {
            token.type = 'paragraph';
            token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
            token.tokens = [];
            this.lexer.inline(token.text, token.tokens);
          }
          return token;
        }
      }

      def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
          if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
          const tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
          return {
            type: 'def',
            tag,
            raw: cap[0],
            href: cap[2],
            title: cap[3]
          };
        }
      }

      table(src) {
        const cap = this.rules.block.table.exec(src);
        if (cap) {
          const item = {
            type: 'table',
            header: splitCells(cap[1]).map(c => { return { text: c }; }),
            align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
            rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, '').split('\n') : []
          };

          if (item.header.length === item.align.length) {
            item.raw = cap[0];

            let l = item.align.length;
            let i, j, k, row;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = 'right';
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = 'center';
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = 'left';
              } else {
                item.align[i] = null;
              }
            }

            l = item.rows.length;
            for (i = 0; i < l; i++) {
              item.rows[i] = splitCells(item.rows[i], item.header.length).map(c => { return { text: c }; });
            }

            // parse child tokens inside headers and cells

            // header child tokens
            l = item.header.length;
            for (j = 0; j < l; j++) {
              item.header[j].tokens = [];
              this.lexer.inlineTokens(item.header[j].text, item.header[j].tokens);
            }

            // cell child tokens
            l = item.rows.length;
            for (j = 0; j < l; j++) {
              row = item.rows[j];
              for (k = 0; k < row.length; k++) {
                row[k].tokens = [];
                this.lexer.inlineTokens(row[k].text, row[k].tokens);
              }
            }

            return item;
          }
        }
      }

      lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
          const token = {
            type: 'heading',
            raw: cap[0],
            depth: cap[2].charAt(0) === '=' ? 1 : 2,
            text: cap[1],
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }

      paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          const token = {
            type: 'paragraph',
            raw: cap[0],
            text: cap[1].charAt(cap[1].length - 1) === '\n'
              ? cap[1].slice(0, -1)
              : cap[1],
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }

      text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
          const token = {
            type: 'text',
            raw: cap[0],
            text: cap[0],
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }

      escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: 'escape',
            raw: cap[0],
            text: escape(cap[1])
          };
        }
      }

      tag(src) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
            this.lexer.state.inLink = true;
          } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
            this.lexer.state.inLink = false;
          }
          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = true;
          } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = false;
          }

          return {
            type: this.options.sanitize
              ? 'text'
              : 'html',
            raw: cap[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            text: this.options.sanitize
              ? (this.options.sanitizer
                ? this.options.sanitizer(cap[0])
                : escape(cap[0]))
              : cap[0]
          };
        }
      }

      link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
          const trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            // commonmark requires matching angle brackets
            if (!(/>$/.test(trimmedUrl))) {
              return;
            }

            // ending angle bracket cannot be escaped
            const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            // find closing parenthesis
            const lastParenIndex = findClosingBracket(cap[2], '()');
            if (lastParenIndex > -1) {
              const start = cap[0].indexOf('!') === 0 ? 5 : 4;
              const linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = '';
            }
          }
          let href = cap[2];
          let title = '';
          if (this.options.pedantic) {
            // split pedantic href and title
            const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

            if (link) {
              href = link[1];
              title = link[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : '';
          }

          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {
              // pedantic allows starting angle bracket without ending angle bracket
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
            title: title ? title.replace(this.rules.inline._escapes, '$1') : title
          }, cap[0], this.lexer);
        }
      }

      reflink(src, links) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src))
            || (cap = this.rules.inline.nolink.exec(src))) {
          let link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
          link = links[link.toLowerCase()];
          if (!link || !link.href) {
            const text = cap[0].charAt(0);
            return {
              type: 'text',
              raw: text,
              text
            };
          }
          return outputLink(cap, link, cap[0], this.lexer);
        }
      }

      emStrong(src, maskedSrc, prevChar = '') {
        let match = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match) return;

        // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well
        if (match[3] && prevChar.match(/[\p{L}\p{N}]/u)) return;

        const nextChar = match[1] || match[2] || '';

        if (!nextChar || (nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {
          const lLength = match[0].length - 1;
          let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;

          const endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;

          // Clip maskedSrc to same section of string as src (move to lexer?)
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);

          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];

            if (!rDelim) continue; // skip single * in __abc*abc__

            rLength = rDelim.length;

            if (match[3] || match[4]) { // found another Left Delim
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) { // either Left or Right Delim
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue; // CommonMark Emphasis Rules 9-10
              }
            }

            delimTotal -= rLength;

            if (delimTotal > 0) continue; // Haven't found enough closing delimiters

            // Remove extra characters. *a*** -> *a*
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);

            // Create `em` if smallest delimiter has odd char count. *a***
            if (Math.min(lLength, rLength) % 2) {
              const text = src.slice(1, lLength + match.index + rLength);
              return {
                type: 'em',
                raw: src.slice(0, lLength + match.index + rLength + 1),
                text,
                tokens: this.lexer.inlineTokens(text, [])
              };
            }

            // Create 'strong' if smallest delimiter has even char count. **a***
            const text = src.slice(2, lLength + match.index + rLength - 1);
            return {
              type: 'strong',
              raw: src.slice(0, lLength + match.index + rLength + 1),
              text,
              tokens: this.lexer.inlineTokens(text, [])
            };
          }
        }
      }

      codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
          let text = cap[2].replace(/\n/g, ' ');
          const hasNonSpaceChars = /[^ ]/.test(text);
          const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = escape(text, true);
          return {
            type: 'codespan',
            raw: cap[0],
            text
          };
        }
      }

      br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: 'br',
            raw: cap[0]
          };
        }
      }

      del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: 'del',
            raw: cap[0],
            text: cap[2],
            tokens: this.lexer.inlineTokens(cap[2], [])
          };
        }
      }

      autolink(src, mangle) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          let text, href;
          if (cap[2] === '@') {
            text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
            href = 'mailto:' + text;
          } else {
            text = escape(cap[1]);
            href = text;
          }

          return {
            type: 'link',
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: 'text',
                raw: text,
                text
              }
            ]
          };
        }
      }

      url(src, mangle) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
          let text, href;
          if (cap[2] === '@') {
            text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
            href = 'mailto:' + text;
          } else {
            // do extended autolink path validation
            let prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape(cap[0]);
            if (cap[1] === 'www.') {
              href = 'http://' + text;
            } else {
              href = text;
            }
          }
          return {
            type: 'link',
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: 'text',
                raw: text,
                text
              }
            ]
          };
        }
      }

      inlineText(src, smartypants) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
          let text;
          if (this.lexer.state.inRawBlock) {
            text = this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0];
          } else {
            text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
          }
          return {
            type: 'text',
            raw: cap[0],
            text
          };
        }
      }
    }

    /**
     * Block-Level Grammar
     */
    const block$2 = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,
      html: '^ {0,3}(?:' // optional indentation
        + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
        + '|comment[^\\n]*(\\n+|$)' // (2)
        + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
        + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
        + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
        + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
        + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
        + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
        + ')',
      def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
      table: noopTest,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      // regex template, placeholders will be replaced according to different paragraph
      // interruption rules of commonmark and the original markdown spec:
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };

    block$2._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    block$2._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block$2.def = edit(block$2.def)
      .replace('label', block$2._label)
      .replace('title', block$2._title)
      .getRegex();

    block$2.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block$2.listItemStart = edit(/^( *)(bull) */)
      .replace('bull', block$2.bullet)
      .getRegex();

    block$2.list = edit(block$2.list)
      .replace(/bull/g, block$2.bullet)
      .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
      .replace('def', '\\n+(?=' + block$2.def.source + ')')
      .getRegex();

    block$2._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
      + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
      + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
      + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
      + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
      + '|track|ul';
    block$2._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block$2.html = edit(block$2.html, 'i')
      .replace('comment', block$2._comment)
      .replace('tag', block$2._tag)
      .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
      .getRegex();

    block$2.paragraph = edit(block$2._paragraph)
      .replace('hr', block$2.hr)
      .replace('heading', ' {0,3}#{1,6} ')
      .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
      .replace('|table', '')
      .replace('blockquote', ' {0,3}>')
      .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
      .replace('tag', block$2._tag) // pars can be interrupted by type (6) html blocks
      .getRegex();

    block$2.blockquote = edit(block$2.blockquote)
      .replace('paragraph', block$2.paragraph)
      .getRegex();

    /**
     * Normal Block Grammar
     */

    block$2.normal = merge({}, block$2);

    /**
     * GFM Block Grammar
     */

    block$2.gfm = merge({}, block$2.normal, {
      table: '^ *([^\\n ].*\\|.*)\\n' // Header
        + ' {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?' // Align
        + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells
    });

    block$2.gfm.table = edit(block$2.gfm.table)
      .replace('hr', block$2.hr)
      .replace('heading', ' {0,3}#{1,6} ')
      .replace('blockquote', ' {0,3}>')
      .replace('code', ' {4}[^\\n]')
      .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
      .replace('tag', block$2._tag) // tables can be interrupted by type (6) html blocks
      .getRegex();

    block$2.gfm.paragraph = edit(block$2._paragraph)
      .replace('hr', block$2.hr)
      .replace('heading', ' {0,3}#{1,6} ')
      .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
      .replace('table', block$2.gfm.table) // interrupt paragraphs with table
      .replace('blockquote', ' {0,3}>')
      .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
      .replace('tag', block$2._tag) // pars can be interrupted by type (6) html blocks
      .getRegex();
    /**
     * Pedantic grammar (original John Gruber's loose markdown specification)
     */

    block$2.pedantic = merge({}, block$2.normal, {
      html: edit(
        '^ *(?:comment *(?:\\n|\\s*$)'
        + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
        + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
        .replace('comment', block$2._comment)
        .replace(/tag/g, '(?!(?:'
          + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
          + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
          + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
        .getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest, // fences not supported
      paragraph: edit(block$2.normal._paragraph)
        .replace('hr', block$2.hr)
        .replace('heading', ' *#{1,6} *[^\n]')
        .replace('lheading', block$2.lheading)
        .replace('blockquote', ' {0,3}>')
        .replace('|fences', '')
        .replace('|list', '')
        .replace('|html', '')
        .getRegex()
    });

    /**
     * Inline-Level Grammar
     */
    const inline$1 = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: '^comment'
        + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
        + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
        + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
        + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
        + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>', // CDATA section
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: 'reflink|nolink(?!\\()',
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
        //        () Skip orphan delim inside strong    (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
        rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
        rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ // ^- Not allowed for _
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/
    };

    // list of punctuation marks from CommonMark spec
    // without * and _ to handle the different emphasis markers * and _
    inline$1._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
    inline$1.punctuation = edit(inline$1.punctuation).replace(/punctuation/g, inline$1._punctuation).getRegex();

    // sequences em should skip over [title](link), `code`, <html>
    inline$1.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
    inline$1.escapedEmSt = /\\\*|\\_/g;

    inline$1._comment = edit(block$2._comment).replace('(?:-->|$)', '-->').getRegex();

    inline$1.emStrong.lDelim = edit(inline$1.emStrong.lDelim)
      .replace(/punct/g, inline$1._punctuation)
      .getRegex();

    inline$1.emStrong.rDelimAst = edit(inline$1.emStrong.rDelimAst, 'g')
      .replace(/punct/g, inline$1._punctuation)
      .getRegex();

    inline$1.emStrong.rDelimUnd = edit(inline$1.emStrong.rDelimUnd, 'g')
      .replace(/punct/g, inline$1._punctuation)
      .getRegex();

    inline$1._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;

    inline$1._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline$1._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline$1.autolink = edit(inline$1.autolink)
      .replace('scheme', inline$1._scheme)
      .replace('email', inline$1._email)
      .getRegex();

    inline$1._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;

    inline$1.tag = edit(inline$1.tag)
      .replace('comment', inline$1._comment)
      .replace('attribute', inline$1._attribute)
      .getRegex();

    inline$1._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline$1._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline$1._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;

    inline$1.link = edit(inline$1.link)
      .replace('label', inline$1._label)
      .replace('href', inline$1._href)
      .replace('title', inline$1._title)
      .getRegex();

    inline$1.reflink = edit(inline$1.reflink)
      .replace('label', inline$1._label)
      .replace('ref', block$2._label)
      .getRegex();

    inline$1.nolink = edit(inline$1.nolink)
      .replace('ref', block$2._label)
      .getRegex();

    inline$1.reflinkSearch = edit(inline$1.reflinkSearch, 'g')
      .replace('reflink', inline$1.reflink)
      .replace('nolink', inline$1.nolink)
      .getRegex();

    /**
     * Normal Inline Grammar
     */

    inline$1.normal = merge({}, inline$1);

    /**
     * Pedantic Inline Grammar
     */

    inline$1.pedantic = merge({}, inline$1.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/)
        .replace('label', inline$1._label)
        .getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
        .replace('label', inline$1._label)
        .getRegex()
    });

    /**
     * GFM Inline Grammar
     */

    inline$1.gfm = merge({}, inline$1.normal, {
      escape: edit(inline$1.escape).replace('])', '~|])').getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    });

    inline$1.gfm.url = edit(inline$1.gfm.url, 'i')
      .replace('email', inline$1.gfm._extended_email)
      .getRegex();
    /**
     * GFM + Line Breaks Inline Grammar
     */

    inline$1.breaks = merge({}, inline$1.gfm, {
      br: edit(inline$1.br).replace('{2,}', '*').getRegex(),
      text: edit(inline$1.gfm.text)
        .replace('\\b_', '\\b_| {2,}\\n')
        .replace(/\{2,\}/g, '*')
        .getRegex()
    });

    /**
     * smartypants text replacement
     */
    function smartypants(text) {
      return text
        // em-dashes
        .replace(/---/g, '\u2014')
        // en-dashes
        .replace(/--/g, '\u2013')
        // opening singles
        .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
        // closing singles & apostrophes
        .replace(/'/g, '\u2019')
        // opening doubles
        .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
        // closing doubles
        .replace(/"/g, '\u201d')
        // ellipses
        .replace(/\.{3}/g, '\u2026');
    }

    /**
     * mangle email addresses
     */
    function mangle(text) {
      let out = '',
        i,
        ch;

      const l = text.length;
      for (i = 0; i < l; i++) {
        ch = text.charCodeAt(i);
        if (Math.random() > 0.5) {
          ch = 'x' + ch.toString(16);
        }
        out += '&#' + ch + ';';
      }

      return out;
    }

    /**
     * Block Lexer
     */
    class Lexer {
      constructor(options) {
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options = options || defaults;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer$1();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
          inLink: false,
          inRawBlock: false,
          top: true
        };

        const rules = {
          block: block$2.normal,
          inline: inline$1.normal
        };

        if (this.options.pedantic) {
          rules.block = block$2.pedantic;
          rules.inline = inline$1.pedantic;
        } else if (this.options.gfm) {
          rules.block = block$2.gfm;
          if (this.options.breaks) {
            rules.inline = inline$1.breaks;
          } else {
            rules.inline = inline$1.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }

      /**
       * Expose Rules
       */
      static get rules() {
        return {
          block: block$2,
          inline: inline$1
        };
      }

      /**
       * Static Lex Method
       */
      static lex(src, options) {
        const lexer = new Lexer(options);
        return lexer.lex(src);
      }

      /**
       * Static Lex Inline Method
       */
      static lexInline(src, options) {
        const lexer = new Lexer(options);
        return lexer.inlineTokens(src);
      }

      /**
       * Preprocessing
       */
      lex(src) {
        src = src
          .replace(/\r\n|\r/g, '\n')
          .replace(/\t/g, '    ');

        this.blockTokens(src, this.tokens);

        let next;
        while (next = this.inlineQueue.shift()) {
          this.inlineTokens(next.src, next.tokens);
        }

        return this.tokens;
      }

      /**
       * Lexing
       */
      blockTokens(src, tokens = []) {
        if (this.options.pedantic) {
          src = src.replace(/^ +$/gm, '');
        }
        let token, lastToken, cutSrc, lastParagraphClipped;

        while (src) {
          if (this.options.extensions
            && this.options.extensions.block
            && this.options.extensions.block.some((extTokenizer) => {
              if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                return true;
              }
              return false;
            })) {
            continue;
          }

          // newline
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.raw.length === 1 && tokens.length > 0) {
              // if there's a single \n as a spacer, it's terminating the last line,
              // so move it there so that we don't get unecessary paragraph tags
              tokens[tokens.length - 1].raw += '\n';
            } else {
              tokens.push(token);
            }
            continue;
          }

          // code
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            // An indented code block cannot interrupt a paragraph.
            if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
              lastToken.raw += '\n' + token.raw;
              lastToken.text += '\n' + token.text;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }

          // fences
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // heading
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // hr
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // blockquote
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // list
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // html
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // def
          if (token = this.tokenizer.def(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
              lastToken.raw += '\n' + token.raw;
              lastToken.text += '\n' + token.raw;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }

          // table (gfm)
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // lheading
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // top-level paragraph
          // prevent paragraph consuming extensions by clipping 'src' to extension start
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startBlock.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === 'number' && tempStart >= 0) { startIndex = Math.min(startIndex, tempStart); }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === 'paragraph') {
              lastToken.raw += '\n' + token.raw;
              lastToken.text += '\n' + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = (cutSrc.length !== src.length);
            src = src.substring(token.raw.length);
            continue;
          }

          // text
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === 'text') {
              lastToken.raw += '\n' + token.raw;
              lastToken.text += '\n' + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }

          if (src) {
            const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }

        this.state.top = true;
        return tokens;
      }

      inline(src, tokens) {
        this.inlineQueue.push({ src, tokens });
      }

      /**
       * Lexing/Compiling
       */
      inlineTokens(src, tokens = []) {
        let token, lastToken, cutSrc;

        // String with links masked to avoid interference with em and strong
        let maskedSrc = src;
        let match;
        let keepPrevChar, prevChar;

        // Mask out reflinks
        if (this.tokens.links) {
          const links = Object.keys(this.tokens.links);
          if (links.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        // Mask out other blocks
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }

        // Mask out escaped em & strong delimiters
        while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
        }

        while (src) {
          if (!keepPrevChar) {
            prevChar = '';
          }
          keepPrevChar = false;

          // extensions
          if (this.options.extensions
            && this.options.extensions.inline
            && this.options.extensions.inline.some((extTokenizer) => {
              if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                return true;
              }
              return false;
            })) {
            continue;
          }

          // escape
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // tag
          if (token = this.tokenizer.tag(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === 'text' && lastToken.type === 'text') {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }

          // link
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // reflink, nolink
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === 'text' && lastToken.type === 'text') {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }

          // em & strong
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // code
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // br
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // del (gfm)
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // autolink
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // url (gfm)
          if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // text
          // prevent inlineText consuming extensions by clipping 'src' to extension start
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startInline.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === 'number' && tempStart >= 0) { startIndex = Math.min(startIndex, tempStart); }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === 'text') {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }

          if (src) {
            const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }

        return tokens;
      }
    }

    /**
     * Renderer
     */
    class Renderer {
      constructor(options) {
        this.options = options || defaults;
      }

      code(code, infostring, escaped) {
        const lang = (infostring || '').match(/\S*/)[0];
        if (this.options.highlight) {
          const out = this.options.highlight(code, lang);
          if (out != null && out !== code) {
            escaped = true;
            code = out;
          }
        }

        code = code.replace(/\n$/, '') + '\n';

        if (!lang) {
          return '<pre><code>'
            + (escaped ? code : escape(code, true))
            + '</code></pre>\n';
        }

        return '<pre><code class="'
          + this.options.langPrefix
          + escape(lang, true)
          + '">'
          + (escaped ? code : escape(code, true))
          + '</code></pre>\n';
      }

      blockquote(quote) {
        return '<blockquote>\n' + quote + '</blockquote>\n';
      }

      html(html) {
        return html;
      }

      heading(text, level, raw, slugger) {
        if (this.options.headerIds) {
          return '<h'
            + level
            + ' id="'
            + this.options.headerPrefix
            + slugger.slug(raw)
            + '">'
            + text
            + '</h'
            + level
            + '>\n';
        }
        // ignore IDs
        return '<h' + level + '>' + text + '</h' + level + '>\n';
      }

      hr() {
        return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
      }

      list(body, ordered, start) {
        const type = ordered ? 'ol' : 'ul',
          startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
        return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
      }

      listitem(text) {
        return '<li>' + text + '</li>\n';
      }

      checkbox(checked) {
        return '<input '
          + (checked ? 'checked="" ' : '')
          + 'disabled="" type="checkbox"'
          + (this.options.xhtml ? ' /' : '')
          + '> ';
      }

      paragraph(text) {
        return '<p>' + text + '</p>\n';
      }

      table(header, body) {
        if (body) body = '<tbody>' + body + '</tbody>';

        return '<table>\n'
          + '<thead>\n'
          + header
          + '</thead>\n'
          + body
          + '</table>\n';
      }

      tablerow(content) {
        return '<tr>\n' + content + '</tr>\n';
      }

      tablecell(content, flags) {
        const type = flags.header ? 'th' : 'td';
        const tag = flags.align
          ? '<' + type + ' align="' + flags.align + '">'
          : '<' + type + '>';
        return tag + content + '</' + type + '>\n';
      }

      // span level renderer
      strong(text) {
        return '<strong>' + text + '</strong>';
      }

      em(text) {
        return '<em>' + text + '</em>';
      }

      codespan(text) {
        return '<code>' + text + '</code>';
      }

      br() {
        return this.options.xhtml ? '<br/>' : '<br>';
      }

      del(text) {
        return '<del>' + text + '</del>';
      }

      link(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        let out = '<a href="' + escape(href) + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += '>' + text + '</a>';
        return out;
      }

      image(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }

        let out = '<img src="' + href + '" alt="' + text + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += this.options.xhtml ? '/>' : '>';
        return out;
      }

      text(text) {
        return text;
      }
    }

    /**
     * TextRenderer
     * returns only the textual part of the token
     */
    class TextRenderer {
      // no need for block level renderers
      strong(text) {
        return text;
      }

      em(text) {
        return text;
      }

      codespan(text) {
        return text;
      }

      del(text) {
        return text;
      }

      html(text) {
        return text;
      }

      text(text) {
        return text;
      }

      link(href, title, text) {
        return '' + text;
      }

      image(href, title, text) {
        return '' + text;
      }

      br() {
        return '';
      }
    }

    /**
     * Slugger generates header id
     */
    class Slugger {
      constructor() {
        this.seen = {};
      }

      serialize(value) {
        return value
          .toLowerCase()
          .trim()
          // remove html tags
          .replace(/<[!\/a-z].*?>/ig, '')
          // remove unwanted chars
          .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
          .replace(/\s/g, '-');
      }

      /**
       * Finds the next safe (unique) slug to use
       */
      getNextSafeSlug(originalSlug, isDryRun) {
        let slug = originalSlug;
        let occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + '-' + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      }

      /**
       * Convert string to unique id
       * @param {object} options
       * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.
       */
      slug(value, options = {}) {
        const slug = this.serialize(value);
        return this.getNextSafeSlug(slug, options.dryrun);
      }
    }

    /**
     * Parsing & Compiling
     */
    class Parser$1 {
      constructor(options) {
        this.options = options || defaults;
        this.options.renderer = this.options.renderer || new Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer();
        this.slugger = new Slugger();
      }

      /**
       * Static Parse Method
       */
      static parse(tokens, options) {
        const parser = new Parser$1(options);
        return parser.parse(tokens);
      }

      /**
       * Static Parse Inline Method
       */
      static parseInline(tokens, options) {
        const parser = new Parser$1(options);
        return parser.parseInline(tokens);
      }

      /**
       * Parse Loop
       */
      parse(tokens, top = true) {
        let out = '',
          i,
          j,
          k,
          l2,
          l3,
          row,
          cell,
          header,
          body,
          token,
          ordered,
          start,
          loose,
          itemBody,
          item,
          checked,
          task,
          checkbox,
          ret;

        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];

          // Run any renderer extensions
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {
              out += ret || '';
              continue;
            }
          }

          switch (token.type) {
            case 'space': {
              continue;
            }
            case 'hr': {
              out += this.renderer.hr();
              continue;
            }
            case 'heading': {
              out += this.renderer.heading(
                this.parseInline(token.tokens),
                token.depth,
                unescape$1(this.parseInline(token.tokens, this.textRenderer)),
                this.slugger);
              continue;
            }
            case 'code': {
              out += this.renderer.code(token.text,
                token.lang,
                token.escaped);
              continue;
            }
            case 'table': {
              header = '';

              // header
              cell = '';
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(
                  this.parseInline(token.header[j].tokens),
                  { header: true, align: token.align[j] }
                );
              }
              header += this.renderer.tablerow(cell);

              body = '';
              l2 = token.rows.length;
              for (j = 0; j < l2; j++) {
                row = token.rows[j];

                cell = '';
                l3 = row.length;
                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(
                    this.parseInline(row[k].tokens),
                    { header: false, align: token.align[k] }
                  );
                }

                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case 'blockquote': {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case 'list': {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;

              body = '';
              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;

                itemBody = '';
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {
                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: 'text',
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }

                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }

              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case 'html': {
              // TODO parse inline content if parameter markdown=1
              out += this.renderer.html(token.text);
              continue;
            }
            case 'paragraph': {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case 'text': {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i + 1 < l && tokens[i + 1].type === 'text') {
                token = tokens[++i];
                body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }

            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }

        return out;
      }

      /**
       * Parse Inline Tokens
       */
      parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = '',
          i,
          token,
          ret;

        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];

          // Run any renderer extensions
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {
              out += ret || '';
              continue;
            }
          }

          switch (token.type) {
            case 'escape': {
              out += renderer.text(token.text);
              break;
            }
            case 'html': {
              out += renderer.html(token.text);
              break;
            }
            case 'link': {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case 'image': {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case 'strong': {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case 'em': {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case 'codespan': {
              out += renderer.codespan(token.text);
              break;
            }
            case 'br': {
              out += renderer.br();
              break;
            }
            case 'del': {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case 'text': {
              out += renderer.text(token.text);
              break;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
    }

    /**
     * Marked
     */
    function marked(src, opt, callback) {
      // throw error in case of non string input
      if (typeof src === 'undefined' || src === null) {
        throw new Error('marked(): input parameter is undefined or null');
      }
      if (typeof src !== 'string') {
        throw new Error('marked(): input parameter is of type '
          + Object.prototype.toString.call(src) + ', string expected');
      }

      if (typeof opt === 'function') {
        callback = opt;
        opt = null;
      }

      opt = merge({}, marked.defaults, opt || {});
      checkSanitizeDeprecation(opt);

      if (callback) {
        const highlight = opt.highlight;
        let tokens;

        try {
          tokens = Lexer.lex(src, opt);
        } catch (e) {
          return callback(e);
        }

        const done = function(err) {
          let out;

          if (!err) {
            try {
              if (opt.walkTokens) {
                marked.walkTokens(tokens, opt.walkTokens);
              }
              out = Parser$1.parse(tokens, opt);
            } catch (e) {
              err = e;
            }
          }

          opt.highlight = highlight;

          return err
            ? callback(err)
            : callback(null, out);
        };

        if (!highlight || highlight.length < 3) {
          return done();
        }

        delete opt.highlight;

        if (!tokens.length) return done();

        let pending = 0;
        marked.walkTokens(tokens, function(token) {
          if (token.type === 'code') {
            pending++;
            setTimeout(() => {
              highlight(token.text, token.lang, function(err, code) {
                if (err) {
                  return done(err);
                }
                if (code != null && code !== token.text) {
                  token.text = code;
                  token.escaped = true;
                }

                pending--;
                if (pending === 0) {
                  done();
                }
              });
            }, 0);
          }
        });

        if (pending === 0) {
          done();
        }

        return;
      }

      try {
        const tokens = Lexer.lex(src, opt);
        if (opt.walkTokens) {
          marked.walkTokens(tokens, opt.walkTokens);
        }
        return Parser$1.parse(tokens, opt);
      } catch (e) {
        e.message += '\nPlease report this to https://github.com/markedjs/marked.';
        if (opt.silent) {
          return '<p>An error occurred:</p><pre>'
            + escape(e.message + '', true)
            + '</pre>';
        }
        throw e;
      }
    }

    /**
     * Options
     */

    marked.options =
    marked.setOptions = function(opt) {
      merge(marked.defaults, opt);
      changeDefaults(marked.defaults);
      return marked;
    };

    marked.getDefaults = getDefaults;

    marked.defaults = defaults;

    /**
     * Use Extension
     */

    marked.use = function(...args) {
      const opts = merge({}, ...args);
      const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
      let hasExtensions;

      args.forEach((pack) => {
        // ==-- Parse "addon" extensions --== //
        if (pack.extensions) {
          hasExtensions = true;
          pack.extensions.forEach((ext) => {
            if (!ext.name) {
              throw new Error('extension name required');
            }
            if (ext.renderer) { // Renderer extensions
              const prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
              if (prevRenderer) {
                // Replace extension with func to run new extension but fall back if false
                extensions.renderers[ext.name] = function(...args) {
                  let ret = ext.renderer.apply(this, args);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if (ext.tokenizer) { // Tokenizer Extensions
              if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              if (extensions[ext.level]) {
                extensions[ext.level].unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) { // Function to check for start of token
                if (ext.level === 'block') {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === 'inline') {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if (ext.childTokens) { // Child tokens to be visited by walkTokens
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
        }

        // ==-- Parse "overwrite" extensions --== //
        if (pack.renderer) {
          const renderer = marked.defaults.renderer || new Renderer();
          for (const prop in pack.renderer) {
            const prevRenderer = renderer[prop];
            // Replace renderer with func to run extension, but fall back if false
            renderer[prop] = (...args) => {
              let ret = pack.renderer[prop].apply(renderer, args);
              if (ret === false) {
                ret = prevRenderer.apply(renderer, args);
              }
              return ret;
            };
          }
          opts.renderer = renderer;
        }
        if (pack.tokenizer) {
          const tokenizer = marked.defaults.tokenizer || new Tokenizer$1();
          for (const prop in pack.tokenizer) {
            const prevTokenizer = tokenizer[prop];
            // Replace tokenizer with func to run extension, but fall back if false
            tokenizer[prop] = (...args) => {
              let ret = pack.tokenizer[prop].apply(tokenizer, args);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args);
              }
              return ret;
            };
          }
          opts.tokenizer = tokenizer;
        }

        // ==-- Parse WalkTokens extensions --== //
        if (pack.walkTokens) {
          const walkTokens = marked.defaults.walkTokens;
          opts.walkTokens = function(token) {
            pack.walkTokens.call(this, token);
            if (walkTokens) {
              walkTokens.call(this, token);
            }
          };
        }

        if (hasExtensions) {
          opts.extensions = extensions;
        }

        marked.setOptions(opts);
      });
    };

    /**
     * Run callback for every token
     */

    marked.walkTokens = function(tokens, callback) {
      for (const token of tokens) {
        callback.call(marked, token);
        switch (token.type) {
          case 'table': {
            for (const cell of token.header) {
              marked.walkTokens(cell.tokens, callback);
            }
            for (const row of token.rows) {
              for (const cell of row) {
                marked.walkTokens(cell.tokens, callback);
              }
            }
            break;
          }
          case 'list': {
            marked.walkTokens(token.items, callback);
            break;
          }
          default: {
            if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) { // Walk any extensions
              marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
                marked.walkTokens(token[childTokens], callback);
              });
            } else if (token.tokens) {
              marked.walkTokens(token.tokens, callback);
            }
          }
        }
      }
    };

    /**
     * Parse Inline
     */
    marked.parseInline = function(src, opt) {
      // throw error in case of non string input
      if (typeof src === 'undefined' || src === null) {
        throw new Error('marked.parseInline(): input parameter is undefined or null');
      }
      if (typeof src !== 'string') {
        throw new Error('marked.parseInline(): input parameter is of type '
          + Object.prototype.toString.call(src) + ', string expected');
      }

      opt = merge({}, marked.defaults, opt || {});
      checkSanitizeDeprecation(opt);

      try {
        const tokens = Lexer.lexInline(src, opt);
        if (opt.walkTokens) {
          marked.walkTokens(tokens, opt.walkTokens);
        }
        return Parser$1.parseInline(tokens, opt);
      } catch (e) {
        e.message += '\nPlease report this to https://github.com/markedjs/marked.';
        if (opt.silent) {
          return '<p>An error occurred:</p><pre>'
            + escape(e.message + '', true)
            + '</pre>';
        }
        throw e;
      }
    };

    /**
     * Expose
     */
    marked.Parser = Parser$1;
    marked.parser = Parser$1.parse;
    marked.Renderer = Renderer;
    marked.TextRenderer = TextRenderer;
    marked.Lexer = Lexer;
    marked.lexer = Lexer.lex;
    marked.Tokenizer = Tokenizer$1;
    marked.Slugger = Slugger;
    marked.parse = marked;
    Parser$1.parse;
    Lexer.lex;

    /* src/util/TOC.svelte generated by Svelte v3.44.3 */

    const { console: console_1$4 } = globals;
    const file$D = "src/util/TOC.svelte";

    // (94:0) {:else}
    function create_else_block_1$2(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(div, "class", "toc-message");
    			add_location(div, file$D, 94, 2, 2343);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(94:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (85:0) {#if headings.length}
    function create_if_block$m(ctx) {
    	let treelike;
    	let current;

    	treelike = new Treelike({
    			props: {
    				items: /*headings*/ ctx[0],
    				$$slots: {
    					default: [
    						create_default_slot$v,
    						({ item }) => ({ 12: item }),
    						({ item }) => item ? 4096 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(treelike.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(treelike, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const treelike_changes = {};
    			if (dirty & /*headings*/ 1) treelike_changes.items = /*headings*/ ctx[0];

    			if (dirty & /*$$scope, slugger, item*/ 4162) {
    				treelike_changes.$$scope = { dirty, ctx };
    			}

    			treelike.$set(treelike_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(treelike.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(treelike.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(treelike, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(85:0) {#if headings.length}",
    		ctx
    	});

    	return block;
    }

    // (96:10) NONE
    function fallback_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("NONE");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(96:10) NONE",
    		ctx
    	});

    	return block;
    }

    // (89:4) {:else}
    function create_else_block$b(ctx) {
    	let link;
    	let t0;
    	let span;
    	let current;

    	link = new Link$1({
    			props: {
    				nored: true,
    				self: true,
    				cmd: /*slugger*/ ctx[1].slug(/*item*/ ctx[12][0]),
    				$$slots: { default: [create_default_slot_2$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    			t0 = space();
    			span = element("span");
    			span.textContent = "+";
    			attr_dev(span, "class", "toc-plus");
    			add_location(span, file$D, 90, 6, 2277);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*slugger, item*/ 4098) link_changes.cmd = /*slugger*/ ctx[1].slug(/*item*/ ctx[12][0]);

    			if (dirty & /*$$scope, item*/ 4160) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(89:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (87:4) {#if typeof(item) == 'string'}
    function create_if_block_1$c(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				nored: true,
    				self: true,
    				cmd: /*slugger*/ ctx[1].slug(/*item*/ ctx[12]),
    				$$slots: { default: [create_default_slot_1$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*slugger, item*/ 4098) link_changes.cmd = /*slugger*/ ctx[1].slug(/*item*/ ctx[12]);

    			if (dirty & /*$$scope, item*/ 4160) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(87:4) {#if typeof(item) == 'string'}",
    		ctx
    	});

    	return block;
    }

    // (90:6) <Link nored self cmd={slugger.slug(item[0])}>
    function create_default_slot_2$i(ctx) {
    	let t_value = /*item*/ ctx[12][0] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*item*/ 4096 && t_value !== (t_value = /*item*/ ctx[12][0] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$i.name,
    		type: "slot",
    		source: "(90:6) <Link nored self cmd={slugger.slug(item[0])}>",
    		ctx
    	});

    	return block;
    }

    // (88:6) <Link nored self cmd={slugger.slug(item)}>
    function create_default_slot_1$l(ctx) {
    	let t_value = /*item*/ ctx[12] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*item*/ 4096 && t_value !== (t_value = /*item*/ ctx[12] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$l.name,
    		type: "slot",
    		source: "(88:6) <Link nored self cmd={slugger.slug(item)}>",
    		ctx
    	});

    	return block;
    }

    // (86:2) <Treelike items={headings} let:item={item}>
    function create_default_slot$v(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$c, create_else_block$b];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (typeof /*item*/ ctx[12] == 'string') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$v.name,
    		type: "slot",
    		source: "(86:2) <Treelike items={headings} let:item={item}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$10(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$m, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*headings*/ ctx[0].length) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let rl;
    	let $tokens;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TOC', slots, ['default']);
    	const tokens = getContext('tokens');
    	validate_store(tokens, 'tokens');
    	component_subscribe($$self, tokens, value => $$invalidate(4, $tokens = value));
    	const state = getContext('state');
    	const path = getContext('path');
    	let { limit = null } = $$props;
    	let headings = [];
    	let slugger = new marked.Slugger();

    	class TOCTree {
    		constructor(p = null) {
    			this.parent = p;
    			this.tree = [];
    			this.depth = this.parent ? this.parent.depth + 1 : null;
    		}

    		add(t) {
    			if (this.depth === null) this.depth = t.depth;

    			if (t.depth > this.depth) {
    				const sub = new TOCTree(this);
    				t.depth = sub.depth;
    				this.tree.push(sub);
    				return sub.add(t);
    			} else if (t.depth < this.depth) {
    				if (this.parent) {
    					return this.parent.add(t);
    				} else {
    					t.depth = this.depth;
    					this.tree.push(t.text);
    					return this;
    				}
    			} else {
    				this.tree.push(t.text);
    				return this;
    			}
    		}

    		count() {
    			let c = 0;

    			this.tree.forEach(h => {
    				if (typeof h == 'string') c += 1; else c += h.count();
    			});

    			return c;
    		}

    		flat(lim = null, depth = 0) {
    			const out = [];
    			if (lim !== null && depth > lim) return [this.count()];

    			this.tree.forEach(h => {
    				if (typeof h == 'string') out.push(h); else {
    					const z = out.pop();
    					out.push([z, ...h.flat(lim, depth + 1)]);
    				}
    			});

    			return out;
    		}
    	}

    	const mkh = tkns => {
    		if (tkns && tkns.length) {
    			$$invalidate(1, slugger = new marked.Slugger());
    			const out = new TOCTree();
    			let current = out;

    			tkns.filter(t => t.type == 'heading').forEach(t => {
    				current = current.add(t);
    			});

    			$$invalidate(0, headings = out.flat(rl));
    		} else {
    			$$invalidate(0, headings = []);
    		}

    		console.log(headings);
    	};

    	const writable_props = ['limit'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$4.warn(`<TOC> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('limit' in $$props) $$invalidate(3, limit = $$props.limit);
    		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		Link: Link$1,
    		Treelike,
    		marked,
    		getContext,
    		setContext,
    		writable,
    		tokens,
    		state,
    		path,
    		limit,
    		headings,
    		slugger,
    		TOCTree,
    		mkh,
    		rl,
    		$tokens
    	});

    	$$self.$inject_state = $$props => {
    		if ('limit' in $$props) $$invalidate(3, limit = $$props.limit);
    		if ('headings' in $$props) $$invalidate(0, headings = $$props.headings);
    		if ('slugger' in $$props) $$invalidate(1, slugger = $$props.slugger);
    		if ('rl' in $$props) rl = $$props.rl;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*limit*/ 8) {
    			rl = limit === null ? null : limit - 1;
    		}

    		if ($$self.$$.dirty & /*$tokens*/ 16) {
    			mkh($tokens);
    		}
    	};

    	return [headings, slugger, tokens, limit, $tokens, slots, $$scope];
    }

    class TOC extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$10, create_fragment$10, safe_not_equal, { limit: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TOC",
    			options,
    			id: create_fragment$10.name
    		});
    	}

    	get limit() {
    		throw new Error("<TOC>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set limit(value) {
    		throw new Error("<TOC>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/util/TopButton.svelte generated by Svelte v3.44.3 */

    // (14:0) <Link nolink does={gotop} disable={!$scrollinfo.scrolled}>
    function create_default_slot$u(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("TOP");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$u.name,
    		type: "slot",
    		source: "(14:0) <Link nolink does={gotop} disable={!$scrollinfo.scrolled}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$$(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				nolink: true,
    				does: /*gotop*/ ctx[2],
    				disable: !/*$scrollinfo*/ ctx[0].scrolled,
    				$$slots: { default: [create_default_slot$u] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const link_changes = {};
    			if (dirty & /*$scrollinfo*/ 1) link_changes.disable = !/*$scrollinfo*/ ctx[0].scrolled;

    			if (dirty & /*$$scope*/ 32) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let $scrollinfo;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TopButton', slots, []);
    	const scrollinfo = getContext('scrollinfo');
    	validate_store(scrollinfo, 'scrollinfo');
    	component_subscribe($$self, scrollinfo, value => $$invalidate(0, $scrollinfo = value));
    	const scrolltop = getContext('scrolltop');
    	const drophash = getContext('drophash');

    	const gotop = () => {
    		drophash();
    		scrolltop();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TopButton> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Link: Link$1,
    		getContext,
    		scrollinfo,
    		scrolltop,
    		drophash,
    		gotop,
    		$scrollinfo
    	});

    	return [$scrollinfo, scrollinfo, gotop];
    }

    class TopButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$$, create_fragment$$, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TopButton",
    			options,
    			id: create_fragment$$.name
    		});
    	}
    }

    /* src/wideui/WUITOC.svelte generated by Svelte v3.44.3 */

    // (12:0) {#if $state.content}
    function create_if_block$l(ctx) {
    	let wuimodule;
    	let current;

    	wuimodule = new WUIModule({
    			props: {
    				$$slots: {
    					body: [create_body_slot$3],
    					controls: [create_controls_slot],
    					title: [create_title_slot$3]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(wuimodule.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(wuimodule, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const wuimodule_changes = {};

    			if (dirty & /*$$scope, $scrollinfo*/ 18) {
    				wuimodule_changes.$$scope = { dirty, ctx };
    			}

    			wuimodule.$set(wuimodule_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wuimodule.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wuimodule.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(wuimodule, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(12:0) {#if $state.content}",
    		ctx
    	});

    	return block;
    }

    // (15:4) <svelte:fragment slot="title">
    function create_title_slot$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("CONTENTS");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$3.name,
    		type: "slot",
    		source: "(15:4) <svelte:fragment slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (18:6) {#if $scrollinfo.scrollable}
    function create_if_block_1$b(ctx) {
    	let wuibutton;
    	let current;

    	wuibutton = new WUIButton({
    			props: {
    				$$slots: { default: [create_default_slot$t] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(wuibutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(wuibutton, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wuibutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wuibutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(wuibutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(18:6) {#if $scrollinfo.scrollable}",
    		ctx
    	});

    	return block;
    }

    // (19:8) <WUIButton>
    function create_default_slot$t(ctx) {
    	let topbutton;
    	let current;
    	topbutton = new TopButton({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(topbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(topbutton, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(topbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(topbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(topbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$t.name,
    		type: "slot",
    		source: "(19:8) <WUIButton>",
    		ctx
    	});

    	return block;
    }

    // (17:4) <svelte:fragment slot="controls">
    function create_controls_slot(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$scrollinfo*/ ctx[1].scrollable && create_if_block_1$b(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$scrollinfo*/ ctx[1].scrollable) {
    				if (if_block) {
    					if (dirty & /*$scrollinfo*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_controls_slot.name,
    		type: "slot",
    		source: "(17:4) <svelte:fragment slot=\\\"controls\\\">",
    		ctx
    	});

    	return block;
    }

    // (23:4) <svelte:fragment slot="body">
    function create_body_slot$3(ctx) {
    	let toc;
    	let current;
    	toc = new TOC({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(toc.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(toc, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toc.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toc.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(toc, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$3.name,
    		type: "slot",
    		source: "(23:4) <svelte:fragment slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$_(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$state*/ ctx[0].content && create_if_block$l(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$state*/ ctx[0].content) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$state*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$l(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let $state;
    	let $scrollinfo;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('WUITOC', slots, []);
    	const state = getContext('state');
    	validate_store(state, 'state');
    	component_subscribe($$self, state, value => $$invalidate(0, $state = value));
    	const scrollinfo = getContext('scrollinfo');
    	validate_store(scrollinfo, 'scrollinfo');
    	component_subscribe($$self, scrollinfo, value => $$invalidate(1, $scrollinfo = value));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<WUITOC> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		WUIModule,
    		WUIButton,
    		TOC,
    		TopButton,
    		getContext,
    		state,
    		scrollinfo,
    		$state,
    		$scrollinfo
    	});

    	return [$state, $scrollinfo, state, scrollinfo];
    }

    class WUITOC extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$_, create_fragment$_, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WUITOC",
    			options,
    			id: create_fragment$_.name
    		});
    	}
    }

    /* src/util/Wrapper.svelte generated by Svelte v3.44.3 */
    const file$C = "src/util/Wrapper.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    const get_default_slot_changes = dirty => ({ item: dirty & /*it*/ 4 });
    const get_default_slot_context = ctx => ({ item: /*item*/ ctx[10] });

    // (27:6) <FB vert center c="wrapper-sep">
    function create_default_slot_2$h(ctx) {
    	let svg;
    	let circle;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			attr_dev(circle, "cx", "5");
    			attr_dev(circle, "cy", "5");
    			attr_dev(circle, "r", "4");
    			add_location(circle, file$C, 28, 10, 695);
    			attr_dev(svg, "viewBox", "0 0 10 10");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			set_style(svg, "width", "4px");
    			set_style(svg, "height", "4px");
    			add_location(svg, file$C, 27, 8, 594);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, circle);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$h.name,
    		type: "slot",
    		source: "(27:6) <FB vert center c=\\\"wrapper-sep\\\">",
    		ctx
    	});

    	return block;
    }

    // (26:4) <FB {line} c="wrapped">
    function create_default_slot_1$k(ctx) {
    	let fb;
    	let t0;
    	let t1;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				center: true,
    				c: "wrapper-sep",
    				$$slots: { default: [create_default_slot_2$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context);

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t0 = space();
    			if (default_slot) default_slot.c();
    			t1 = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t0, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, it*/ 260)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, get_default_slot_changes),
    						get_default_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t0);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$k.name,
    		type: "slot",
    		source: "(26:4) <FB {line} c=\\\"wrapped\\\">",
    		ctx
    	});

    	return block;
    }

    // (25:2) {#each it as item}
    function create_each_block$9(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				line: /*line*/ ctx[0],
    				c: "wrapped",
    				$$slots: { default: [create_default_slot_1$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};
    			if (dirty & /*line*/ 1) fb_changes.line = /*line*/ ctx[0];

    			if (dirty & /*$$scope, it*/ 260) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(25:2) {#each it as item}",
    		ctx
    	});

    	return block;
    }

    // (24:0) <FB wrap c="wrapper" {style}>
    function create_default_slot$s(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*it*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*line, $$scope, it*/ 261) {
    				each_value = /*it*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$s.name,
    		type: "slot",
    		source: "(24:0) <FB wrap c=\\\"wrapper\\\" {style}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Z(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				wrap: true,
    				c: "wrapper",
    				style: /*style*/ ctx[1],
    				$$slots: { default: [create_default_slot$s] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*style*/ 2) fb_changes.style = /*style*/ ctx[1];

    			if (dirty & /*$$scope, it, line*/ 261) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let it;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Wrapper', slots, ['default']);
    	let { items } = $$props;
    	let { limit = null } = $$props;
    	let { vgap = 0 } = $$props;
    	let { line = "n" } = $$props;
    	let { lines = null } = $$props;
    	let style = {};

    	const mkcss = () => {
    		const c = { 'row-gap': `${vgap}px` };

    		if (lines) {
    			c['max-height'] = `calc((var(--x${line}) * ${lines}) + ${vgap * (lines - 1)}px)`;
    		}

    		$$invalidate(1, style = c);
    	};

    	const writable_props = ['items', 'limit', 'vgap', 'line', 'lines'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Wrapper> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('items' in $$props) $$invalidate(3, items = $$props.items);
    		if ('limit' in $$props) $$invalidate(4, limit = $$props.limit);
    		if ('vgap' in $$props) $$invalidate(5, vgap = $$props.vgap);
    		if ('line' in $$props) $$invalidate(0, line = $$props.line);
    		if ('lines' in $$props) $$invalidate(6, lines = $$props.lines);
    		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		items,
    		limit,
    		vgap,
    		line,
    		lines,
    		style,
    		mkcss,
    		it
    	});

    	$$self.$inject_state = $$props => {
    		if ('items' in $$props) $$invalidate(3, items = $$props.items);
    		if ('limit' in $$props) $$invalidate(4, limit = $$props.limit);
    		if ('vgap' in $$props) $$invalidate(5, vgap = $$props.vgap);
    		if ('line' in $$props) $$invalidate(0, line = $$props.line);
    		if ('lines' in $$props) $$invalidate(6, lines = $$props.lines);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('it' in $$props) $$invalidate(2, it = $$props.it);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*vgap, lines, line*/ 97) {
    			mkcss();
    		}

    		if ($$self.$$.dirty & /*limit, items*/ 24) {
    			$$invalidate(2, it = limit ? items.slice(0, limit) : items);
    		}
    	};

    	return [line, style, it, items, limit, vgap, lines, slots, $$scope];
    }

    class Wrapper extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {
    			items: 3,
    			limit: 4,
    			vgap: 5,
    			line: 0,
    			lines: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Wrapper",
    			options,
    			id: create_fragment$Z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*items*/ ctx[3] === undefined && !('items' in props)) {
    			console.warn("<Wrapper> was created without expected prop 'items'");
    		}
    	}

    	get items() {
    		throw new Error("<Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get limit() {
    		throw new Error("<Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set limit(value) {
    		throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vgap() {
    		throw new Error("<Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vgap(value) {
    		throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get line() {
    		throw new Error("<Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set line(value) {
    		throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lines() {
    		throw new Error("<Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lines(value) {
    		throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/wideui/RecentPages.svelte generated by Svelte v3.44.3 */

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    // (38:2) <svelte:fragment slot="title">
    function create_title_slot$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*title*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 2) set_data_dev(t, /*title*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$2.name,
    		type: "slot",
    		source: "(38:2) <svelte:fragment slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (44:4) {:else}
    function create_else_block$a(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*recents*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*recents, fmt*/ 36) {
    				each_value = /*recents*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(44:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (40:4) {#if compact}
    function create_if_block$k(ctx) {
    	let wrapper;
    	let current;

    	wrapper = new Wrapper({
    			props: {
    				items: /*recents*/ ctx[2],
    				line: "s1",
    				lines: 3,
    				$$slots: {
    					default: [
    						create_default_slot$r,
    						({ item: page }) => ({ 12: page }),
    						({ item: page }) => page ? 4096 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(wrapper.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(wrapper, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const wrapper_changes = {};
    			if (dirty & /*recents*/ 4) wrapper_changes.items = /*recents*/ ctx[2];

    			if (dirty & /*$$scope, page*/ 36864) {
    				wrapper_changes.$$scope = { dirty, ctx };
    			}

    			wrapper.$set(wrapper_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wrapper.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wrapper.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(wrapper, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(40:4) {#if compact}",
    		ctx
    	});

    	return block;
    }

    // (47:10) <FB c="recent-title">
    function create_default_slot_5$a(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				nored: true,
    				space: /*page*/ ctx[12].namespace,
    				title: /*page*/ ctx[12].title
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*recents*/ 4) link_changes.space = /*page*/ ctx[12].namespace;
    			if (dirty & /*recents*/ 4) link_changes.title = /*page*/ ctx[12].title;
    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$a.name,
    		type: "slot",
    		source: "(47:10) <FB c=\\\"recent-title\\\">",
    		ctx
    	});

    	return block;
    }

    // (51:12) <FB c="recent-date">
    function create_default_slot_4$a(ctx) {
    	let t_value = /*fmt*/ ctx[5](/*page*/ ctx[12].createdAt) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*recents*/ 4 && t_value !== (t_value = /*fmt*/ ctx[5](/*page*/ ctx[12].createdAt) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$a.name,
    		type: "slot",
    		source: "(51:12) <FB c=\\\"recent-date\\\">",
    		ctx
    	});

    	return block;
    }

    // (52:12) <FB c="recent-user">
    function create_default_slot_3$d(ctx) {
    	let t0;
    	let t1_value = /*page*/ ctx[12].user.handle + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text("(");
    			t1 = text(t1_value);
    			t2 = text(")");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*recents*/ 4 && t1_value !== (t1_value = /*page*/ ctx[12].user.handle + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$d.name,
    		type: "slot",
    		source: "(52:12) <FB c=\\\"recent-user\\\">",
    		ctx
    	});

    	return block;
    }

    // (50:10) <FB c="recent-extra">
    function create_default_slot_2$g(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				c: "recent-date",
    				$$slots: { default: [create_default_slot_4$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				c: "recent-user",
    				$$slots: { default: [create_default_slot_3$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope, recents*/ 32772) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope, recents*/ 32772) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$g.name,
    		type: "slot",
    		source: "(50:10) <FB c=\\\"recent-extra\\\">",
    		ctx
    	});

    	return block;
    }

    // (46:8) <FB zero vert c="recent-page">
    function create_default_slot_1$j(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let current;

    	fb0 = new FB({
    			props: {
    				c: "recent-title",
    				$$slots: { default: [create_default_slot_5$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				c: "recent-extra",
    				$$slots: { default: [create_default_slot_2$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope, recents*/ 32772) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope, recents*/ 32772) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$j.name,
    		type: "slot",
    		source: "(46:8) <FB zero vert c=\\\"recent-page\\\">",
    		ctx
    	});

    	return block;
    }

    // (45:6) {#each recents as page}
    function create_each_block$8(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				zero: true,
    				vert: true,
    				c: "recent-page",
    				$$slots: { default: [create_default_slot_1$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, recents*/ 32772) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(45:6) {#each recents as page}",
    		ctx
    	});

    	return block;
    }

    // (41:6) <Wrapper items={recents} line="s1" lines={3} let:item={page}>
    function create_default_slot$r(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				nored: true,
    				space: /*page*/ ctx[12].namespace,
    				title: /*page*/ ctx[12].title
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*page*/ 4096) link_changes.space = /*page*/ ctx[12].namespace;
    			if (dirty & /*page*/ 4096) link_changes.title = /*page*/ ctx[12].title;
    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$r.name,
    		type: "slot",
    		source: "(41:6) <Wrapper items={recents} line=\\\"s1\\\" lines={3} let:item={page}>",
    		ctx
    	});

    	return block;
    }

    // (39:2) <svelte:fragment slot="body">
    function create_body_slot$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$k, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*compact*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$2.name,
    		type: "slot",
    		source: "(39:2) <svelte:fragment slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Y(ctx) {
    	let wuimodule;
    	let current;

    	wuimodule = new WUIModule({
    			props: {
    				c: /*c*/ ctx[3],
    				$$slots: {
    					body: [create_body_slot$2],
    					title: [create_title_slot$2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(wuimodule.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(wuimodule, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const wuimodule_changes = {};
    			if (dirty & /*c*/ 8) wuimodule_changes.c = /*c*/ ctx[3];

    			if (dirty & /*$$scope, recents, compact, title*/ 32775) {
    				wuimodule_changes.$$scope = { dirty, ctx };
    			}

    			wuimodule.$set(wuimodule_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wuimodule.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wuimodule.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(wuimodule, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let $aod;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RecentPages', slots, []);
    	const grab = getContext('grab');
    	const handle = getContext('handle');
    	const aod = getContext('aod');
    	validate_store(aod, 'aod');
    	component_subscribe($$self, aod, value => $$invalidate(7, $aod = value));
    	let { count = null } = $$props;
    	let { compact = false } = $$props;
    	let { title = compact ? 'RECENT' : 'RECENT PAGES' } = $$props;
    	let recents = [];

    	const refresh = () => {
    		const a = ['recent'];
    		if (count) a.push(count);

    		return grab(...a).then(res => {
    			if (res.err == 0) $$invalidate(2, recents = res.val);
    		}).catch(e => handle(e));
    	};

    	const fmt = s => {
    		const d = new Date(s);
    		return date$1.format(d, 'ddd, MMM DD YYYY');
    	};

    	let c = [];

    	const mkc = () => {
    		const cb = ['recent-pages'];
    		if (compact) cb.push('recent-compact');
    		$$invalidate(3, c = cb);
    	};

    	const writable_props = ['count', 'compact', 'title'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RecentPages> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('count' in $$props) $$invalidate(6, count = $$props.count);
    		if ('compact' in $$props) $$invalidate(0, compact = $$props.compact);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		Link: Link$1,
    		Wrapper,
    		WUIModule,
    		date: date$1,
    		getContext,
    		grab,
    		handle,
    		aod,
    		count,
    		compact,
    		title,
    		recents,
    		refresh,
    		fmt,
    		c,
    		mkc,
    		$aod
    	});

    	$$self.$inject_state = $$props => {
    		if ('count' in $$props) $$invalidate(6, count = $$props.count);
    		if ('compact' in $$props) $$invalidate(0, compact = $$props.compact);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('recents' in $$props) $$invalidate(2, recents = $$props.recents);
    		if ('c' in $$props) $$invalidate(3, c = $$props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$aod, count*/ 192) {
    			refresh();
    		}

    		if ($$self.$$.dirty & /*compact*/ 1) {
    			mkc();
    		}
    	};

    	return [compact, title, recents, c, aod, fmt, count, $aod];
    }

    class RecentPages extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, { count: 6, compact: 0, title: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RecentPages",
    			options,
    			id: create_fragment$Y.name
    		});
    	}

    	get count() {
    		throw new Error("<RecentPages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<RecentPages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get compact() {
    		throw new Error("<RecentPages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set compact(value) {
    		throw new Error("<RecentPages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<RecentPages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<RecentPages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Visibility.svelte generated by Svelte v3.44.3 */
    const file$B = "src/Visibility.svelte";

    function create_fragment$X(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "visibility-wrapper");
    			toggle_class(div, "visfull", !!/*$visible*/ ctx[2]);
    			toggle_class(div, "vispart", !/*$visible*/ ctx[2]);
    			toggle_class(div, "ghost", /*ghost*/ ctx[0] && !/*$visible*/ ctx[2]);
    			add_location(div, file$B, 31, 0, 779);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[6](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (dirty & /*$visible*/ 4) {
    				toggle_class(div, "visfull", !!/*$visible*/ ctx[2]);
    			}

    			if (dirty & /*$visible*/ 4) {
    				toggle_class(div, "vispart", !/*$visible*/ ctx[2]);
    			}

    			if (dirty & /*ghost, $visible*/ 5) {
    				toggle_class(div, "ghost", /*ghost*/ ctx[0] && !/*$visible*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[6](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let $visible;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Visibility', slots, ['default']);
    	const dispatch = createEventDispatcher();
    	let { ghost = false } = $$props;
    	let watcher;
    	let watched;
    	let visible = writable(true);
    	validate_store(visible, 'visible');
    	component_subscribe($$self, visible, value => $$invalidate(2, $visible = value));
    	setContext('visible', visible);

    	onMount(() => {
    		watcher = new IntersectionObserver((entries, obs) => {
    				const ir = entries[entries.length - 1].intersectionRatio;
    				const vis = ir >= 1;
    				if (vis && !$visible) dispatch('visible', true);
    				if (!vis && !!$visible) dispatch('visible', false);
    				set_store_value(visible, $visible = vis, $visible);
    			},
    		{ rootMargin: '0px', threshold: 0.99 });

    		watcher.observe(watched);
    	});

    	onDestroy(() => {
    		watcher.disconnect();
    	});

    	const writable_props = ['ghost'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Visibility> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			watched = $$value;
    			$$invalidate(1, watched);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('ghost' in $$props) $$invalidate(0, ghost = $$props.ghost);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		setContext,
    		onMount,
    		onDestroy,
    		createEventDispatcher,
    		writable,
    		dispatch,
    		ghost,
    		watcher,
    		watched,
    		visible,
    		$visible
    	});

    	$$self.$inject_state = $$props => {
    		if ('ghost' in $$props) $$invalidate(0, ghost = $$props.ghost);
    		if ('watcher' in $$props) watcher = $$props.watcher;
    		if ('watched' in $$props) $$invalidate(1, watched = $$props.watched);
    		if ('visible' in $$props) $$invalidate(3, visible = $$props.visible);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [ghost, watched, $visible, visible, $$scope, slots, div_binding];
    }

    class Visibility extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$X, safe_not_equal, { ghost: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Visibility",
    			options,
    			id: create_fragment$X.name
    		});
    	}

    	get ghost() {
    		throw new Error("<Visibility>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ghost(value) {
    		throw new Error("<Visibility>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/wideui/Bookmarks.svelte generated by Svelte v3.44.3 */

    // (10:2) <svelte:fragment slot="title">
    function create_title_slot$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("BOOKMARKS");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$1.name,
    		type: "slot",
    		source: "(10:2) <svelte:fragment slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (14:4) <Wrapper {items} line="s1" lines={3} let:item={nst}>
    function create_default_slot$q(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: { nst: /*nst*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*nst*/ 2) link_changes.nst = /*nst*/ ctx[1];
    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$q.name,
    		type: "slot",
    		source: "(14:4) <Wrapper {items} line=\\\"s1\\\" lines={3} let:item={nst}>",
    		ctx
    	});

    	return block;
    }

    // (13:2) <svelte:fragment slot="body">
    function create_body_slot$1(ctx) {
    	let wrapper;
    	let current;

    	wrapper = new Wrapper({
    			props: {
    				items: /*items*/ ctx[0],
    				line: "s1",
    				lines: 3,
    				$$slots: {
    					default: [
    						create_default_slot$q,
    						({ item: nst }) => ({ 1: nst }),
    						({ item: nst }) => nst ? 2 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(wrapper.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(wrapper, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const wrapper_changes = {};
    			if (dirty & /*items*/ 1) wrapper_changes.items = /*items*/ ctx[0];

    			if (dirty & /*$$scope, nst*/ 6) {
    				wrapper_changes.$$scope = { dirty, ctx };
    			}

    			wrapper.$set(wrapper_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wrapper.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wrapper.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(wrapper, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$1.name,
    		type: "slot",
    		source: "(13:2) <svelte:fragment slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$W(ctx) {
    	let wuimodule;
    	let current;

    	wuimodule = new WUIModule({
    			props: {
    				$$slots: {
    					body: [create_body_slot$1],
    					title: [create_title_slot$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(wuimodule.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(wuimodule, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const wuimodule_changes = {};

    			if (dirty & /*$$scope, items*/ 5) {
    				wuimodule_changes.$$scope = { dirty, ctx };
    			}

    			wuimodule.$set(wuimodule_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wuimodule.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wuimodule.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(wuimodule, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Bookmarks', slots, []);
    	let { items } = $$props;
    	const writable_props = ['items'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Bookmarks> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('items' in $$props) $$invalidate(0, items = $$props.items);
    	};

    	$$self.$capture_state = () => ({ FB, Link: Link$1, Wrapper, WUIModule, items });

    	$$self.$inject_state = $$props => {
    		if ('items' in $$props) $$invalidate(0, items = $$props.items);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [items];
    }

    class Bookmarks extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$W, safe_not_equal, { items: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Bookmarks",
    			options,
    			id: create_fragment$W.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*items*/ ctx[0] === undefined && !('items' in props)) {
    			console.warn("<Bookmarks> was created without expected prop 'items'");
    		}
    	}

    	get items() {
    		throw new Error("<Bookmarks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Bookmarks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/wideui/Navigator.svelte generated by Svelte v3.44.3 */

    function create_fragment$V(ctx) {
    	let bookmarks_1;
    	let t;
    	let recentpages;
    	let current;

    	bookmarks_1 = new Bookmarks({
    			props: {
    				items: /*bookmarks*/ ctx[0],
    				limit: 12,
    				lines: 3
    			},
    			$$inline: true
    		});

    	recentpages = new RecentPages({
    			props: { compact: true, count: 10 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(bookmarks_1.$$.fragment);
    			t = space();
    			create_component(recentpages.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(bookmarks_1, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(recentpages, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(bookmarks_1.$$.fragment, local);
    			transition_in(recentpages.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(bookmarks_1.$$.fragment, local);
    			transition_out(recentpages.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(bookmarks_1, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(recentpages, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Navigator', slots, []);

    	let bookmarks = [
    		'Home',
    		'foo',
    		'bar',
    		'CPB:test',
    		'CPB:forms',
    		'CPB:user',
    		'CPB:login',
    		'scop:uli',
    		'foo:bar',
    		'foo:baz',
    		'A Much Longer Title Than The Last One With Capitals'
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Navigator> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		FB,
    		Link: Link$1,
    		WUIModule,
    		RecentPages,
    		Bookmarks,
    		bookmarks
    	});

    	$$self.$inject_state = $$props => {
    		if ('bookmarks' in $$props) $$invalidate(0, bookmarks = $$props.bookmarks);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [bookmarks];
    }

    class Navigator extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$V, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navigator",
    			options,
    			id: create_fragment$V.name
    		});
    	}
    }

    /* src/WideUI.svelte generated by Svelte v3.44.3 */

    // (26:0) {#if $ui >= 2}
    function create_if_block$j(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				c: "wide-ui",
    				ghost: /*ghost*/ ctx[0],
    				$$slots: { default: [create_default_slot$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};
    			if (dirty & /*ghost*/ 1) fb_changes.ghost = /*ghost*/ ctx[0];

    			if (dirty & /*$$scope, $state, $ui*/ 70) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(26:0) {#if $ui >= 2}",
    		ctx
    	});

    	return block;
    }

    // (31:4) <FB c="sbwrap">
    function create_default_slot_7$8(ctx) {
    	let searchbar;
    	let current;

    	searchbar = new SearchBar({
    			props: {
    				preview: true,
    				auto: true,
    				inf: "title",
    				szOpt: 5
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(searchbar.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(searchbar, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(searchbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(searchbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(searchbar, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$8.name,
    		type: "slot",
    		source: "(31:4) <FB c=\\\"sbwrap\\\">",
    		ctx
    	});

    	return block;
    }

    // (29:2) <FB vert zero c="wide-head">
    function create_default_slot_6$8(ctx) {
    	let userbar;
    	let t;
    	let fb;
    	let current;
    	userbar = new UserBar({ props: { mini: true }, $$inline: true });

    	fb = new FB({
    			props: {
    				c: "sbwrap",
    				$$slots: { default: [create_default_slot_7$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(userbar.$$.fragment);
    			t = space();
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(userbar, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(userbar.$$.fragment, local);
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(userbar.$$.fragment, local);
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(userbar, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$8.name,
    		type: "slot",
    		source: "(29:2) <FB vert zero c=\\\"wide-head\\\">",
    		ctx
    	});

    	return block;
    }

    // (36:2) {#if $ui >= 3}
    function create_if_block_3$5(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				c: "wide-menu",
    				$$slots: { default: [create_default_slot_5$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({ props: { spacer: 1 }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(36:2) {#if $ui >= 3}",
    		ctx
    	});

    	return block;
    }

    // (37:4) <FB c="wide-menu">
    function create_default_slot_5$9(ctx) {
    	let bookmarks_1;
    	let current;

    	bookmarks_1 = new Bookmarks({
    			props: { items: /*bookmarks*/ ctx[5], limit: null },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(bookmarks_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(bookmarks_1, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(bookmarks_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(bookmarks_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(bookmarks_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$9.name,
    		type: "slot",
    		source: "(37:4) <FB c=\\\"wide-menu\\\">",
    		ctx
    	});

    	return block;
    }

    // (47:8) {#if $ui <= 2}
    function create_if_block_2$6(ctx) {
    	let navigator;
    	let current;
    	navigator = new Navigator({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(navigator.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navigator, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navigator.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navigator.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navigator, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(47:8) {#if $ui <= 2}",
    		ctx
    	});

    	return block;
    }

    // (46:6) <FB vert c="wide-col wide-col1">
    function create_default_slot_4$9(ctx) {
    	let t;
    	let wuitoc;
    	let current;
    	let if_block = /*$ui*/ ctx[1] <= 2 && create_if_block_2$6(ctx);
    	wuitoc = new WUITOC({ $$inline: true });

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(wuitoc.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(wuitoc, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$ui*/ ctx[1] <= 2) {
    				if (if_block) {
    					if (dirty & /*$ui*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(wuitoc.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(wuitoc.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(wuitoc, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$9.name,
    		type: "slot",
    		source: "(46:6) <FB vert c=\\\"wide-col wide-col1\\\">",
    		ctx
    	});

    	return block;
    }

    // (51:6) {#if $ui >= 3}
    function create_if_block_1$a(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				c: "wide-col wide-col2",
    				$$slots: { default: [create_default_slot_3$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(51:6) {#if $ui >= 3}",
    		ctx
    	});

    	return block;
    }

    // (52:8) <FB vert c="wide-col wide-col2">
    function create_default_slot_3$c(ctx) {
    	let recentpages;
    	let current;
    	recentpages = new RecentPages({ props: { count: 10 }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(recentpages.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(recentpages, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(recentpages.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(recentpages.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(recentpages, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$c.name,
    		type: "slot",
    		source: "(52:8) <FB vert c=\\\"wide-col wide-col2\\\">",
    		ctx
    	});

    	return block;
    }

    // (44:4) <R2Hider hide={!$state.finished}>
    function create_default_slot_2$f(ctx) {
    	let fb;
    	let t;
    	let if_block_anchor;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				c: "wide-col wide-col1",
    				$$slots: { default: [create_default_slot_4$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$ui*/ ctx[1] >= 3 && create_if_block_1$a(ctx);

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, $ui*/ 66) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);

    			if (/*$ui*/ ctx[1] >= 3) {
    				if (if_block) {
    					if (dirty & /*$ui*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$f.name,
    		type: "slot",
    		source: "(44:4) <R2Hider hide={!$state.finished}>",
    		ctx
    	});

    	return block;
    }

    // (43:2) <FB c="wide-body">
    function create_default_slot_1$i(ctx) {
    	let r2hider;
    	let current;

    	r2hider = new R2Hider({
    			props: {
    				hide: !/*$state*/ ctx[2].finished,
    				$$slots: { default: [create_default_slot_2$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(r2hider.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(r2hider, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const r2hider_changes = {};
    			if (dirty & /*$state*/ 4) r2hider_changes.hide = !/*$state*/ ctx[2].finished;

    			if (dirty & /*$$scope, $ui*/ 66) {
    				r2hider_changes.$$scope = { dirty, ctx };
    			}

    			r2hider.$set(r2hider_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(r2hider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(r2hider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(r2hider, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$i.name,
    		type: "slot",
    		source: "(43:2) <FB c=\\\"wide-body\\\">",
    		ctx
    	});

    	return block;
    }

    // (27:0) <FB vert c="wide-ui" {ghost}>
    function create_default_slot$p(ctx) {
    	let fb0;
    	let t0;
    	let t1;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				vert: true,
    				zero: true,
    				c: "wide-head",
    				$$slots: { default: [create_default_slot_6$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$ui*/ ctx[1] >= 3 && create_if_block_3$5(ctx);

    	fb1 = new FB({
    			props: {
    				c: "wide-body",
    				$$slots: { default: [create_default_slot_1$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);

    			if (/*$ui*/ ctx[1] >= 3) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$ui*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t1.parentNode, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const fb1_changes = {};

    			if (dirty & /*$$scope, $state, $ui*/ 70) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$p.name,
    		type: "slot",
    		source: "(27:0) <FB vert c=\\\"wide-ui\\\" {ghost}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$U(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$ui*/ ctx[1] >= 2 && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$ui*/ ctx[1] >= 2) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$ui*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$j(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let $ui;
    	let $state;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('WideUI', slots, []);
    	const state = getContext('state');
    	validate_store(state, 'state');
    	component_subscribe($$self, state, value => $$invalidate(2, $state = value));
    	const ui = getContext('ui');
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, value => $$invalidate(1, $ui = value));
    	let { ghost = false } = $$props;

    	let bookmarks = [
    		'Home',
    		'foo',
    		'bar',
    		'CPB:test',
    		'CPB:forms',
    		'CPB:user',
    		'CPB:login',
    		'scop:uli',
    		'foo:bar',
    		'foo:baz'
    	];

    	const writable_props = ['ghost'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<WideUI> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('ghost' in $$props) $$invalidate(0, ghost = $$props.ghost);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		WUITOC,
    		RecentPages,
    		SearchBar,
    		Text: Text$1,
    		Visibility,
    		R2Hider,
    		Navigator,
    		Bookmarks,
    		UserBar,
    		Messenger,
    		getContext,
    		state,
    		ui,
    		ghost,
    		bookmarks,
    		$ui,
    		$state
    	});

    	$$self.$inject_state = $$props => {
    		if ('ghost' in $$props) $$invalidate(0, ghost = $$props.ghost);
    		if ('bookmarks' in $$props) $$invalidate(5, bookmarks = $$props.bookmarks);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [ghost, $ui, $state, state, ui, bookmarks];
    }

    class WideUI extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$U, safe_not_equal, { ghost: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WideUI",
    			options,
    			id: create_fragment$U.name
    		});
    	}

    	get ghost() {
    		throw new Error("<WideUI>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ghost(value) {
    		throw new Error("<WideUI>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Contents.svelte generated by Svelte v3.44.3 */
    const file$A = "src/Contents.svelte";

    // (69:0) {#if !$loading}
    function create_if_block$i(ctx) {
    	let bodyframe;
    	let t;
    	let footer;
    	let current;
    	bodyframe = new Bodyframe({ $$inline: true });
    	footer = new Footer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(bodyframe.$$.fragment);
    			t = space();
    			create_component(footer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(bodyframe, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(bodyframe.$$.fragment, local);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(bodyframe.$$.fragment, local);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(bodyframe, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(69:0) {#if !$loading}",
    		ctx
    	});

    	return block;
    }

    // (67:0) <R2Hider hide={!$state.finished}>
    function create_default_slot_1$h(ctx) {
    	let div;
    	let t;
    	let if_block_anchor;
    	let current;
    	let if_block = !/*$loading*/ ctx[4] && create_if_block$i(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    			attr_dev(div, "class", "watermargin");
    			add_location(div, file$A, 67, 0, 2025);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[18](div);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*$loading*/ ctx[4]) {
    				if (if_block) {
    					if (dirty & /*$loading*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$i(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[18](null);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$h.name,
    		type: "slot",
    		source: "(67:0) <R2Hider hide={!$state.finished}>",
    		ctx
    	});

    	return block;
    }

    // (66:0) <FB vert expand c="cpb-content {editmode}" bind:element={element}>
    function create_default_slot$o(ctx) {
    	let r2hider;
    	let current;

    	r2hider = new R2Hider({
    			props: {
    				hide: !/*$state*/ ctx[3].finished,
    				$$slots: { default: [create_default_slot_1$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(r2hider.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(r2hider, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const r2hider_changes = {};
    			if (dirty & /*$state*/ 8) r2hider_changes.hide = !/*$state*/ ctx[3].finished;

    			if (dirty & /*$$scope, $loading, waterm*/ 268435474) {
    				r2hider_changes.$$scope = { dirty, ctx };
    			}

    			r2hider.$set(r2hider_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(r2hider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(r2hider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(r2hider, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$o.name,
    		type: "slot",
    		source: "(66:0) <FB vert expand c=\\\"cpb-content {editmode}\\\" bind:element={element}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$T(ctx) {
    	let fb;
    	let updating_element;
    	let current;

    	function fb_element_binding(value) {
    		/*fb_element_binding*/ ctx[19](value);
    	}

    	let fb_props = {
    		vert: true,
    		expand: true,
    		c: "cpb-content " + /*editmode*/ ctx[2],
    		$$slots: { default: [create_default_slot$o] },
    		$$scope: { ctx }
    	};

    	if (/*element*/ ctx[0] !== void 0) {
    		fb_props.element = /*element*/ ctx[0];
    	}

    	fb = new FB({ props: fb_props, $$inline: true });
    	binding_callbacks.push(() => bind(fb, 'element', fb_element_binding));

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*editmode*/ 4) fb_changes.c = "cpb-content " + /*editmode*/ ctx[2];

    			if (dirty & /*$$scope, $state, $loading, waterm*/ 268435482) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_element && dirty & /*element*/ 1) {
    				updating_element = true;
    				fb_changes.element = /*element*/ ctx[0];
    				add_flush_callback(() => updating_element = false);
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let editmode;
    	let $creating;
    	let $editing;
    	let $state;
    	let $loading;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Contents', slots, []);
    	const path = getContext('path');
    	const loading = getContext('loading');
    	validate_store(loading, 'loading');
    	component_subscribe($$self, loading, value => $$invalidate(4, $loading = value));
    	const finished = getContext('finished');
    	const editing = getContext('editing');
    	validate_store(editing, 'editing');
    	component_subscribe($$self, editing, value => $$invalidate(17, $editing = value));
    	const creating = getContext('creating');
    	validate_store(creating, 'creating');
    	component_subscribe($$self, creating, value => $$invalidate(16, $creating = value));
    	const hashistory = getContext('hashistory');
    	const updatescroll = getContext('updatescroll');
    	const state = getContext('state');
    	validate_store(state, 'state');
    	component_subscribe($$self, state, value => $$invalidate(3, $state = value));
    	const loc = getContext('loc');
    	const rc = getContext('rc');
    	let element;
    	let waterm;
    	let ch = 0;
    	let sh = 0;
    	let sy = 0;
    	let { scrollable = false } = $$props;
    	let scrolled = false;

    	const top = () => {
    		if (element) element.scrollTo({ top: 0, behavior: 'smooth' });
    	};

    	const calcscroll = () => {
    		if (element) {
    			$$invalidate(11, ch = element.clientHeight);
    			$$invalidate(12, sh = element.scrollHeight);
    			$$invalidate(13, sy = element.scrollTop);
    			$$invalidate(9, scrollable = sh > ch);
    			updatescroll(ch, sh, sy, scrollable, scrolled);
    		}
    	};

    	const mobserver = new MutationObserver((list, obs) => {
    			let calc = false;

    			list.forEach(m => {
    				if (m.type === 'childList') {
    					calc = true;
    				}
    			});

    			if (calc) calcscroll();
    		});

    	let iobserver;
    	const writable_props = ['scrollable'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Contents> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			waterm = $$value;
    			$$invalidate(1, waterm);
    		});
    	}

    	function fb_element_binding(value) {
    		element = value;
    		$$invalidate(0, element);
    	}

    	$$self.$$set = $$props => {
    		if ('scrollable' in $$props) $$invalidate(9, scrollable = $$props.scrollable);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		R2,
    		R2Hider,
    		Titleframe,
    		Bodyframe,
    		Footer,
    		getContext,
    		path,
    		loading,
    		finished,
    		editing,
    		creating,
    		hashistory,
    		updatescroll,
    		state,
    		loc,
    		rc,
    		element,
    		waterm,
    		ch,
    		sh,
    		sy,
    		scrollable,
    		scrolled,
    		top,
    		calcscroll,
    		mobserver,
    		iobserver,
    		editmode,
    		$creating,
    		$editing,
    		$state,
    		$loading
    	});

    	$$self.$inject_state = $$props => {
    		if ('element' in $$props) $$invalidate(0, element = $$props.element);
    		if ('waterm' in $$props) $$invalidate(1, waterm = $$props.waterm);
    		if ('ch' in $$props) $$invalidate(11, ch = $$props.ch);
    		if ('sh' in $$props) $$invalidate(12, sh = $$props.sh);
    		if ('sy' in $$props) $$invalidate(13, sy = $$props.sy);
    		if ('scrollable' in $$props) $$invalidate(9, scrollable = $$props.scrollable);
    		if ('scrolled' in $$props) $$invalidate(14, scrolled = $$props.scrolled);
    		if ('iobserver' in $$props) $$invalidate(15, iobserver = $$props.iobserver);
    		if ('editmode' in $$props) $$invalidate(2, editmode = $$props.editmode);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$editing, $creating*/ 196608) {
    			$$invalidate(2, editmode = !!$editing || !!$creating ? 'edit-mode' : '');
    		}

    		if ($$self.$$.dirty & /*element*/ 1) {
    			if (element) {
    				mobserver.observe(element, { childList: true, subtree: true });
    			} else mobserver.disconnect();
    		}

    		if ($$self.$$.dirty & /*element, waterm, ch, sh, sy, scrollable, scrolled, iobserver*/ 64003) {
    			if (element && waterm) {
    				$$invalidate(15, iobserver = new IntersectionObserver((entries, obs) => {
    						const ir = entries[entries.length - 1].intersectionRatio;
    						$$invalidate(14, scrolled = ir < 0.1);
    						updatescroll(ch, sh, sy, scrollable, scrolled);
    					},
    				{
    						root: element,
    						rootMargin: '0px',
    						threshold: 0.1
    					}));

    				iobserver.observe(waterm);
    			} else if (iobserver) iobserver.disconnect();
    		}
    	};

    	return [
    		element,
    		waterm,
    		editmode,
    		$state,
    		$loading,
    		loading,
    		editing,
    		creating,
    		state,
    		scrollable,
    		top,
    		ch,
    		sh,
    		sy,
    		scrolled,
    		iobserver,
    		$creating,
    		$editing,
    		div_binding,
    		fb_element_binding
    	];
    }

    class Contents extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, { scrollable: 9, top: 10 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Contents",
    			options,
    			id: create_fragment$T.name
    		});
    	}

    	get scrollable() {
    		throw new Error("<Contents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrollable(value) {
    		throw new Error("<Contents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get top() {
    		return this.$$.ctx[10];
    	}

    	set top(value) {
    		throw new Error("<Contents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/hex/Hexline.svelte generated by Svelte v3.44.3 */
    const file$z = "src/hex/Hexline.svelte";

    // (9:0) <FB c="hexline" zero>
    function create_default_slot$n(ctx) {
    	let div0;
    	let t0;
    	let fb;
    	let t1;
    	let div1;
    	let current;

    	fb = new FB({
    			props: {
    				expand: true,
    				c: "seg",
    				ghost: !/*solid*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			create_component(fb.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "seg wing");
    			add_location(div0, file$z, 9, 2, 213);
    			attr_dev(div1, "class", "seg wing");
    			add_location(div1, file$z, 11, 2, 282);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb, target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};
    			if (dirty & /*solid*/ 1) fb_changes.ghost = !/*solid*/ ctx[0];
    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$n.name,
    		type: "slot",
    		source: "(9:0) <FB c=\\\"hexline\\\" zero>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$S(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: "hexline",
    				zero: true,
    				$$slots: { default: [create_default_slot$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, solid*/ 17) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let solid;
    	let $hexn;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Hexline', slots, []);
    	const hexn = getContext('hexn');
    	validate_store(hexn, 'hexn');
    	component_subscribe($$self, hexn, value => $$invalidate(3, $hexn = value));
    	let { mask = 0b000000 } = $$props;
    	const writable_props = ['mask'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Hexline> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('mask' in $$props) $$invalidate(2, mask = $$props.mask);
    	};

    	$$self.$capture_state = () => ({ FB, getContext, hexn, mask, solid, $hexn });

    	$$self.$inject_state = $$props => {
    		if ('mask' in $$props) $$invalidate(2, mask = $$props.mask);
    		if ('solid' in $$props) $$invalidate(0, solid = $$props.solid);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$hexn, mask*/ 12) {
    			$$invalidate(0, solid = ($hexn & mask) == mask);
    		}
    	};

    	return [solid, hexn, mask, $hexn];
    }

    class Hexline extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, { mask: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Hexline",
    			options,
    			id: create_fragment$S.name
    		});
    	}

    	get mask() {
    		throw new Error("<Hexline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mask(value) {
    		throw new Error("<Hexline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/hex/Hexagram.svelte generated by Svelte v3.44.3 */

    // (59:2) {:else}
    function create_else_block$9(ctx) {
    	let hexline0;
    	let t0;
    	let hexline1;
    	let t1;
    	let hexline2;
    	let t2;
    	let hexline3;
    	let t3;
    	let hexline4;
    	let t4;
    	let hexline5;
    	let current;

    	hexline0 = new Hexline({
    			props: { mask: 0b000001 },
    			$$inline: true
    		});

    	hexline1 = new Hexline({
    			props: { mask: 0b000010 },
    			$$inline: true
    		});

    	hexline2 = new Hexline({
    			props: { mask: 0b000100 },
    			$$inline: true
    		});

    	hexline3 = new Hexline({
    			props: { mask: 0b001000 },
    			$$inline: true
    		});

    	hexline4 = new Hexline({
    			props: { mask: 0b010000 },
    			$$inline: true
    		});

    	hexline5 = new Hexline({
    			props: { mask: 0b100000 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hexline0.$$.fragment);
    			t0 = space();
    			create_component(hexline1.$$.fragment);
    			t1 = space();
    			create_component(hexline2.$$.fragment);
    			t2 = space();
    			create_component(hexline3.$$.fragment);
    			t3 = space();
    			create_component(hexline4.$$.fragment);
    			t4 = space();
    			create_component(hexline5.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hexline0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(hexline1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(hexline2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(hexline3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(hexline4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(hexline5, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hexline0.$$.fragment, local);
    			transition_in(hexline1.$$.fragment, local);
    			transition_in(hexline2.$$.fragment, local);
    			transition_in(hexline3.$$.fragment, local);
    			transition_in(hexline4.$$.fragment, local);
    			transition_in(hexline5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hexline0.$$.fragment, local);
    			transition_out(hexline1.$$.fragment, local);
    			transition_out(hexline2.$$.fragment, local);
    			transition_out(hexline3.$$.fragment, local);
    			transition_out(hexline4.$$.fragment, local);
    			transition_out(hexline5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hexline0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(hexline1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(hexline2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(hexline3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(hexline4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(hexline5, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(59:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (50:23) 
    function create_if_block_3$4(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: "hg-outline",
    				vert: true,
    				zero: true,
    				solid: true,
    				$$slots: { default: [create_default_slot_7$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(50:23) ",
    		ctx
    	});

    	return block;
    }

    // (49:2) {#if dummy}
    function create_if_block_2$5(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(49:2) {#if dummy}",
    		ctx
    	});

    	return block;
    }

    // (51:4) <FB c="hg-outline" vert zero solid>
    function create_default_slot_7$7(ctx) {
    	let hexline0;
    	let t0;
    	let hexline1;
    	let t1;
    	let hexline2;
    	let t2;
    	let hexline3;
    	let t3;
    	let hexline4;
    	let t4;
    	let hexline5;
    	let current;

    	hexline0 = new Hexline({
    			props: { mask: 0b000001 },
    			$$inline: true
    		});

    	hexline1 = new Hexline({
    			props: { mask: 0b000010 },
    			$$inline: true
    		});

    	hexline2 = new Hexline({
    			props: { mask: 0b000100 },
    			$$inline: true
    		});

    	hexline3 = new Hexline({
    			props: { mask: 0b001000 },
    			$$inline: true
    		});

    	hexline4 = new Hexline({
    			props: { mask: 0b010000 },
    			$$inline: true
    		});

    	hexline5 = new Hexline({
    			props: { mask: 0b100000 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hexline0.$$.fragment);
    			t0 = space();
    			create_component(hexline1.$$.fragment);
    			t1 = space();
    			create_component(hexline2.$$.fragment);
    			t2 = space();
    			create_component(hexline3.$$.fragment);
    			t3 = space();
    			create_component(hexline4.$$.fragment);
    			t4 = space();
    			create_component(hexline5.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hexline0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(hexline1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(hexline2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(hexline3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(hexline4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(hexline5, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hexline0.$$.fragment, local);
    			transition_in(hexline1.$$.fragment, local);
    			transition_in(hexline2.$$.fragment, local);
    			transition_in(hexline3.$$.fragment, local);
    			transition_in(hexline4.$$.fragment, local);
    			transition_in(hexline5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hexline0.$$.fragment, local);
    			transition_out(hexline1.$$.fragment, local);
    			transition_out(hexline2.$$.fragment, local);
    			transition_out(hexline3.$$.fragment, local);
    			transition_out(hexline4.$$.fragment, local);
    			transition_out(hexline5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hexline0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(hexline1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(hexline2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(hexline3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(hexline4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(hexline5, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$7.name,
    		type: "slot",
    		source: "(51:4) <FB c=\\\"hg-outline\\\" vert zero solid>",
    		ctx
    	});

    	return block;
    }

    // (67:2) {#if type}
    function create_if_block_1$9(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				title: true,
    				abs: true,
    				center: /*order*/ ctx[0] < 3,
    				around: /*order*/ ctx[0] > 2,
    				c: "hg-marker",
    				$$slots: { default: [create_default_slot_6$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};
    			if (dirty & /*order*/ 1) fb_changes.center = /*order*/ ctx[0] < 3;
    			if (dirty & /*order*/ 1) fb_changes.around = /*order*/ ctx[0] > 2;

    			if (dirty & /*$$scope, type*/ 262146) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(67:2) {#if type}",
    		ctx
    	});

    	return block;
    }

    // (68:4) <FB title abs center={order < 3} around={order > 2} c="hg-marker">
    function create_default_slot_6$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*type*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*type*/ 2) set_data_dev(t, /*type*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$7.name,
    		type: "slot",
    		source: "(68:4) <FB title abs center={order < 3} around={order > 2} c=\\\"hg-marker\\\">",
    		ctx
    	});

    	return block;
    }

    // (72:2) {#if nohex}
    function create_if_block$h(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				abs: true,
    				c: "hg-label",
    				$$slots: { default: [create_default_slot_1$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(72:2) {#if nohex}",
    		ctx
    	});

    	return block;
    }

    // (77:12) <FB center line="b2" reverse>
    function create_default_slot_5$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("無");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$8.name,
    		type: "slot",
    		source: "(77:12) <FB center line=\\\"b2\\\" reverse>",
    		ctx
    	});

    	return block;
    }

    // (76:10) <FB vert center c="hg-label-center">
    function create_default_slot_4$8(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				center: true,
    				line: "b2",
    				reverse: true,
    				$$slots: { default: [create_default_slot_5$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$8.name,
    		type: "slot",
    		source: "(76:10) <FB vert center c=\\\"hg-label-center\\\">",
    		ctx
    	});

    	return block;
    }

    // (75:8) <FB center>
    function create_default_slot_3$b(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				center: true,
    				c: "hg-label-center",
    				$$slots: { default: [create_default_slot_4$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$b.name,
    		type: "slot",
    		source: "(75:8) <FB center>",
    		ctx
    	});

    	return block;
    }

    // (74:6) <FB expand vert center c="hg-label-inner">
    function create_default_slot_2$e(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				center: true,
    				$$slots: { default: [create_default_slot_3$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$e.name,
    		type: "slot",
    		source: "(74:6) <FB expand vert center c=\\\"hg-label-inner\\\">",
    		ctx
    	});

    	return block;
    }

    // (73:4) <FB abs c="hg-label">
    function create_default_slot_1$g(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				expand: true,
    				vert: true,
    				center: true,
    				c: "hg-label-inner",
    				$$slots: { default: [create_default_slot_2$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$g.name,
    		type: "slot",
    		source: "(73:4) <FB abs c=\\\"hg-label\\\">",
    		ctx
    	});

    	return block;
    }

    // (48:0) <FB c={cls} vert zero solid rel>
    function create_default_slot$m(ctx) {
    	let current_block_type_index;
    	let if_block0;
    	let t0;
    	let t1;
    	let if_block2_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$5, create_if_block_3$4, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*dummy*/ ctx[2]) return 0;
    		if (/*order*/ ctx[0] == 3) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = /*type*/ ctx[1] && create_if_block_1$9(ctx);
    	let if_block2 = /*nohex*/ ctx[3] && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(t0.parentNode, t0);
    			}

    			if (/*type*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*type*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$9(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*nohex*/ ctx[3]) {
    				if (if_block2) {
    					if (dirty & /*nohex*/ 8) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$h(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$m.name,
    		type: "slot",
    		source: "(48:0) <FB c={cls} vert zero solid rel>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$R(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: /*cls*/ ctx[4],
    				vert: true,
    				zero: true,
    				solid: true,
    				rel: true,
    				$$slots: { default: [create_default_slot$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*cls*/ 16) fb_changes.c = /*cls*/ ctx[4];

    			if (dirty & /*$$scope, nohex, order, type, dummy*/ 262159) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let $hexn;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Hexagram', slots, []);
    	let { state = 0b000000 } = $$props;
    	let { rand = false } = $$props;
    	let { big = false } = $$props;
    	let { order = 1 } = $$props;
    	let { type = null } = $$props;
    	let { top = false } = $$props;
    	let { dummy = false } = $$props;
    	let { nohex = false } = $$props;
    	let hexn = writable(state);
    	validate_store(hexn, 'hexn');
    	component_subscribe($$self, hexn, value => $$invalidate(11, $hexn = value));
    	setContext('hexn', hexn);
    	let timer;
    	let cls = '';
    	const rint = (min, max) => Math.random() * (max - min) + min;
    	const randomize = () => $$invalidate(6, state = rint(0b000000, 0b111111));

    	const clrtimer = () => {
    		if (timer) clearTimeout(timer);
    	};

    	const mktimer = () => {
    		clrtimer();
    		timer = setTimeout(loop, rand);
    	};

    	const loop = () => {
    		randomize();
    		mktimer();
    	};

    	const mkc = () => {
    		const c = ['hexagram', `order-${order}`];
    		if (big) c.push('hg-b1');
    		if (top) c.push('hg-top');
    		if (order > 1) c.push('ordered');
    		$$invalidate(4, cls = c.join(' '));
    	};

    	const writable_props = ['state', 'rand', 'big', 'order', 'type', 'top', 'dummy', 'nohex'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Hexagram> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('state' in $$props) $$invalidate(6, state = $$props.state);
    		if ('rand' in $$props) $$invalidate(7, rand = $$props.rand);
    		if ('big' in $$props) $$invalidate(8, big = $$props.big);
    		if ('order' in $$props) $$invalidate(0, order = $$props.order);
    		if ('type' in $$props) $$invalidate(1, type = $$props.type);
    		if ('top' in $$props) $$invalidate(9, top = $$props.top);
    		if ('dummy' in $$props) $$invalidate(2, dummy = $$props.dummy);
    		if ('nohex' in $$props) $$invalidate(3, nohex = $$props.nohex);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		Hexline,
    		setContext,
    		writable,
    		state,
    		rand,
    		big,
    		order,
    		type,
    		top,
    		dummy,
    		nohex,
    		hexn,
    		timer,
    		cls,
    		rint,
    		randomize,
    		clrtimer,
    		mktimer,
    		loop,
    		mkc,
    		$hexn
    	});

    	$$self.$inject_state = $$props => {
    		if ('state' in $$props) $$invalidate(6, state = $$props.state);
    		if ('rand' in $$props) $$invalidate(7, rand = $$props.rand);
    		if ('big' in $$props) $$invalidate(8, big = $$props.big);
    		if ('order' in $$props) $$invalidate(0, order = $$props.order);
    		if ('type' in $$props) $$invalidate(1, type = $$props.type);
    		if ('top' in $$props) $$invalidate(9, top = $$props.top);
    		if ('dummy' in $$props) $$invalidate(2, dummy = $$props.dummy);
    		if ('nohex' in $$props) $$invalidate(3, nohex = $$props.nohex);
    		if ('hexn' in $$props) $$invalidate(5, hexn = $$props.hexn);
    		if ('timer' in $$props) timer = $$props.timer;
    		if ('cls' in $$props) $$invalidate(4, cls = $$props.cls);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*state*/ 64) {
    			set_store_value(hexn, $hexn = state, $hexn);
    		}

    		if ($$self.$$.dirty & /*big*/ 256) {
    			mkc();
    		}

    		if ($$self.$$.dirty & /*rand*/ 128) {
    			if (rand) mktimer(); else clrtimer();
    		}
    	};

    	return [order, type, dummy, nohex, cls, hexn, state, rand, big, top];
    }

    class Hexagram extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$R, create_fragment$R, safe_not_equal, {
    			state: 6,
    			rand: 7,
    			big: 8,
    			order: 0,
    			type: 1,
    			top: 9,
    			dummy: 2,
    			nohex: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Hexagram",
    			options,
    			id: create_fragment$R.name
    		});
    	}

    	get state() {
    		throw new Error("<Hexagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set state(value) {
    		throw new Error("<Hexagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rand() {
    		throw new Error("<Hexagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rand(value) {
    		throw new Error("<Hexagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get big() {
    		throw new Error("<Hexagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set big(value) {
    		throw new Error("<Hexagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get order() {
    		throw new Error("<Hexagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set order(value) {
    		throw new Error("<Hexagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Hexagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Hexagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get top() {
    		throw new Error("<Hexagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set top(value) {
    		throw new Error("<Hexagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dummy() {
    		throw new Error("<Hexagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dummy(value) {
    		throw new Error("<Hexagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nohex() {
    		throw new Error("<Hexagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nohex(value) {
    		throw new Error("<Hexagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Loadbar.svelte generated by Svelte v3.44.3 */

    const { console: console_1$3 } = globals;
    const file$y = "src/Loadbar.svelte";

    function create_fragment$Q(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "progress");
    			set_style(div0, "width", /*pc*/ ctx[0] + "%");
    			add_location(div0, file$y, 51, 2, 998);
    			attr_dev(div1, "class", "loadbar");
    			add_location(div1, file$y, 50, 0, 974);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*pc*/ 1) {
    				set_style(div0, "width", /*pc*/ ctx[0] + "%");
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let pc;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Loadbar', slots, []);
    	let { t = 0 } = $$props;
    	let { end = 10000 } = $$props;
    	let invert = false;
    	let total = 0;
    	let fs = null;
    	let ft = 0;
    	const dispatch = createEventDispatcher();

    	const frame = stamp => {
    		ft = fs ? stamp - fs : 0;
    		if (invert) total = Math.max(total - ft, 0); else total = Math.min(total + ft, end);
    		$$invalidate(1, t = total / end);
    		fs = stamp;
    		if (invert && t > 0 || !invert && t < 1) requestAnimationFrame(frame); else complete();
    	};

    	const begin = () => {
    		if (invert && t > 0 || !invert && t < 1) requestAnimationFrame(frame);
    	};

    	const play = () => {
    		invert = false;
    		total = 0;
    		$$invalidate(1, t = 0);
    		fs = null;
    		ft = 0;
    		begin();
    	};

    	const reverse = () => {
    		invert = true;
    		total = end;
    		$$invalidate(1, t = 1);
    		fs = null;
    		ft = 0;
    		begin();
    	};

    	const complete = () => {
    		console.log('COMPLETE');
    		dispatch('complete');
    	};

    	onMount(() => begin());
    	const writable_props = ['t', 'end'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<Loadbar> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('t' in $$props) $$invalidate(1, t = $$props.t);
    		if ('end' in $$props) $$invalidate(2, end = $$props.end);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		createEventDispatcher,
    		t,
    		end,
    		invert,
    		total,
    		fs,
    		ft,
    		dispatch,
    		frame,
    		begin,
    		play,
    		reverse,
    		complete,
    		pc
    	});

    	$$self.$inject_state = $$props => {
    		if ('t' in $$props) $$invalidate(1, t = $$props.t);
    		if ('end' in $$props) $$invalidate(2, end = $$props.end);
    		if ('invert' in $$props) invert = $$props.invert;
    		if ('total' in $$props) total = $$props.total;
    		if ('fs' in $$props) fs = $$props.fs;
    		if ('ft' in $$props) ft = $$props.ft;
    		if ('pc' in $$props) $$invalidate(0, pc = $$props.pc);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*t*/ 2) {
    			$$invalidate(0, pc = t * 100);
    		}
    	};

    	return [pc, t, end, play, reverse];
    }

    class Loadbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, { t: 1, end: 2, play: 3, reverse: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Loadbar",
    			options,
    			id: create_fragment$Q.name
    		});
    	}

    	get t() {
    		throw new Error("<Loadbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set t(value) {
    		throw new Error("<Loadbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get end() {
    		throw new Error("<Loadbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set end(value) {
    		throw new Error("<Loadbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get play() {
    		return this.$$.ctx[3];
    	}

    	set play(value) {
    		throw new Error("<Loadbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get reverse() {
    		return this.$$.ctx[4];
    	}

    	set reverse(value) {
    		throw new Error("<Loadbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Loadstack.svelte generated by Svelte v3.44.3 */

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    // (34:0) {#each tail as t}
    function create_each_block$7(ctx) {
    	let loadbar;
    	let current;

    	loadbar = new Loadbar({
    			props: { t: 1, end: /*end*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(loadbar.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loadbar, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const loadbar_changes = {};
    			if (dirty & /*end*/ 1) loadbar_changes.end = /*end*/ ctx[0];
    			loadbar.$set(loadbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loadbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loadbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loadbar, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(34:0) {#each tail as t}",
    		ctx
    	});

    	return block;
    }

    // (32:0) <FB vert>
    function create_default_slot$l(ctx) {
    	let t;
    	let loadbar;
    	let current;
    	let each_value = /*tail*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let loadbar_props = { end: /*end*/ ctx[0] };
    	loadbar = new Loadbar({ props: loadbar_props, $$inline: true });
    	/*loadbar_binding*/ ctx[6](loadbar);
    	loadbar.$on("complete", /*loop*/ ctx[3]);

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			create_component(loadbar.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			mount_component(loadbar, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*end, tail*/ 5) {
    				each_value = /*tail*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const loadbar_changes = {};
    			if (dirty & /*end*/ 1) loadbar_changes.end = /*end*/ ctx[0];
    			loadbar.$set(loadbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(loadbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(loadbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			/*loadbar_binding*/ ctx[6](null);
    			destroy_component(loadbar, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$l.name,
    		type: "slot",
    		source: "(32:0) <FB vert>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$P(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				$$slots: { default: [create_default_slot$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, end, mainbar, tail*/ 8199) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let head;
    	let tail;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Loadstack', slots, []);
    	let { end = 2500 } = $$props;
    	let { max = 6 } = $$props;
    	const dispatch = createEventDispatcher();
    	let stack = [0];
    	let reverse = false;
    	let mainbar;

    	const loop = () => {
    		if (!reverse && stack.length >= max) reverse = true; else if (reverse && stack.length <= 1) reverse = false; else {
    			if (reverse) stack.pop(); else stack.push(0);
    		}

    		$$invalidate(5, stack);

    		if (mainbar) {
    			if (reverse) mainbar.reverse(); else mainbar.play();
    			dispatch('loop');
    		}
    	};

    	const writable_props = ['end', 'max'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Loadstack> was created with unknown prop '${key}'`);
    	});

    	function loadbar_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			mainbar = $$value;
    			$$invalidate(1, mainbar);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('end' in $$props) $$invalidate(0, end = $$props.end);
    		if ('max' in $$props) $$invalidate(4, max = $$props.max);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		Loadbar,
    		onMount,
    		createEventDispatcher,
    		end,
    		max,
    		dispatch,
    		stack,
    		reverse,
    		mainbar,
    		loop,
    		tail,
    		head
    	});

    	$$self.$inject_state = $$props => {
    		if ('end' in $$props) $$invalidate(0, end = $$props.end);
    		if ('max' in $$props) $$invalidate(4, max = $$props.max);
    		if ('stack' in $$props) $$invalidate(5, stack = $$props.stack);
    		if ('reverse' in $$props) reverse = $$props.reverse;
    		if ('mainbar' in $$props) $$invalidate(1, mainbar = $$props.mainbar);
    		if ('tail' in $$props) $$invalidate(2, tail = $$props.tail);
    		if ('head' in $$props) head = $$props.head;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*stack*/ 32) {
    			head = stack[0];
    		}

    		if ($$self.$$.dirty & /*stack*/ 32) {
    			$$invalidate(2, tail = stack.slice(1));
    		}
    	};

    	return [end, mainbar, tail, loop, max, stack, loadbar_binding];
    }

    class Loadstack extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$P, safe_not_equal, { end: 0, max: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Loadstack",
    			options,
    			id: create_fragment$P.name
    		});
    	}

    	get end() {
    		throw new Error("<Loadstack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set end(value) {
    		throw new Error("<Loadstack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<Loadstack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<Loadstack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var alea = createCommonjsModule(function (module) {
    // A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
    // http://baagoe.com/en/RandomMusings/javascript/
    // https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
    // Original work is under MIT license -

    // Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to deal
    // in the Software without restriction, including without limitation the rights
    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    // copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    // 
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    // 
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    // THE SOFTWARE.



    (function(global, module, define) {

    function Alea(seed) {
      var me = this, mash = Mash();

      me.next = function() {
        var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
        me.s0 = me.s1;
        me.s1 = me.s2;
        return me.s2 = t - (me.c = t | 0);
      };

      // Apply the seeding algorithm from Baagoe.
      me.c = 1;
      me.s0 = mash(' ');
      me.s1 = mash(' ');
      me.s2 = mash(' ');
      me.s0 -= mash(seed);
      if (me.s0 < 0) { me.s0 += 1; }
      me.s1 -= mash(seed);
      if (me.s1 < 0) { me.s1 += 1; }
      me.s2 -= mash(seed);
      if (me.s2 < 0) { me.s2 += 1; }
      mash = null;
    }

    function copy(f, t) {
      t.c = f.c;
      t.s0 = f.s0;
      t.s1 = f.s1;
      t.s2 = f.s2;
      return t;
    }

    function impl(seed, opts) {
      var xg = new Alea(seed),
          state = opts && opts.state,
          prng = xg.next;
      prng.int32 = function() { return (xg.next() * 0x100000000) | 0; };
      prng.double = function() {
        return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
      };
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    function Mash() {
      var n = 0xefc8249d;

      var mash = function(data) {
        data = data.toString();
        for (var i = 0; i < data.length; i++) {
          n += data.charCodeAt(i);
          var h = 0.02519603282416938 * n;
          n = h >>> 0;
          h -= n;
          h *= n;
          n = h >>> 0;
          h -= n;
          n += h * 0x100000000; // 2^32
        }
        return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
      };

      return mash;
    }


    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.alea = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xor128 = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "xor128" prng algorithm by
    // George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this, strseed = '';

      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;

      // Set up generator function.
      me.next = function() {
        var t = me.x ^ (me.x << 11);
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
      };

      if (seed === (seed | 0)) {
        // Integer seed.
        me.x = seed;
      } else {
        // String seed.
        strseed += seed;
      }

      // Mix in string seed, then discard an initial batch of 64 values.
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }

    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      return t;
    }

    function impl(seed, opts) {
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xor128 = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xorwow = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "xorwow" prng algorithm by
    // George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this, strseed = '';

      // Set up generator function.
      me.next = function() {
        var t = (me.x ^ (me.x >>> 2));
        me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
        return (me.d = (me.d + 362437 | 0)) +
           (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
      };

      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.v = 0;

      if (seed === (seed | 0)) {
        // Integer seed.
        me.x = seed;
      } else {
        // String seed.
        strseed += seed;
      }

      // Mix in string seed, then discard an initial batch of 64 values.
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        if (k == strseed.length) {
          me.d = me.x << 10 ^ me.x >>> 4;
        }
        me.next();
      }
    }

    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      t.v = f.v;
      t.d = f.d;
      return t;
    }

    function impl(seed, opts) {
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xorwow = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xorshift7 = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "xorshift7" algorithm by
    // François Panneton and Pierre L'ecuyer:
    // "On the Xorgshift Random Number Generators"
    // http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this;

      // Set up generator function.
      me.next = function() {
        // Update xor generator.
        var X = me.x, i = me.i, t, v;
        t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
        t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
        t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
        t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
        t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
        X[i] = v;
        me.i = (i + 1) & 7;
        return v;
      };

      function init(me, seed) {
        var j, X = [];

        if (seed === (seed | 0)) {
          // Seed state array using a 32-bit integer.
          X[0] = seed;
        } else {
          // Seed state using a string.
          seed = '' + seed;
          for (j = 0; j < seed.length; ++j) {
            X[j & 7] = (X[j & 7] << 15) ^
                (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
          }
        }
        // Enforce an array length of 8, not all zeroes.
        while (X.length < 8) X.push(0);
        for (j = 0; j < 8 && X[j] === 0; ++j);
        if (j == 8) X[7] = -1;

        me.x = X;
        me.i = 0;

        // Discard an initial 256 values.
        for (j = 256; j > 0; --j) {
          me.next();
        }
      }

      init(me, seed);
    }

    function copy(f, t) {
      t.x = f.x.slice();
      t.i = f.i;
      return t;
    }

    function impl(seed, opts) {
      if (seed == null) seed = +(new Date);
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.x) copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xorshift7 = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xor4096 = createCommonjsModule(function (module) {
    // A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
    //
    // This fast non-cryptographic random number generator is designed for
    // use in Monte-Carlo algorithms. It combines a long-period xorshift
    // generator with a Weyl generator, and it passes all common batteries
    // of stasticial tests for randomness while consuming only a few nanoseconds
    // for each prng generated.  For background on the generator, see Brent's
    // paper: "Some long-period random number generators using shifts and xors."
    // http://arxiv.org/pdf/1004.3115v1.pdf
    //
    // Usage:
    //
    // var xor4096 = require('xor4096');
    // random = xor4096(1);                        // Seed with int32 or string.
    // assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
    // assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
    //
    // For nonzero numeric keys, this impelementation provides a sequence
    // identical to that by Brent's xorgens 3 implementaion in C.  This
    // implementation also provides for initalizing the generator with
    // string seeds, or for saving and restoring the state of the generator.
    //
    // On Chrome, this prng benchmarks about 2.1 times slower than
    // Javascript's built-in Math.random().

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this;

      // Set up generator function.
      me.next = function() {
        var w = me.w,
            X = me.X, i = me.i, t, v;
        // Update Weyl generator.
        me.w = w = (w + 0x61c88647) | 0;
        // Update xor generator.
        v = X[(i + 34) & 127];
        t = X[i = ((i + 1) & 127)];
        v ^= v << 13;
        t ^= t << 17;
        v ^= v >>> 15;
        t ^= t >>> 12;
        // Update Xor generator array state.
        v = X[i] = v ^ t;
        me.i = i;
        // Result is the combination.
        return (v + (w ^ (w >>> 16))) | 0;
      };

      function init(me, seed) {
        var t, v, i, j, w, X = [], limit = 128;
        if (seed === (seed | 0)) {
          // Numeric seeds initialize v, which is used to generates X.
          v = seed;
          seed = null;
        } else {
          // String seeds are mixed into v and X one character at a time.
          seed = seed + '\0';
          v = 0;
          limit = Math.max(limit, seed.length);
        }
        // Initialize circular array and weyl value.
        for (i = 0, j = -32; j < limit; ++j) {
          // Put the unicode characters into the array, and shuffle them.
          if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
          // After 32 shuffles, take v as the starting w value.
          if (j === 0) w = v;
          v ^= v << 10;
          v ^= v >>> 15;
          v ^= v << 4;
          v ^= v >>> 13;
          if (j >= 0) {
            w = (w + 0x61c88647) | 0;     // Weyl.
            t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
            i = (0 == t) ? i + 1 : 0;     // Count zeroes.
          }
        }
        // We have detected all zeroes; make the key nonzero.
        if (i >= 128) {
          X[(seed && seed.length || 0) & 127] = -1;
        }
        // Run the generator 512 times to further mix the state before using it.
        // Factoring this as a function slows the main generator, so it is just
        // unrolled here.  The weyl generator is not advanced while warming up.
        i = 127;
        for (j = 4 * 128; j > 0; --j) {
          v = X[(i + 34) & 127];
          t = X[i = ((i + 1) & 127)];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          X[i] = v ^ t;
        }
        // Storing state as object members is faster than using closure variables.
        me.w = w;
        me.X = X;
        me.i = i;
      }

      init(me, seed);
    }

    function copy(f, t) {
      t.i = f.i;
      t.w = f.w;
      t.X = f.X.slice();
      return t;
    }
    function impl(seed, opts) {
      if (seed == null) seed = +(new Date);
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.X) copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xor4096 = impl;
    }

    })(
      commonjsGlobal,                                     // window object or global
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var tychei = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "Tyche-i" prng algorithm by
    // Samuel Neves and Filipe Araujo.
    // See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this, strseed = '';

      // Set up generator function.
      me.next = function() {
        var b = me.b, c = me.c, d = me.d, a = me.a;
        b = (b << 25) ^ (b >>> 7) ^ c;
        c = (c - d) | 0;
        d = (d << 24) ^ (d >>> 8) ^ a;
        a = (a - b) | 0;
        me.b = b = (b << 20) ^ (b >>> 12) ^ c;
        me.c = c = (c - d) | 0;
        me.d = (d << 16) ^ (c >>> 16) ^ a;
        return me.a = (a - b) | 0;
      };

      /* The following is non-inverted tyche, which has better internal
       * bit diffusion, but which is about 25% slower than tyche-i in JS.
      me.next = function() {
        var a = me.a, b = me.b, c = me.c, d = me.d;
        a = (me.a + me.b | 0) >>> 0;
        d = me.d ^ a; d = d << 16 ^ d >>> 16;
        c = me.c + d | 0;
        b = me.b ^ c; b = b << 12 ^ d >>> 20;
        me.a = a = a + b | 0;
        d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
        me.c = c = c + d | 0;
        b = b ^ c;
        return me.b = (b << 7 ^ b >>> 25);
      }
      */

      me.a = 0;
      me.b = 0;
      me.c = 2654435769 | 0;
      me.d = 1367130551;

      if (seed === Math.floor(seed)) {
        // Integer seed.
        me.a = (seed / 0x100000000) | 0;
        me.b = seed | 0;
      } else {
        // String seed.
        strseed += seed;
      }

      // Mix in string seed, then discard an initial batch of 64 values.
      for (var k = 0; k < strseed.length + 20; k++) {
        me.b ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }

    function copy(f, t) {
      t.a = f.a;
      t.b = f.b;
      t.c = f.c;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.tychei = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var _nodeResolve_empty = {};

    var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _nodeResolve_empty
    });

    var require$$0$5 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

    /*
    Copyright 2014 David Bau.

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    */

    var seedrandom$1 = createCommonjsModule(function (module) {
    (function (pool, math) {
    //
    // The following constants are related to IEEE 754 limits.
    //

    // Detect the global object, even if operating in strict mode.
    // http://stackoverflow.com/a/14387057/265298
    var global = (0, eval)('this'),
        width = 256,        // each RC4 output is 0 <= x < 256
        chunks = 6,         // at least six RC4 outputs for each double
        digits = 52,        // there are 52 significant digits in a double
        rngname = 'random', // rngname: name for Math.random and Math.seedrandom
        startdenom = math.pow(width, chunks),
        significance = math.pow(2, digits),
        overflow = significance * 2,
        mask = width - 1,
        nodecrypto;         // node.js crypto module, initialized at the bottom.

    //
    // seedrandom()
    // This is the seedrandom function described above.
    //
    function seedrandom(seed, options, callback) {
      var key = [];
      options = (options == true) ? { entropy: true } : (options || {});

      // Flatten the seed string or build one from local entropy if needed.
      var shortseed = mixkey(flatten(
        options.entropy ? [seed, tostring(pool)] :
        (seed == null) ? autoseed() : seed, 3), key);

      // Use the seed to initialize an ARC4 generator.
      var arc4 = new ARC4(key);

      // This function returns a random double in [0, 1) that contains
      // randomness in every bit of the mantissa of the IEEE 754 value.
      var prng = function() {
        var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
            d = startdenom,                 //   and denominator d = 2 ^ 48.
            x = 0;                          //   and no 'extra last byte'.
        while (n < significance) {          // Fill up all significant digits by
          n = (n + x) * width;              //   shifting numerator and
          d *= width;                       //   denominator and generating a
          x = arc4.g(1);                    //   new least-significant-byte.
        }
        while (n >= overflow) {             // To avoid rounding up, before adding
          n /= 2;                           //   last byte, shift everything
          d /= 2;                           //   right using integer math until
          x >>>= 1;                         //   we have exactly the desired bits.
        }
        return (n + x) / d;                 // Form the number within [0, 1).
      };

      prng.int32 = function() { return arc4.g(4) | 0; };
      prng.quick = function() { return arc4.g(4) / 0x100000000; };
      prng.double = prng;

      // Mix the randomness into accumulated entropy.
      mixkey(tostring(arc4.S), pool);

      // Calling convention: what to return as a function of prng, seed, is_math.
      return (options.pass || callback ||
          function(prng, seed, is_math_call, state) {
            if (state) {
              // Load the arc4 state from the given state if it has an S array.
              if (state.S) { copy(state, arc4); }
              // Only provide the .state method if requested via options.state.
              prng.state = function() { return copy(arc4, {}); };
            }

            // If called as a method of Math (Math.seedrandom()), mutate
            // Math.random because that is how seedrandom.js has worked since v1.0.
            if (is_math_call) { math[rngname] = prng; return seed; }

            // Otherwise, it is a newer calling convention, so return the
            // prng directly.
            else return prng;
          })(
      prng,
      shortseed,
      'global' in options ? options.global : (this == math),
      options.state);
    }
    math['seed' + rngname] = seedrandom;

    //
    // ARC4
    //
    // An ARC4 implementation.  The constructor takes a key in the form of
    // an array of at most (width) integers that should be 0 <= x < (width).
    //
    // The g(count) method returns a pseudorandom integer that concatenates
    // the next (count) outputs from ARC4.  Its return value is a number x
    // that is in the range 0 <= x < (width ^ count).
    //
    function ARC4(key) {
      var t, keylen = key.length,
          me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

      // The empty key [] is treated as [0].
      if (!keylen) { key = [keylen++]; }

      // Set up S using the standard key scheduling algorithm.
      while (i < width) {
        s[i] = i++;
      }
      for (i = 0; i < width; i++) {
        s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
        s[j] = t;
      }

      // The "g" method returns the next (count) outputs as one number.
      (me.g = function(count) {
        // Using instance members instead of closure state nearly doubles speed.
        var t, r = 0,
            i = me.i, j = me.j, s = me.S;
        while (count--) {
          t = s[i = mask & (i + 1)];
          r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
        }
        me.i = i; me.j = j;
        return r;
        // For robust unpredictability, the function call below automatically
        // discards an initial batch of values.  This is called RC4-drop[256].
        // See http://google.com/search?q=rsa+fluhrer+response&btnI
      })(width);
    }

    //
    // copy()
    // Copies internal state of ARC4 to or from a plain object.
    //
    function copy(f, t) {
      t.i = f.i;
      t.j = f.j;
      t.S = f.S.slice();
      return t;
    }
    //
    // flatten()
    // Converts an object tree to nested arrays of strings.
    //
    function flatten(obj, depth) {
      var result = [], typ = (typeof obj), prop;
      if (depth && typ == 'object') {
        for (prop in obj) {
          try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
        }
      }
      return (result.length ? result : typ == 'string' ? obj : obj + '\0');
    }

    //
    // mixkey()
    // Mixes a string seed into a key that is an array of integers, and
    // returns a shortened string seed that is equivalent to the result key.
    //
    function mixkey(seed, key) {
      var stringseed = seed + '', smear, j = 0;
      while (j < stringseed.length) {
        key[mask & j] =
          mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
      }
      return tostring(key);
    }

    //
    // autoseed()
    // Returns an object for autoseeding, using window.crypto and Node crypto
    // module if available.
    //
    function autoseed() {
      try {
        var out;
        if (nodecrypto && (out = nodecrypto.randomBytes)) {
          // The use of 'out' to remember randomBytes makes tight minified code.
          out = out(width);
        } else {
          out = new Uint8Array(width);
          (global.crypto || global.msCrypto).getRandomValues(out);
        }
        return tostring(out);
      } catch (e) {
        var browser = global.navigator,
            plugins = browser && browser.plugins;
        return [+new Date, global, plugins, global.screen, tostring(pool)];
      }
    }

    //
    // tostring()
    // Converts an array of charcodes to a string
    //
    function tostring(a) {
      return String.fromCharCode.apply(0, a);
    }

    //
    // When seedrandom.js is loaded, we immediately mix a few bits
    // from the built-in RNG into the entropy pool.  Because we do
    // not want to interfere with deterministic PRNG state later,
    // seedrandom will not call math.random on its own again after
    // initialization.
    //
    mixkey(math.random(), pool);

    //
    // Nodejs and AMD support: export the implementation as a module using
    // either convention.
    //
    if (module.exports) {
      module.exports = seedrandom;
      // When in node.js, try using crypto package for autoseeding.
      try {
        nodecrypto = require$$0$5;
      } catch (ex) {}
    }

    // End anonymous scope, and pass initial values.
    })(
      [],     // pool: entropy pool starts empty
      Math    // math: package containing random, pow, and seedrandom
    );
    });

    // A library of seedable RNGs implemented in Javascript.
    //
    // Usage:
    //
    // var seedrandom = require('seedrandom');
    // var random = seedrandom(1); // or any seed.
    // var x = random();       // 0 <= x < 1.  Every bit is random.
    // var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

    // alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
    // Period: ~2^116
    // Reported to pass all BigCrush tests.


    // xor128, a pure xor-shift generator by George Marsaglia.
    // Period: 2^128-1.
    // Reported to fail: MatrixRank and LinearComp.


    // xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
    // Period: 2^192-2^32
    // Reported to fail: CollisionOver, SimpPoker, and LinearComp.


    // xorshift7, by François Panneton and Pierre L'ecuyer, takes
    // a different approach: it adds robustness by allowing more shifts
    // than Marsaglia's original three.  It is a 7-shift generator
    // with 256 bits, that passes BigCrush with no systmatic failures.
    // Period 2^256-1.
    // No systematic BigCrush failures reported.


    // xor4096, by Richard Brent, is a 4096-bit xor-shift with a
    // very long period that also adds a Weyl generator. It also passes
    // BigCrush with no systematic failures.  Its long period may
    // be useful if you have many generators and need to avoid
    // collisions.
    // Period: 2^4128-2^32.
    // No systematic BigCrush failures reported.


    // Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
    // number generator derived from ChaCha, a modern stream cipher.
    // https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
    // Period: ~2^127
    // No systematic BigCrush failures reported.


    // The original ARC4-based prng included in this library.
    // Period: ~2^1600


    seedrandom$1.alea = alea;
    seedrandom$1.xor128 = xor128;
    seedrandom$1.xorwow = xorwow;
    seedrandom$1.xorshift7 = xorshift7;
    seedrandom$1.xor4096 = xor4096;
    seedrandom$1.tychei = tychei;

    var seedrandom = seedrandom$1;

    class Reading {
      constructor(lines, change) {
        this.hexagram = parseInt(lines.join(''), 2);
        this.change = parseInt(change.join(''), 2);
        this.zhigua = this.change ? this.hexagram ^ this.change : null;
      }
    }

    class Oracle {
      constructor() {
        this.rng = null;
        this.lines = [];
        this.change = [];
      }
      query(q) {
        this.rng = new seedrandom(q, {entropy:true});
        this.lines = [];
        this.change = [];
        this.generate();
        return new Reading(this.lines, this.change)
      }
      generate() {
        for (let l = 1; l <= 6; l++) {
          let line = new Line(this);
          switch(line.sum) {
            case 9:
              this.lines.push(1);
              this.change.push(1);
              break;
            case 8:
              this.lines.push(0);
              this.change.push(0);
              break;
            case 7:
              this.lines.push(1);
              this.change.push(0);
              break;
            case 6:
              this.lines.push(0);
              this.change.push(1);
              break;
            default:
              throw 'unknown line: ' + line
          }
        }
      }
    }

    class Line {
      constructor(oracle) {
        this.oracle = oracle;
        this.stalks = 49;
        this.sum = 0;
        this.generate();
      }
      generate() {
        this.stalks = 49;
        this.sum = 0;
        for (let c = 1; c <= 3; c++) {
          this.calculate();
        }
      }
      calculate() {
        const remainder =size=> size % 4 || 4;

        let pa = Math.ceil(this.oracle.rng() * (this.stalks - 9) + 4);
        let pb = this.stalks - pa;

        pb -= 1;
        let used = 1;

        let r = remainder(pa);
        pa -= r;
        used += r;

        r = remainder(pb);
        pb -= r;
        used += r;

        let s = used;
        switch(used) {
          case 9:
          case 8:
            s = 2;
            break;
          case 5:
          case 4:
            s = 3;
            break;
          default:
            throw 'unknown number = ' + used
        }
        this.stalks -= used;
        this.sum += s;
      }
    }

    var yarrow = Oracle;

    /* src/LoadingScreen.svelte generated by Svelte v3.44.3 */

    // (40:4) <FB center>
    function create_default_slot_20$2(ctx) {
    	let hexagram;
    	let current;

    	hexagram = new Hexagram({
    			props: { state: /*s*/ ctx[0][0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hexagram.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hexagram, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hexagram_changes = {};
    			if (dirty & /*s*/ 1) hexagram_changes.state = /*s*/ ctx[0][0];
    			hexagram.$set(hexagram_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hexagram.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hexagram.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hexagram, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$2.name,
    		type: "slot",
    		source: "(40:4) <FB center>",
    		ctx
    	});

    	return block;
    }

    // (41:4) <FB center>
    function create_default_slot_19$2(ctx) {
    	let hexagram;
    	let current;

    	hexagram = new Hexagram({
    			props: { state: /*s*/ ctx[0][4] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hexagram.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hexagram, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hexagram_changes = {};
    			if (dirty & /*s*/ 1) hexagram_changes.state = /*s*/ ctx[0][4];
    			hexagram.$set(hexagram_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hexagram.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hexagram.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hexagram, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$2.name,
    		type: "slot",
    		source: "(41:4) <FB center>",
    		ctx
    	});

    	return block;
    }

    // (42:4) <FB center>
    function create_default_slot_18$2(ctx) {
    	let hexagram;
    	let current;

    	hexagram = new Hexagram({
    			props: {
    				state: /*s*/ ctx[0][1] || 0,
    				nohex: /*s*/ ctx[0][1] === null,
    				top: true,
    				type: "之卦",
    				order: 2
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hexagram.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hexagram, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hexagram_changes = {};
    			if (dirty & /*s*/ 1) hexagram_changes.state = /*s*/ ctx[0][1] || 0;
    			if (dirty & /*s*/ 1) hexagram_changes.nohex = /*s*/ ctx[0][1] === null;
    			hexagram.$set(hexagram_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hexagram.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hexagram.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hexagram, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$2.name,
    		type: "slot",
    		source: "(42:4) <FB center>",
    		ctx
    	});

    	return block;
    }

    // (39:20) <FB vert between>
    function create_default_slot_17$2(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let fb2;
    	let current;

    	fb0 = new FB({
    			props: {
    				center: true,
    				$$slots: { default: [create_default_slot_20$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				center: true,
    				$$slots: { default: [create_default_slot_19$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb2 = new FB({
    			props: {
    				center: true,
    				$$slots: { default: [create_default_slot_18$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    			create_component(fb2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope, s*/ 65) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope, s*/ 65) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    			const fb2_changes = {};

    			if (dirty & /*$$scope, s*/ 65) {
    				fb2_changes.$$scope = { dirty, ctx };
    			}

    			fb2.$set(fb2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(fb2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(fb2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$2.name,
    		type: "slot",
    		source: "(39:20) <FB vert between>",
    		ctx
    	});

    	return block;
    }

    // (39:2) <FB center expand>
    function create_default_slot_16$2(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				between: true,
    				$$slots: { default: [create_default_slot_17$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, s*/ 65) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$2.name,
    		type: "slot",
    		source: "(39:2) <FB center expand>",
    		ctx
    	});

    	return block;
    }

    // (49:6) <FB title line="b6" fw={9}>
    function create_default_slot_15$2(ctx) {
    	let t_1;

    	const block = {
    		c: function create() {
    			t_1 = text("HOLD");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t_1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$2.name,
    		type: "slot",
    		source: "(49:6) <FB title line=\\\"b6\\\" fw={9}>",
    		ctx
    	});

    	return block;
    }

    // (52:10) <FB title mono line="n">
    function create_default_slot_14$2(ctx) {
    	let t_1;

    	const block = {
    		c: function create() {
    			t_1 = text("0x2764");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t_1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$2.name,
    		type: "slot",
    		source: "(52:10) <FB title mono line=\\\"n\\\">",
    		ctx
    	});

    	return block;
    }

    // (51:8) <FB c="blackcell head">
    function create_default_slot_13$2(ctx) {
    	let fb0;
    	let t_1;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				title: true,
    				mono: true,
    				line: "n",
    				$$slots: { default: [create_default_slot_14$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				vc: true,
    				expand: true,
    				c: "blackfill blackline"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t_1 = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t_1, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t_1);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$2.name,
    		type: "slot",
    		source: "(51:8) <FB c=\\\"blackcell head\\\">",
    		ctx
    	});

    	return block;
    }

    // (56:10) <FB line="s3" fw={6} end>
    function create_default_slot_12$2(ctx) {
    	let t_1;

    	const block = {
    		c: function create() {
    			t_1 = text("WELCOME TO THE");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t_1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$2.name,
    		type: "slot",
    		source: "(56:10) <FB line=\\\"s3\\\" fw={6} end>",
    		ctx
    	});

    	return block;
    }

    // (57:10) <FB line="s3" fw={6} end>
    function create_default_slot_11$4(ctx) {
    	let t_1;

    	const block = {
    		c: function create() {
    			t_1 = text("FUTURE");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t_1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$4.name,
    		type: "slot",
    		source: "(57:10) <FB line=\\\"s3\\\" fw={6} end>",
    		ctx
    	});

    	return block;
    }

    // (55:8) <FB vert zero c="blackcell">
    function create_default_slot_10$4(ctx) {
    	let fb0;
    	let t_1;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				line: "s3",
    				fw: 6,
    				end: true,
    				$$slots: { default: [create_default_slot_12$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				line: "s3",
    				fw: 6,
    				end: true,
    				$$slots: { default: [create_default_slot_11$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t_1 = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t_1, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t_1);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$4.name,
    		type: "slot",
    		source: "(55:8) <FB vert zero c=\\\"blackcell\\\">",
    		ctx
    	});

    	return block;
    }

    // (50:6) <FB vert zero c="blackbox">
    function create_default_slot_9$4(ctx) {
    	let fb0;
    	let t_1;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				c: "blackcell head",
    				$$slots: { default: [create_default_slot_13$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				vert: true,
    				zero: true,
    				c: "blackcell",
    				$$slots: { default: [create_default_slot_10$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t_1 = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t_1, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t_1);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$4.name,
    		type: "slot",
    		source: "(50:6) <FB vert zero c=\\\"blackbox\\\">",
    		ctx
    	});

    	return block;
    }

    // (48:4) <FB expand vert>
    function create_default_slot_8$4(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let loadstack;
    	let current;

    	fb0 = new FB({
    			props: {
    				title: true,
    				line: "b6",
    				fw: 9,
    				$$slots: { default: [create_default_slot_15$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				vert: true,
    				zero: true,
    				c: "blackbox",
    				$$slots: { default: [create_default_slot_9$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	loadstack = new Loadstack({
    			props: { end: 2500, max: 6 },
    			$$inline: true
    		});

    	loadstack.$on("loop", /*prognosticate*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    			create_component(loadstack.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(loadstack, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(loadstack.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(loadstack.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(loadstack, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$4.name,
    		type: "slot",
    		source: "(48:4) <FB expand vert>",
    		ctx
    	});

    	return block;
    }

    // (63:4) <FB center>
    function create_default_slot_7$6(ctx) {
    	let hexagram;
    	let current;

    	hexagram = new Hexagram({
    			props: {
    				big: true,
    				top: true,
    				state: /*s*/ ctx[0][6],
    				order: 3,
    				type: "之卦"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hexagram.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hexagram, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hexagram_changes = {};
    			if (dirty & /*s*/ 1) hexagram_changes.state = /*s*/ ctx[0][6];
    			hexagram.$set(hexagram_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hexagram.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hexagram.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hexagram, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$6.name,
    		type: "slot",
    		source: "(63:4) <FB center>",
    		ctx
    	});

    	return block;
    }

    // (45:2) <FB vert>
    function create_default_slot_6$6(ctx) {
    	let hexagram;
    	let t0;
    	let fb0;
    	let t1;
    	let fb1;
    	let current;
    	hexagram = new Hexagram({ props: { dummy: true }, $$inline: true });

    	fb0 = new FB({
    			props: {
    				expand: true,
    				vert: true,
    				$$slots: { default: [create_default_slot_8$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				center: true,
    				$$slots: { default: [create_default_slot_7$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hexagram.$$.fragment);
    			t0 = space();
    			create_component(fb0.$$.fragment);
    			t1 = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hexagram, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope, s*/ 65) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hexagram.$$.fragment, local);
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hexagram.$$.fragment, local);
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hexagram, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$6.name,
    		type: "slot",
    		source: "(45:2) <FB vert>",
    		ctx
    	});

    	return block;
    }

    // (69:4) <FB center>
    function create_default_slot_5$7(ctx) {
    	let hexagram;
    	let current;

    	hexagram = new Hexagram({
    			props: { state: /*s*/ ctx[0][2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hexagram.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hexagram, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hexagram_changes = {};
    			if (dirty & /*s*/ 1) hexagram_changes.state = /*s*/ ctx[0][2];
    			hexagram.$set(hexagram_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hexagram.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hexagram.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hexagram, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$7.name,
    		type: "slot",
    		source: "(69:4) <FB center>",
    		ctx
    	});

    	return block;
    }

    // (70:4) <FB center>
    function create_default_slot_4$7(ctx) {
    	let hexagram;
    	let current;

    	hexagram = new Hexagram({
    			props: { state: /*s*/ ctx[0][5] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hexagram.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hexagram, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hexagram_changes = {};
    			if (dirty & /*s*/ 1) hexagram_changes.state = /*s*/ ctx[0][5];
    			hexagram.$set(hexagram_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hexagram.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hexagram.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hexagram, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$7.name,
    		type: "slot",
    		source: "(70:4) <FB center>",
    		ctx
    	});

    	return block;
    }

    // (71:4) <FB center>
    function create_default_slot_3$a(ctx) {
    	let hexagram;
    	let current;

    	hexagram = new Hexagram({
    			props: {
    				state: /*s*/ ctx[0][3] || 0,
    				nohex: /*s*/ ctx[0][3] === null,
    				top: true,
    				type: "之卦",
    				order: 2
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hexagram.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hexagram, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hexagram_changes = {};
    			if (dirty & /*s*/ 1) hexagram_changes.state = /*s*/ ctx[0][3] || 0;
    			if (dirty & /*s*/ 1) hexagram_changes.nohex = /*s*/ ctx[0][3] === null;
    			hexagram.$set(hexagram_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hexagram.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hexagram.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hexagram, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$a.name,
    		type: "slot",
    		source: "(71:4) <FB center>",
    		ctx
    	});

    	return block;
    }

    // (68:20) <FB vert between>
    function create_default_slot_2$d(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let fb2;
    	let current;

    	fb0 = new FB({
    			props: {
    				center: true,
    				$$slots: { default: [create_default_slot_5$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				center: true,
    				$$slots: { default: [create_default_slot_4$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb2 = new FB({
    			props: {
    				center: true,
    				$$slots: { default: [create_default_slot_3$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    			create_component(fb2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope, s*/ 65) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope, s*/ 65) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    			const fb2_changes = {};

    			if (dirty & /*$$scope, s*/ 65) {
    				fb2_changes.$$scope = { dirty, ctx };
    			}

    			fb2.$set(fb2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(fb2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(fb2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$d.name,
    		type: "slot",
    		source: "(68:20) <FB vert between>",
    		ctx
    	});

    	return block;
    }

    // (68:2) <FB center expand>
    function create_default_slot_1$f(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				between: true,
    				$$slots: { default: [create_default_slot_2$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, s*/ 65) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$f.name,
    		type: "slot",
    		source: "(68:2) <FB center expand>",
    		ctx
    	});

    	return block;
    }

    // (37:0) <FB center expand c="loading-screen">
    function create_default_slot$k(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let fb2;
    	let current;

    	fb0 = new FB({
    			props: {
    				center: true,
    				expand: true,
    				$$slots: { default: [create_default_slot_16$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				vert: true,
    				$$slots: { default: [create_default_slot_6$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb2 = new FB({
    			props: {
    				center: true,
    				expand: true,
    				$$slots: { default: [create_default_slot_1$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    			create_component(fb2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope, s*/ 65) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope, s*/ 65) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    			const fb2_changes = {};

    			if (dirty & /*$$scope, s*/ 65) {
    				fb2_changes.$$scope = { dirty, ctx };
    			}

    			fb2.$set(fb2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(fb2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(fb2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$k.name,
    		type: "slot",
    		source: "(37:0) <FB center expand c=\\\"loading-screen\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$O(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				center: true,
    				expand: true,
    				c: "loading-screen",
    				$$slots: { default: [create_default_slot$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, s*/ 65) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LoadingScreen', slots, []);
    	let s = [];
    	const oracle = new yarrow();
    	const fuzz = n => n + util.rint(-10, 10);

    	const t = () => {
    		const r = delay;
    		delay = Math.min(delay + 30, max);
    		return fuzz(r >= max ? max : r);
    	};

    	const random = () => util.rint(0b000000, 0b111111);

    	const prognosticate = () => {
    		const r1 = oracle.query('foo');
    		const r2 = oracle.query('bar');
    		const h1 = r1.hexagram;
    		const h2 = r1.zhigua;
    		const h3 = r2.hexagram;
    		const h4 = r2.zhigua;
    		const h5 = r1.change;
    		const h6 = r2.change;
    		const h7 = h2 ^ h4;
    		$$invalidate(0, s = [h1, h2, h3, h4, h5, h6, h7]);
    	};

    	onMount(() => prognosticate());
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LoadingScreen> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		FB,
    		Hexagram,
    		Loadbar,
    		Loadstack,
    		rint: util.rint,
    		Oracle: yarrow,
    		onMount,
    		s,
    		oracle,
    		fuzz,
    		t,
    		random,
    		prognosticate
    	});

    	$$self.$inject_state = $$props => {
    		if ('s' in $$props) $$invalidate(0, s = $$props.s);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [s, prognosticate];
    }

    class LoadingScreen extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LoadingScreen",
    			options,
    			id: create_fragment$O.name
    		});
    	}
    }

    /* src/special/Login.svelte generated by Svelte v3.44.3 */

    // (19:4) <FB line="b3">
    function create_default_slot_7$5(ctx) {
    	let text_1;
    	let updating_value;
    	let current;

    	function text_1_value_binding(value) {
    		/*text_1_value_binding*/ ctx[8](value);
    	}

    	let text_1_props = { lab: "HANDLE" };

    	if (/*handle*/ ctx[0] !== void 0) {
    		text_1_props.value = /*handle*/ ctx[0];
    	}

    	text_1 = new Text$1({ props: text_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(text_1, 'value', text_1_value_binding));

    	const block = {
    		c: function create() {
    			create_component(text_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(text_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const text_1_changes = {};

    			if (!updating_value && dirty & /*handle*/ 1) {
    				updating_value = true;
    				text_1_changes.value = /*handle*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			text_1.$set(text_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(text_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$5.name,
    		type: "slot",
    		source: "(19:4) <FB line=\\\"b3\\\">",
    		ctx
    	});

    	return block;
    }

    // (22:4) {#if doreg}
    function create_if_block_1$8(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				line: "b3",
    				$$slots: { default: [create_default_slot_6$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, email*/ 8194) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(22:4) {#if doreg}",
    		ctx
    	});

    	return block;
    }

    // (23:6) <FB line="b3">
    function create_default_slot_6$5(ctx) {
    	let text_1;
    	let updating_value;
    	let current;

    	function text_1_value_binding_1(value) {
    		/*text_1_value_binding_1*/ ctx[9](value);
    	}

    	let text_1_props = { lab: "EMAIL" };

    	if (/*email*/ ctx[1] !== void 0) {
    		text_1_props.value = /*email*/ ctx[1];
    	}

    	text_1 = new Text$1({ props: text_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(text_1, 'value', text_1_value_binding_1));

    	const block = {
    		c: function create() {
    			create_component(text_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(text_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const text_1_changes = {};

    			if (!updating_value && dirty & /*email*/ 2) {
    				updating_value = true;
    				text_1_changes.value = /*email*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			text_1.$set(text_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(text_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$5.name,
    		type: "slot",
    		source: "(23:6) <FB line=\\\"b3\\\">",
    		ctx
    	});

    	return block;
    }

    // (27:4) <FB line="b3">
    function create_default_slot_5$6(ctx) {
    	let text_1;
    	let updating_value;
    	let current;

    	function text_1_value_binding_2(value) {
    		/*text_1_value_binding_2*/ ctx[10](value);
    	}

    	let text_1_props = { lab: "PASS" };

    	if (/*pass*/ ctx[2] !== void 0) {
    		text_1_props.value = /*pass*/ ctx[2];
    	}

    	text_1 = new Text$1({ props: text_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(text_1, 'value', text_1_value_binding_2));

    	const block = {
    		c: function create() {
    			create_component(text_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(text_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const text_1_changes = {};

    			if (!updating_value && dirty & /*pass*/ 4) {
    				updating_value = true;
    				text_1_changes.value = /*pass*/ ctx[2];
    				add_flush_callback(() => updating_value = false);
    			}

    			text_1.$set(text_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(text_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$6.name,
    		type: "slot",
    		source: "(27:4) <FB line=\\\"b3\\\">",
    		ctx
    	});

    	return block;
    }

    // (34:6) {:else}
    function create_else_block$8(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				cond: /*logw*/ ctx[5],
    				global: true,
    				bounce: true,
    				$$slots: { default: [create_default_slot_4$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(34:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (32:6) {#if doreg}
    function create_if_block$g(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				cond: /*regw*/ ctx[6],
    				global: true,
    				bounce: true,
    				$$slots: { default: [create_default_slot_3$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(32:6) {#if doreg}",
    		ctx
    	});

    	return block;
    }

    // (35:8) <Link cond={logw} global bounce>
    function create_default_slot_4$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("LOGIN");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$6.name,
    		type: "slot",
    		source: "(35:8) <Link cond={logw} global bounce>",
    		ctx
    	});

    	return block;
    }

    // (33:8) <Link cond={regw} global bounce>
    function create_default_slot_3$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("REGISTER");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$9.name,
    		type: "slot",
    		source: "(33:8) <Link cond={regw} global bounce>",
    		ctx
    	});

    	return block;
    }

    // (31:4) <FB flip line="b3">
    function create_default_slot_2$c(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$g, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*doreg*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$c.name,
    		type: "slot",
    		source: "(31:4) <FB flip line=\\\"b3\\\">",
    		ctx
    	});

    	return block;
    }

    // (18:2) <FB vert w={50} lw={5} c="login-form">
    function create_default_slot_1$e(ctx) {
    	let fb0;
    	let t0;
    	let t1;
    	let fb1;
    	let t2;
    	let fb2;
    	let t3;
    	let fb3;
    	let current;

    	fb0 = new FB({
    			props: {
    				line: "b3",
    				$$slots: { default: [create_default_slot_7$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*doreg*/ ctx[3] && create_if_block_1$8(ctx);

    	fb1 = new FB({
    			props: {
    				line: "b3",
    				$$slots: { default: [create_default_slot_5$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb2 = new FB({ props: { spacer: "3" }, $$inline: true });

    	fb3 = new FB({
    			props: {
    				flip: true,
    				line: "b3",
    				$$slots: { default: [create_default_slot_2$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(fb1.$$.fragment);
    			t2 = space();
    			create_component(fb2.$$.fragment);
    			t3 = space();
    			create_component(fb3.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(fb2, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(fb3, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope, handle*/ 8193) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);

    			if (/*doreg*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*doreg*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t1.parentNode, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const fb1_changes = {};

    			if (dirty & /*$$scope, pass*/ 8196) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    			const fb3_changes = {};

    			if (dirty & /*$$scope, doreg*/ 8200) {
    				fb3_changes.$$scope = { dirty, ctx };
    			}

    			fb3.$set(fb3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(fb2.$$.fragment, local);
    			transition_in(fb3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(fb2.$$.fragment, local);
    			transition_out(fb3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(fb2, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(fb3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$e.name,
    		type: "slot",
    		source: "(18:2) <FB vert w={50} lw={5} c=\\\"login-form\\\">",
    		ctx
    	});

    	return block;
    }

    // (17:0) <FB center>
    function create_default_slot$j(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				w: 50,
    				lw: 5,
    				c: "login-form",
    				$$slots: { default: [create_default_slot_1$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, doreg, pass, email, handle*/ 8207) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(17:0) <FB center>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$N(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				center: true,
    				$$slots: { default: [create_default_slot$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, doreg, pass, email, handle*/ 8207) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let doreg;
    	let $loc;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Login', slots, []);
    	const login = getContext('login');
    	const register = getContext('register');
    	const loc = getContext('loc');
    	validate_store(loc, 'loc');
    	component_subscribe($$self, loc, value => $$invalidate(7, $loc = value));
    	let handle;
    	let email;
    	let pass;
    	const logw = () => login({ handle, pass });
    	const regw = () => register({ handle, email, pass });
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Login> was created with unknown prop '${key}'`);
    	});

    	function text_1_value_binding(value) {
    		handle = value;
    		$$invalidate(0, handle);
    	}

    	function text_1_value_binding_1(value) {
    		email = value;
    		$$invalidate(1, email);
    	}

    	function text_1_value_binding_2(value) {
    		pass = value;
    		$$invalidate(2, pass);
    	}

    	$$self.$capture_state = () => ({
    		Link: Link$1,
    		FB,
    		Text: Text$1,
    		getContext,
    		login,
    		register,
    		loc,
    		handle,
    		email,
    		pass,
    		logw,
    		regw,
    		doreg,
    		$loc
    	});

    	$$self.$inject_state = $$props => {
    		if ('handle' in $$props) $$invalidate(0, handle = $$props.handle);
    		if ('email' in $$props) $$invalidate(1, email = $$props.email);
    		if ('pass' in $$props) $$invalidate(2, pass = $$props.pass);
    		if ('doreg' in $$props) $$invalidate(3, doreg = $$props.doreg);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$loc*/ 128) {
    			$$invalidate(3, doreg = $loc.title == 'register');
    		}
    	};

    	return [
    		handle,
    		email,
    		pass,
    		doreg,
    		loc,
    		logw,
    		regw,
    		$loc,
    		text_1_value_binding,
    		text_1_value_binding_1,
    		text_1_value_binding_2
    	];
    }

    class Login extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Login",
    			options,
    			id: create_fragment$N.name
    		});
    	}
    }

    /* src/special/User.svelte generated by Svelte v3.44.3 */
    const file$x = "src/special/User.svelte";

    // (7:0) {#if $hasuser}
    function create_if_block$f(ctx) {
    	let h1;
    	let t0_value = /*$user*/ ctx[1].val.handle + "";
    	let t0;
    	let t1;
    	let p;
    	let t2;
    	let t3_value = /*$user*/ ctx[1].val.createdAt + "";
    	let t3;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			t0 = text(t0_value);
    			t1 = space();
    			p = element("p");
    			t2 = text("Circa ");
    			t3 = text(t3_value);
    			add_location(h1, file$x, 7, 2, 149);
    			add_location(p, file$x, 8, 2, 179);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			append_dev(h1, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t2);
    			append_dev(p, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$user*/ 2 && t0_value !== (t0_value = /*$user*/ ctx[1].val.handle + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$user*/ 2 && t3_value !== (t3_value = /*$user*/ ctx[1].val.createdAt + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(7:0) {#if $hasuser}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let if_block_anchor;
    	let if_block = /*$hasuser*/ ctx[0] && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$hasuser*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let $hasuser;
    	let $user;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('User', slots, []);
    	const hasuser = getContext('hasuser');
    	validate_store(hasuser, 'hasuser');
    	component_subscribe($$self, hasuser, value => $$invalidate(0, $hasuser = value));
    	const user = getContext('user');
    	validate_store(user, 'user');
    	component_subscribe($$self, user, value => $$invalidate(1, $user = value));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<User> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		getContext,
    		hasuser,
    		user,
    		$hasuser,
    		$user
    	});

    	return [$hasuser, $user, hasuser, user];
    }

    class User extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "User",
    			options,
    			id: create_fragment$M.name
    		});
    	}
    }

    /* src/PaginLink.svelte generated by Svelte v3.44.3 */
    const file$w = "src/PaginLink.svelte";

    // (28:0) {:else}
    function create_else_block$7(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				c: "pagination-link disabled"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(28:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (21:17) 
    function create_if_block_2$4(ctx) {
    	let link;
    	let updating_current;
    	let current;

    	function link_current_binding(value) {
    		/*link_current_binding*/ ctx[7](value);
    	}

    	let link_props = {
    		self: true,
    		global: true,
    		opt: { pg: /*pnum*/ ctx[0] },
    		$$slots: { default: [create_default_slot_1$d] },
    		$$scope: { ctx }
    	};

    	if (/*cur*/ ctx[4] !== void 0) {
    		link_props.current = /*cur*/ ctx[4];
    	}

    	link = new Link$1({ props: link_props, $$inline: true });
    	binding_callbacks.push(() => bind(link, 'current', link_current_binding));

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*pnum*/ 1) link_changes.opt = { pg: /*pnum*/ ctx[0] };

    			if (dirty & /*$$scope, flip, labelc, lab, pnum*/ 611) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_current && dirty & /*cur*/ 16) {
    				updating_current = true;
    				link_changes.current = /*cur*/ ctx[4];
    				add_flush_callback(() => updating_current = false);
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(21:17) ",
    		ctx
    	});

    	return block;
    }

    // (16:0) {#if nolink}
    function create_if_block$e(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				flip: /*flip*/ ctx[5],
    				c: "pagination-link " + /*labelc*/ ctx[6],
    				$$slots: { default: [create_default_slot$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};
    			if (dirty & /*flip*/ 32) fb_changes.flip = /*flip*/ ctx[5];
    			if (dirty & /*labelc*/ 64) fb_changes.c = "pagination-link " + /*labelc*/ ctx[6];

    			if (dirty & /*$$scope, lab, pnum*/ 515) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(16:0) {#if nolink}",
    		ctx
    	});

    	return block;
    }

    // (25:6) {#if lab}
    function create_if_block_3$3(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*lab*/ ctx[1]);
    			attr_dev(span, "class", "pagination-lab");
    			add_location(span, file$w, 24, 15, 739);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*lab*/ 2) set_data_dev(t, /*lab*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(25:6) {#if lab}",
    		ctx
    	});

    	return block;
    }

    // (23:4) <FB vert {flip} c="pagination-link {labelc}">
    function create_default_slot_2$b(ctx) {
    	let span;
    	let t0;
    	let t1;
    	let if_block_anchor;
    	let if_block = /*lab*/ ctx[1] && create_if_block_3$3(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(/*pnum*/ ctx[0]);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    			attr_dev(span, "class", "pagination-num");
    			add_location(span, file$w, 23, 6, 681);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*pnum*/ 1) set_data_dev(t0, /*pnum*/ ctx[0]);

    			if (/*lab*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$b.name,
    		type: "slot",
    		source: "(23:4) <FB vert {flip} c=\\\"pagination-link {labelc}\\\">",
    		ctx
    	});

    	return block;
    }

    // (22:2) <Link bind:current={cur} self global opt={{pg: pnum}}>
    function create_default_slot_1$d(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				flip: /*flip*/ ctx[5],
    				c: "pagination-link " + /*labelc*/ ctx[6],
    				$$slots: { default: [create_default_slot_2$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};
    			if (dirty & /*flip*/ 32) fb_changes.flip = /*flip*/ ctx[5];
    			if (dirty & /*labelc*/ 64) fb_changes.c = "pagination-link " + /*labelc*/ ctx[6];

    			if (dirty & /*$$scope, lab, pnum*/ 515) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$d.name,
    		type: "slot",
    		source: "(22:2) <Link bind:current={cur} self global opt={{pg: pnum}}>",
    		ctx
    	});

    	return block;
    }

    // (19:4) {#if lab}
    function create_if_block_1$7(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*lab*/ ctx[1]);
    			attr_dev(span, "class", "pagination-lab");
    			add_location(span, file$w, 18, 13, 495);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*lab*/ 2) set_data_dev(t, /*lab*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(19:4) {#if lab}",
    		ctx
    	});

    	return block;
    }

    // (17:2) <FB vert {flip} c="pagination-link {labelc}">
    function create_default_slot$i(ctx) {
    	let span;
    	let t0;
    	let t1;
    	let if_block_anchor;
    	let if_block = /*lab*/ ctx[1] && create_if_block_1$7(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(/*pnum*/ ctx[0]);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    			attr_dev(span, "class", "pagination-num");
    			add_location(span, file$w, 17, 4, 439);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*pnum*/ 1) set_data_dev(t0, /*pnum*/ ctx[0]);

    			if (/*lab*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$7(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(17:2) <FB vert {flip} c=\\\"pagination-link {labelc}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$e, create_if_block_2$4, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*nolink*/ ctx[3]) return 0;
    		if (/*enable*/ ctx[2]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let labelc;
    	let flip;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PaginLink', slots, []);
    	const loc = getContext('loc');
    	let { pnum } = $$props;
    	let { lab = null } = $$props;
    	let { enable = true } = $$props;
    	let { nolink = false } = $$props;
    	let cur = false;
    	const writable_props = ['pnum', 'lab', 'enable', 'nolink'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PaginLink> was created with unknown prop '${key}'`);
    	});

    	function link_current_binding(value) {
    		cur = value;
    		$$invalidate(4, cur);
    	}

    	$$self.$$set = $$props => {
    		if ('pnum' in $$props) $$invalidate(0, pnum = $$props.pnum);
    		if ('lab' in $$props) $$invalidate(1, lab = $$props.lab);
    		if ('enable' in $$props) $$invalidate(2, enable = $$props.enable);
    		if ('nolink' in $$props) $$invalidate(3, nolink = $$props.nolink);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		R2,
    		Link: Link$1,
    		getContext,
    		loc,
    		pnum,
    		lab,
    		enable,
    		nolink,
    		cur,
    		flip,
    		labelc
    	});

    	$$self.$inject_state = $$props => {
    		if ('pnum' in $$props) $$invalidate(0, pnum = $$props.pnum);
    		if ('lab' in $$props) $$invalidate(1, lab = $$props.lab);
    		if ('enable' in $$props) $$invalidate(2, enable = $$props.enable);
    		if ('nolink' in $$props) $$invalidate(3, nolink = $$props.nolink);
    		if ('cur' in $$props) $$invalidate(4, cur = $$props.cur);
    		if ('flip' in $$props) $$invalidate(5, flip = $$props.flip);
    		if ('labelc' in $$props) $$invalidate(6, labelc = $$props.labelc);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*lab*/ 2) {
    			$$invalidate(6, labelc = lab ? 'labeled' : '');
    		}

    		if ($$self.$$.dirty & /*lab, cur, nolink*/ 26) {
    			$$invalidate(5, flip = !lab || cur || nolink);
    		}
    	};

    	return [pnum, lab, enable, nolink, cur, flip, labelc, link_current_binding];
    }

    class PaginLink extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, { pnum: 0, lab: 1, enable: 2, nolink: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PaginLink",
    			options,
    			id: create_fragment$L.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*pnum*/ ctx[0] === undefined && !('pnum' in props)) {
    			console.warn("<PaginLink> was created without expected prop 'pnum'");
    		}
    	}

    	get pnum() {
    		throw new Error("<PaginLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pnum(value) {
    		throw new Error("<PaginLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lab() {
    		throw new Error("<PaginLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lab(value) {
    		throw new Error("<PaginLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get enable() {
    		throw new Error("<PaginLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set enable(value) {
    		throw new Error("<PaginLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nolink() {
    		throw new Error("<PaginLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nolink(value) {
    		throw new Error("<PaginLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/SearchInter.svelte generated by Svelte v3.44.3 */
    const file$v = "src/SearchInter.svelte";

    // (9:0) {:else}
    function create_else_block$6(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "pagination-inter");
    			add_location(span, file$v, 9, 2, 161);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(9:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (7:0) {#if cond}
    function create_if_block$d(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "·";
    			attr_dev(span, "class", "pagination-inter");
    			add_location(span, file$v, 7, 2, 104);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(7:0) {#if cond}",
    		ctx
    	});

    	return block;
    }

    // (6:0) <FB vert flip>
    function create_default_slot$h(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*cond*/ ctx[0]) return create_if_block$d;
    		return create_else_block$6;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(6:0) <FB vert flip>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				flip: true,
    				$$slots: { default: [create_default_slot$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, cond*/ 3) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SearchInter', slots, []);
    	let { cond = true } = $$props;
    	const writable_props = ['cond'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SearchInter> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('cond' in $$props) $$invalidate(0, cond = $$props.cond);
    	};

    	$$self.$capture_state = () => ({ FB, cond });

    	$$self.$inject_state = $$props => {
    		if ('cond' in $$props) $$invalidate(0, cond = $$props.cond);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [cond];
    }

    class SearchInter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, { cond: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SearchInter",
    			options,
    			id: create_fragment$K.name
    		});
    	}

    	get cond() {
    		throw new Error("<SearchInter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cond(value) {
    		throw new Error("<SearchInter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/SearchWing.svelte generated by Svelte v3.44.3 */

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (25:0) {#each wing as x}
    function create_each_block$6(ctx) {
    	let paginlink;
    	let t;
    	let searchinter;
    	let current;

    	paginlink = new PaginLink({
    			props: {
    				pnum: /*next*/ ctx[3](/*x*/ ctx[9]),
    				enable: /*cond*/ ctx[4](/*x*/ ctx[9])
    			},
    			$$inline: true
    		});

    	searchinter = new SearchInter({
    			props: {
    				cond: /*cond*/ ctx[4](/*x*/ ctx[9]) && /*cond*/ ctx[4](/*x*/ ctx[9] + 1) && /*x*/ ctx[9] < /*width*/ ctx[1] - 1
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(paginlink.$$.fragment);
    			t = space();
    			create_component(searchinter.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(paginlink, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(searchinter, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const paginlink_changes = {};
    			if (dirty & /*wing*/ 4) paginlink_changes.pnum = /*next*/ ctx[3](/*x*/ ctx[9]);
    			if (dirty & /*wing*/ 4) paginlink_changes.enable = /*cond*/ ctx[4](/*x*/ ctx[9]);
    			paginlink.$set(paginlink_changes);
    			const searchinter_changes = {};
    			if (dirty & /*wing, width*/ 6) searchinter_changes.cond = /*cond*/ ctx[4](/*x*/ ctx[9]) && /*cond*/ ctx[4](/*x*/ ctx[9] + 1) && /*x*/ ctx[9] < /*width*/ ctx[1] - 1;
    			searchinter.$set(searchinter_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(paginlink.$$.fragment, local);
    			transition_in(searchinter.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(paginlink.$$.fragment, local);
    			transition_out(searchinter.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(paginlink, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(searchinter, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(25:0) {#each wing as x}",
    		ctx
    	});

    	return block;
    }

    // (24:0) <FB flip={neg}>
    function create_default_slot$g(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*wing*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*cond, wing, width, next*/ 30) {
    				each_value = /*wing*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(24:0) <FB flip={neg}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				flip: /*neg*/ ctx[0],
    				$$slots: { default: [create_default_slot$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*neg*/ 1) fb_changes.flip = /*neg*/ ctx[0];

    			if (dirty & /*$$scope, wing, width*/ 4102) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let delt;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SearchWing', slots, []);
    	let { neg = false } = $$props;
    	let { width = 5 } = $$props;
    	let { page = 1 } = $$props;
    	let { pages = 1 } = $$props;
    	let wing = [];

    	const rewing = () => {
    		$$invalidate(2, wing = [...Array(width).keys()]);
    	};

    	const next = x => {
    		return page + x * delt + 2 * delt;
    	};

    	const cond = x => {
    		const nx = next(x);
    		return neg ? nx > 1 : nx < pages;
    	};

    	const writable_props = ['neg', 'width', 'page', 'pages'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SearchWing> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('neg' in $$props) $$invalidate(0, neg = $$props.neg);
    		if ('width' in $$props) $$invalidate(1, width = $$props.width);
    		if ('page' in $$props) $$invalidate(5, page = $$props.page);
    		if ('pages' in $$props) $$invalidate(6, pages = $$props.pages);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		PaginLink,
    		SearchInter,
    		neg,
    		width,
    		page,
    		pages,
    		wing,
    		rewing,
    		next,
    		cond,
    		delt
    	});

    	$$self.$inject_state = $$props => {
    		if ('neg' in $$props) $$invalidate(0, neg = $$props.neg);
    		if ('width' in $$props) $$invalidate(1, width = $$props.width);
    		if ('page' in $$props) $$invalidate(5, page = $$props.page);
    		if ('pages' in $$props) $$invalidate(6, pages = $$props.pages);
    		if ('wing' in $$props) $$invalidate(2, wing = $$props.wing);
    		if ('delt' in $$props) delt = $$props.delt;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*neg*/ 1) {
    			delt = neg ? -1 : 1;
    		}

    		if ($$self.$$.dirty & /*width, page, pages*/ 98) {
    			rewing();
    		}
    	};

    	return [neg, width, wing, next, cond, page, pages];
    }

    class SearchWing extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, { neg: 0, width: 1, page: 5, pages: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SearchWing",
    			options,
    			id: create_fragment$J.name
    		});
    	}

    	get neg() {
    		throw new Error("<SearchWing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set neg(value) {
    		throw new Error("<SearchWing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<SearchWing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<SearchWing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get page() {
    		throw new Error("<SearchWing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set page(value) {
    		throw new Error("<SearchWing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pages() {
    		throw new Error("<SearchWing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pages(value) {
    		throw new Error("<SearchWing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/SearchPagination.svelte generated by Svelte v3.44.3 */

    // (20:0) {#if result}
    function create_if_block$c(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				between: true,
    				c: "pagination",
    				$$slots: { default: [create_default_slot$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, result, lastpage, width, nextpage, prevpage, firstpage*/ 127) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(20:0) {#if result}",
    		ctx
    	});

    	return block;
    }

    // (24:4) <FB c="pagination-center">
    function create_default_slot_1$c(ctx) {
    	let paginlink0;
    	let t0;
    	let searchinter0;
    	let t1;
    	let paginlink1;
    	let t2;
    	let searchinter1;
    	let t3;
    	let paginlink2;
    	let current;

    	paginlink0 = new PaginLink({
    			props: {
    				lab: "PREV",
    				pnum: /*result*/ ctx[0].page - 1,
    				enable: /*prevpage*/ ctx[4]
    			},
    			$$inline: true
    		});

    	searchinter0 = new SearchInter({
    			props: { cond: /*prevpage*/ ctx[4] },
    			$$inline: true
    		});

    	paginlink1 = new PaginLink({
    			props: {
    				lab: "PAGE",
    				pnum: /*result*/ ctx[0].page,
    				nolink: true
    			},
    			$$inline: true
    		});

    	searchinter1 = new SearchInter({
    			props: { cond: /*nextpage*/ ctx[5] },
    			$$inline: true
    		});

    	paginlink2 = new PaginLink({
    			props: {
    				lab: "NEXT",
    				pnum: /*result*/ ctx[0].page + 1,
    				enable: /*nextpage*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(paginlink0.$$.fragment);
    			t0 = space();
    			create_component(searchinter0.$$.fragment);
    			t1 = space();
    			create_component(paginlink1.$$.fragment);
    			t2 = space();
    			create_component(searchinter1.$$.fragment);
    			t3 = space();
    			create_component(paginlink2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(paginlink0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(searchinter0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(paginlink1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(searchinter1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(paginlink2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const paginlink0_changes = {};
    			if (dirty & /*result*/ 1) paginlink0_changes.pnum = /*result*/ ctx[0].page - 1;
    			if (dirty & /*prevpage*/ 16) paginlink0_changes.enable = /*prevpage*/ ctx[4];
    			paginlink0.$set(paginlink0_changes);
    			const searchinter0_changes = {};
    			if (dirty & /*prevpage*/ 16) searchinter0_changes.cond = /*prevpage*/ ctx[4];
    			searchinter0.$set(searchinter0_changes);
    			const paginlink1_changes = {};
    			if (dirty & /*result*/ 1) paginlink1_changes.pnum = /*result*/ ctx[0].page;
    			paginlink1.$set(paginlink1_changes);
    			const searchinter1_changes = {};
    			if (dirty & /*nextpage*/ 32) searchinter1_changes.cond = /*nextpage*/ ctx[5];
    			searchinter1.$set(searchinter1_changes);
    			const paginlink2_changes = {};
    			if (dirty & /*result*/ 1) paginlink2_changes.pnum = /*result*/ ctx[0].page + 1;
    			if (dirty & /*nextpage*/ 32) paginlink2_changes.enable = /*nextpage*/ ctx[5];
    			paginlink2.$set(paginlink2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(paginlink0.$$.fragment, local);
    			transition_in(searchinter0.$$.fragment, local);
    			transition_in(paginlink1.$$.fragment, local);
    			transition_in(searchinter1.$$.fragment, local);
    			transition_in(paginlink2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(paginlink0.$$.fragment, local);
    			transition_out(searchinter0.$$.fragment, local);
    			transition_out(paginlink1.$$.fragment, local);
    			transition_out(searchinter1.$$.fragment, local);
    			transition_out(paginlink2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(paginlink0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(searchinter0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(paginlink1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(searchinter1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(paginlink2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(24:4) <FB c=\\\"pagination-center\\\">",
    		ctx
    	});

    	return block;
    }

    // (21:2) <FB between c="pagination">
    function create_default_slot$f(ctx) {
    	let paginlink0;
    	let t0;
    	let searchwing0;
    	let t1;
    	let fb;
    	let t2;
    	let searchwing1;
    	let t3;
    	let paginlink1;
    	let current;

    	paginlink0 = new PaginLink({
    			props: {
    				lab: "FIRST",
    				pnum: 1,
    				enable: !/*firstpage*/ ctx[2]
    			},
    			$$inline: true
    		});

    	searchwing0 = new SearchWing({
    			props: {
    				width: /*width*/ ctx[1],
    				neg: true,
    				page: /*result*/ ctx[0].page,
    				pages: /*result*/ ctx[0].pages
    			},
    			$$inline: true
    		});

    	fb = new FB({
    			props: {
    				c: "pagination-center",
    				$$slots: { default: [create_default_slot_1$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	searchwing1 = new SearchWing({
    			props: {
    				width: /*width*/ ctx[1],
    				page: /*result*/ ctx[0].page,
    				pages: /*result*/ ctx[0].pages
    			},
    			$$inline: true
    		});

    	paginlink1 = new PaginLink({
    			props: {
    				lab: "LAST",
    				pnum: /*result*/ ctx[0].pages,
    				enable: !/*lastpage*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(paginlink0.$$.fragment);
    			t0 = space();
    			create_component(searchwing0.$$.fragment);
    			t1 = space();
    			create_component(fb.$$.fragment);
    			t2 = space();
    			create_component(searchwing1.$$.fragment);
    			t3 = space();
    			create_component(paginlink1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(paginlink0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(searchwing0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(searchwing1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(paginlink1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const paginlink0_changes = {};
    			if (dirty & /*firstpage*/ 4) paginlink0_changes.enable = !/*firstpage*/ ctx[2];
    			paginlink0.$set(paginlink0_changes);
    			const searchwing0_changes = {};
    			if (dirty & /*width*/ 2) searchwing0_changes.width = /*width*/ ctx[1];
    			if (dirty & /*result*/ 1) searchwing0_changes.page = /*result*/ ctx[0].page;
    			if (dirty & /*result*/ 1) searchwing0_changes.pages = /*result*/ ctx[0].pages;
    			searchwing0.$set(searchwing0_changes);
    			const fb_changes = {};

    			if (dirty & /*$$scope, result, nextpage, prevpage*/ 113) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    			const searchwing1_changes = {};
    			if (dirty & /*width*/ 2) searchwing1_changes.width = /*width*/ ctx[1];
    			if (dirty & /*result*/ 1) searchwing1_changes.page = /*result*/ ctx[0].page;
    			if (dirty & /*result*/ 1) searchwing1_changes.pages = /*result*/ ctx[0].pages;
    			searchwing1.$set(searchwing1_changes);
    			const paginlink1_changes = {};
    			if (dirty & /*result*/ 1) paginlink1_changes.pnum = /*result*/ ctx[0].pages;
    			if (dirty & /*lastpage*/ 8) paginlink1_changes.enable = !/*lastpage*/ ctx[3];
    			paginlink1.$set(paginlink1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(paginlink0.$$.fragment, local);
    			transition_in(searchwing0.$$.fragment, local);
    			transition_in(fb.$$.fragment, local);
    			transition_in(searchwing1.$$.fragment, local);
    			transition_in(paginlink1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(paginlink0.$$.fragment, local);
    			transition_out(searchwing0.$$.fragment, local);
    			transition_out(fb.$$.fragment, local);
    			transition_out(searchwing1.$$.fragment, local);
    			transition_out(paginlink1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(paginlink0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(searchwing0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(searchwing1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(paginlink1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(21:2) <FB between c=\\\"pagination\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*result*/ ctx[0] && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*result*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*result*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SearchPagination', slots, []);
    	let { result = null } = $$props;
    	let { width = 5 } = $$props;
    	let firstpage, lastpage, prevpage, nextpage;
    	const writable_props = ['result', 'width'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SearchPagination> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('result' in $$props) $$invalidate(0, result = $$props.result);
    		if ('width' in $$props) $$invalidate(1, width = $$props.width);
    	};

    	$$self.$capture_state = () => ({
    		Link: Link$1,
    		FB,
    		PaginLink,
    		SearchInter,
    		SearchWing,
    		result,
    		width,
    		firstpage,
    		lastpage,
    		prevpage,
    		nextpage
    	});

    	$$self.$inject_state = $$props => {
    		if ('result' in $$props) $$invalidate(0, result = $$props.result);
    		if ('width' in $$props) $$invalidate(1, width = $$props.width);
    		if ('firstpage' in $$props) $$invalidate(2, firstpage = $$props.firstpage);
    		if ('lastpage' in $$props) $$invalidate(3, lastpage = $$props.lastpage);
    		if ('prevpage' in $$props) $$invalidate(4, prevpage = $$props.prevpage);
    		if ('nextpage' in $$props) $$invalidate(5, nextpage = $$props.nextpage);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*result*/ 1) {
    			if (result) {
    				$$invalidate(2, firstpage = result.page <= 1);
    				$$invalidate(3, lastpage = result.page >= result.pages);
    				$$invalidate(4, prevpage = result.page - 1 > 1);
    				$$invalidate(5, nextpage = result.page + 1 < result.pages);
    			}
    		}
    	};

    	return [result, width, firstpage, lastpage, prevpage, nextpage];
    }

    class SearchPagination extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$I, safe_not_equal, { result: 0, width: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SearchPagination",
    			options,
    			id: create_fragment$I.name
    		});
    	}

    	get result() {
    		throw new Error("<SearchPagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set result(value) {
    		throw new Error("<SearchPagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<SearchPagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<SearchPagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/special/Search.svelte generated by Svelte v3.44.3 */
    const file$u = "src/special/Search.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (23:0) {#if result && result.items}
    function create_if_block$b(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				expand: true,
    				c: "results search-results",
    				$$slots: { default: [create_default_slot_1$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, result*/ 129) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(23:0) {#if result && result.items}",
    		ctx
    	});

    	return block;
    }

    // (25:4) <FB c="results-heading">
    function create_default_slot_5$5(ctx) {
    	let div0;
    	let t1;
    	let div1;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "TITLE";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "TEXT";
    			attr_dev(div0, "class", "results-cell col1");
    			add_location(div0, file$u, 25, 6, 602);
    			attr_dev(div1, "class", "results-cell col2");
    			add_location(div1, file$u, 26, 6, 651);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$5.name,
    		type: "slot",
    		source: "(25:4) <FB c=\\\"results-heading\\\">",
    		ctx
    	});

    	return block;
    }

    // (33:12) {#if item.namespace != 'main'}
    function create_if_block_1$6(ctx) {
    	let span;
    	let t0;
    	let t1_value = /*item*/ ctx[4].namespace + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text("(");
    			t1 = text(t1_value);
    			t2 = text(")");
    			attr_dev(span, "class", "ns-header");
    			add_location(span, file$u, 33, 14, 918);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			append_dev(span, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*result*/ 1 && t1_value !== (t1_value = /*item*/ ctx[4].namespace + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(33:12) {#if item.namespace != 'main'}",
    		ctx
    	});

    	return block;
    }

    // (36:12) <Link space={item.namespace} title={item.plain} nored>
    function create_default_slot_4$5(ctx) {
    	let searchemph;
    	let current;

    	searchemph = new SearchEmph({
    			props: { text: /*item*/ ctx[4].title },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(searchemph.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(searchemph, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const searchemph_changes = {};
    			if (dirty & /*result*/ 1) searchemph_changes.text = /*item*/ ctx[4].title;
    			searchemph.$set(searchemph_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(searchemph.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(searchemph.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(searchemph, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$5.name,
    		type: "slot",
    		source: "(36:12) <Link space={item.namespace} title={item.plain} nored>",
    		ctx
    	});

    	return block;
    }

    // (31:8) <FB c="results-row">
    function create_default_slot_3$8(ctx) {
    	let div0;
    	let t0;
    	let link;
    	let t1;
    	let div1;
    	let searchemph;
    	let t2;
    	let current;
    	let if_block = /*item*/ ctx[4].namespace != 'main' && create_if_block_1$6(ctx);

    	link = new Link$1({
    			props: {
    				space: /*item*/ ctx[4].namespace,
    				title: /*item*/ ctx[4].plain,
    				nored: true,
    				$$slots: { default: [create_default_slot_4$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	searchemph = new SearchEmph({
    			props: { text: /*item*/ ctx[4].body },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			create_component(link.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			create_component(searchemph.$$.fragment);
    			t2 = space();
    			attr_dev(div0, "class", "results-cell col1 title-header");
    			add_location(div0, file$u, 31, 10, 816);
    			attr_dev(div1, "class", "results-cell col2 body-header");
    			add_location(div1, file$u, 39, 10, 1146);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			if (if_block) if_block.m(div0, null);
    			append_dev(div0, t0);
    			mount_component(link, div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(searchemph, div1, null);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*item*/ ctx[4].namespace != 'main') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$6(ctx);
    					if_block.c();
    					if_block.m(div0, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const link_changes = {};
    			if (dirty & /*result*/ 1) link_changes.space = /*item*/ ctx[4].namespace;
    			if (dirty & /*result*/ 1) link_changes.title = /*item*/ ctx[4].plain;

    			if (dirty & /*$$scope, result*/ 129) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    			const searchemph_changes = {};
    			if (dirty & /*result*/ 1) searchemph_changes.text = /*item*/ ctx[4].body;
    			searchemph.$set(searchemph_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			transition_in(searchemph.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			transition_out(searchemph.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (if_block) if_block.d();
    			destroy_component(link);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(searchemph);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$8.name,
    		type: "slot",
    		source: "(31:8) <FB c=\\\"results-row\\\">",
    		ctx
    	});

    	return block;
    }

    // (30:6) {#each result.items as item}
    function create_each_block$5(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: "results-row",
    				$$slots: { default: [create_default_slot_3$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, result*/ 129) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(30:6) {#each result.items as item}",
    		ctx
    	});

    	return block;
    }

    // (29:4) <FB expand vert c="results-items">
    function create_default_slot_2$a(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*result*/ ctx[0].items;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*result*/ 1) {
    				each_value = /*result*/ ctx[0].items;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$a.name,
    		type: "slot",
    		source: "(29:4) <FB expand vert c=\\\"results-items\\\">",
    		ctx
    	});

    	return block;
    }

    // (24:2) <FB vert expand c="results search-results">
    function create_default_slot_1$b(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				c: "results-heading",
    				$$slots: { default: [create_default_slot_5$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				expand: true,
    				vert: true,
    				c: "results-items",
    				$$slots: { default: [create_default_slot_2$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope, result*/ 129) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(24:2) <FB vert expand c=\\\"results search-results\\\">",
    		ctx
    	});

    	return block;
    }

    // (12:0) <FB vert expand>
    function create_default_slot$e(ctx) {
    	let searchbar;
    	let updating_result;
    	let t0;
    	let t1;
    	let searchpagination;
    	let current;

    	function searchbar_result_binding(value) {
    		/*searchbar_result_binding*/ ctx[3](value);
    	}

    	let searchbar_props = {
    		query: /*$loc*/ ctx[1].sub[0],
    		pgOpt: /*$loc*/ ctx[1].opt.pg,
    		szOpt: /*$loc*/ ctx[1].opt.sz,
    		inf: /*$loc*/ ctx[1].opt.inf,
    		inhOpt: /*$loc*/ ctx[1].opt.inh,
    		options: true
    	};

    	if (/*result*/ ctx[0] !== void 0) {
    		searchbar_props.result = /*result*/ ctx[0];
    	}

    	searchbar = new SearchBar({ props: searchbar_props, $$inline: true });
    	binding_callbacks.push(() => bind(searchbar, 'result', searchbar_result_binding));
    	let if_block = /*result*/ ctx[0] && /*result*/ ctx[0].items && create_if_block$b(ctx);

    	searchpagination = new SearchPagination({
    			props: { result: /*result*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(searchbar.$$.fragment);
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(searchpagination.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(searchbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(searchpagination, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const searchbar_changes = {};
    			if (dirty & /*$loc*/ 2) searchbar_changes.query = /*$loc*/ ctx[1].sub[0];
    			if (dirty & /*$loc*/ 2) searchbar_changes.pgOpt = /*$loc*/ ctx[1].opt.pg;
    			if (dirty & /*$loc*/ 2) searchbar_changes.szOpt = /*$loc*/ ctx[1].opt.sz;
    			if (dirty & /*$loc*/ 2) searchbar_changes.inf = /*$loc*/ ctx[1].opt.inf;
    			if (dirty & /*$loc*/ 2) searchbar_changes.inhOpt = /*$loc*/ ctx[1].opt.inh;

    			if (!updating_result && dirty & /*result*/ 1) {
    				updating_result = true;
    				searchbar_changes.result = /*result*/ ctx[0];
    				add_flush_callback(() => updating_result = false);
    			}

    			searchbar.$set(searchbar_changes);

    			if (/*result*/ ctx[0] && /*result*/ ctx[0].items) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*result*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t1.parentNode, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const searchpagination_changes = {};
    			if (dirty & /*result*/ 1) searchpagination_changes.result = /*result*/ ctx[0];
    			searchpagination.$set(searchpagination_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(searchbar.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(searchpagination.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(searchbar.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(searchpagination.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(searchbar, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(searchpagination, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(12:0) <FB vert expand>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				expand: true,
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, result, $loc*/ 131) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let $loc;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Search', slots, []);
    	const loc = getContext('loc');
    	validate_store(loc, 'loc');
    	component_subscribe($$self, loc, value => $$invalidate(1, $loc = value));
    	let result;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Search> was created with unknown prop '${key}'`);
    	});

    	function searchbar_result_binding(value) {
    		result = value;
    		$$invalidate(0, result);
    	}

    	$$self.$capture_state = () => ({
    		Link: Link$1,
    		FB,
    		SearchBar,
    		SearchEmph,
    		SearchPagination,
    		getContext,
    		loc,
    		result,
    		$loc
    	});

    	$$self.$inject_state = $$props => {
    		if ('result' in $$props) $$invalidate(0, result = $$props.result);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [result, $loc, loc, searchbar_result_binding];
    }

    class Search extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Search",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    /* src/Corner.svelte generated by Svelte v3.44.3 */

    // (42:13) 
    function create_if_block_3$2(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				zero: true,
    				c: "corner",
    				$$slots: { default: [create_default_slot_9$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(42:13) ",
    		ctx
    	});

    	return block;
    }

    // (31:13) 
    function create_if_block_2$3(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				zero: true,
    				c: "corner",
    				$$slots: { default: [create_default_slot_6$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(31:13) ",
    		ctx
    	});

    	return block;
    }

    // (20:13) 
    function create_if_block_1$5(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				zero: true,
    				c: "corner",
    				$$slots: { default: [create_default_slot_3$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(20:13) ",
    		ctx
    	});

    	return block;
    }

    // (9:0) {#if ul}
    function create_if_block$a(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				zero: true,
    				c: "corner",
    				$$slots: { default: [create_default_slot$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(9:0) {#if ul}",
    		ctx
    	});

    	return block;
    }

    // (44:2) <FB expand zero c="corner-v">
    function create_default_slot_11$3(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: { leaf: true, expand: true },
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: { leaf: true, c: "corner-vb" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$3.name,
    		type: "slot",
    		source: "(44:2) <FB expand zero c=\\\"corner-v\\\">",
    		ctx
    	});

    	return block;
    }

    // (48:2) <FB zero c="corner-h">
    function create_default_slot_10$3(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: { expand: true, leaf: true, c: "corner-hb" },
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: { leaf: true, c: "corner-br" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$3.name,
    		type: "slot",
    		source: "(48:2) <FB zero c=\\\"corner-h\\\">",
    		ctx
    	});

    	return block;
    }

    // (43:0) <FB vert zero c="corner">
    function create_default_slot_9$3(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				expand: true,
    				zero: true,
    				c: "corner-v",
    				$$slots: { default: [create_default_slot_11$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				zero: true,
    				c: "corner-h",
    				$$slots: { default: [create_default_slot_10$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$3.name,
    		type: "slot",
    		source: "(43:0) <FB vert zero c=\\\"corner\\\">",
    		ctx
    	});

    	return block;
    }

    // (33:2) <FB expand zero c="corner-v">
    function create_default_slot_8$3(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: { leaf: true, c: "corner-vb" },
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: { leaf: true, expand: true },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$3.name,
    		type: "slot",
    		source: "(33:2) <FB expand zero c=\\\"corner-v\\\">",
    		ctx
    	});

    	return block;
    }

    // (37:2) <FB zero c="corner-h">
    function create_default_slot_7$4(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: { leaf: true, c: "corner-bl" },
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: { expand: true, leaf: true, c: "corner-hb" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$4.name,
    		type: "slot",
    		source: "(37:2) <FB zero c=\\\"corner-h\\\">",
    		ctx
    	});

    	return block;
    }

    // (32:0) <FB vert zero c="corner">
    function create_default_slot_6$4(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				expand: true,
    				zero: true,
    				c: "corner-v",
    				$$slots: { default: [create_default_slot_8$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				zero: true,
    				c: "corner-h",
    				$$slots: { default: [create_default_slot_7$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$4.name,
    		type: "slot",
    		source: "(32:0) <FB vert zero c=\\\"corner\\\">",
    		ctx
    	});

    	return block;
    }

    // (22:2) <FB zero c="corner-h">
    function create_default_slot_5$4(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: { expand: true, leaf: true, c: "corner-hb" },
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: { leaf: true, c: "corner-ur" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$4.name,
    		type: "slot",
    		source: "(22:2) <FB zero c=\\\"corner-h\\\">",
    		ctx
    	});

    	return block;
    }

    // (26:2) <FB expand zero c="corner-v">
    function create_default_slot_4$4(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: { leaf: true, expand: true },
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: { leaf: true, c: "corner-vb" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$4.name,
    		type: "slot",
    		source: "(26:2) <FB expand zero c=\\\"corner-v\\\">",
    		ctx
    	});

    	return block;
    }

    // (21:0) <FB vert zero c="corner">
    function create_default_slot_3$7(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				zero: true,
    				c: "corner-h",
    				$$slots: { default: [create_default_slot_5$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				expand: true,
    				zero: true,
    				c: "corner-v",
    				$$slots: { default: [create_default_slot_4$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$7.name,
    		type: "slot",
    		source: "(21:0) <FB vert zero c=\\\"corner\\\">",
    		ctx
    	});

    	return block;
    }

    // (11:2) <FB zero c="corner-h">
    function create_default_slot_2$9(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: { leaf: true, c: "corner-ul" },
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: { expand: true, leaf: true, c: "corner-hb" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$9.name,
    		type: "slot",
    		source: "(11:2) <FB zero c=\\\"corner-h\\\">",
    		ctx
    	});

    	return block;
    }

    // (15:2) <FB expand zero c="corner-v">
    function create_default_slot_1$a(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: { leaf: true, c: "corner-vb" },
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: { leaf: true, expand: true },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(15:2) <FB expand zero c=\\\"corner-v\\\">",
    		ctx
    	});

    	return block;
    }

    // (10:0) <FB vert zero c="corner">
    function create_default_slot$d(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				zero: true,
    				c: "corner-h",
    				$$slots: { default: [create_default_slot_2$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				expand: true,
    				zero: true,
    				c: "corner-v",
    				$$slots: { default: [create_default_slot_1$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(10:0) <FB vert zero c=\\\"corner\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$a, create_if_block_1$5, create_if_block_2$3, create_if_block_3$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*ul*/ ctx[0]) return 0;
    		if (/*ur*/ ctx[1]) return 1;
    		if (/*bl*/ ctx[2]) return 2;
    		if (/*br*/ ctx[3]) return 3;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Corner', slots, []);
    	let { ul = false } = $$props;
    	let { ur = false } = $$props;
    	let { bl = false } = $$props;
    	let { br = false } = $$props;
    	const writable_props = ['ul', 'ur', 'bl', 'br'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Corner> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('ul' in $$props) $$invalidate(0, ul = $$props.ul);
    		if ('ur' in $$props) $$invalidate(1, ur = $$props.ur);
    		if ('bl' in $$props) $$invalidate(2, bl = $$props.bl);
    		if ('br' in $$props) $$invalidate(3, br = $$props.br);
    	};

    	$$self.$capture_state = () => ({ FB, ul, ur, bl, br });

    	$$self.$inject_state = $$props => {
    		if ('ul' in $$props) $$invalidate(0, ul = $$props.ul);
    		if ('ur' in $$props) $$invalidate(1, ur = $$props.ur);
    		if ('bl' in $$props) $$invalidate(2, bl = $$props.bl);
    		if ('br' in $$props) $$invalidate(3, br = $$props.br);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [ul, ur, bl, br];
    }

    class Corner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, { ul: 0, ur: 1, bl: 2, br: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Corner",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get ul() {
    		throw new Error("<Corner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ul(value) {
    		throw new Error("<Corner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ur() {
    		throw new Error("<Corner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ur(value) {
    		throw new Error("<Corner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bl() {
    		throw new Error("<Corner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bl(value) {
    		throw new Error("<Corner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get br() {
    		throw new Error("<Corner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set br(value) {
    		throw new Error("<Corner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Reticle.svelte generated by Svelte v3.44.3 */

    // (13:2) <FB zero c="reticle-row">
    function create_default_slot_3$6(ctx) {
    	let corner0;
    	let t0;
    	let fb;
    	let t1;
    	let corner1;
    	let current;
    	corner0 = new Corner({ props: { ul: true }, $$inline: true });

    	fb = new FB({
    			props: { leaf: true, expand: true },
    			$$inline: true
    		});

    	corner1 = new Corner({ props: { ur: true }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(corner0.$$.fragment);
    			t0 = space();
    			create_component(fb.$$.fragment);
    			t1 = space();
    			create_component(corner1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(corner0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(corner1, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(corner0.$$.fragment, local);
    			transition_in(fb.$$.fragment, local);
    			transition_in(corner1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(corner0.$$.fragment, local);
    			transition_out(fb.$$.fragment, local);
    			transition_out(corner1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(corner0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(corner1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$6.name,
    		type: "slot",
    		source: "(13:2) <FB zero c=\\\"reticle-row\\\">",
    		ctx
    	});

    	return block;
    }

    // (18:2) <FB vert center expand c="reticle-row reticle-body">
    function create_default_slot_2$8(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$8.name,
    		type: "slot",
    		source: "(18:2) <FB vert center expand c=\\\"reticle-row reticle-body\\\">",
    		ctx
    	});

    	return block;
    }

    // (21:2) <FB zero c="reticle-row">
    function create_default_slot_1$9(ctx) {
    	let corner0;
    	let t0;
    	let fb;
    	let t1;
    	let corner1;
    	let current;
    	corner0 = new Corner({ props: { bl: true }, $$inline: true });

    	fb = new FB({
    			props: { leaf: true, expand: true },
    			$$inline: true
    		});

    	corner1 = new Corner({ props: { br: true }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(corner0.$$.fragment);
    			t0 = space();
    			create_component(fb.$$.fragment);
    			t1 = space();
    			create_component(corner1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(corner0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(corner1, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(corner0.$$.fragment, local);
    			transition_in(fb.$$.fragment, local);
    			transition_in(corner1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(corner0.$$.fragment, local);
    			transition_out(fb.$$.fragment, local);
    			transition_out(corner1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(corner0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(corner1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(21:2) <FB zero c=\\\"reticle-row\\\">",
    		ctx
    	});

    	return block;
    }

    // (12:0) <FB vert zero {c}>
    function create_default_slot$c(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let fb2;
    	let current;

    	fb0 = new FB({
    			props: {
    				zero: true,
    				c: "reticle-row",
    				$$slots: { default: [create_default_slot_3$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				vert: true,
    				center: true,
    				expand: true,
    				c: "reticle-row reticle-body",
    				$$slots: { default: [create_default_slot_2$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb2 = new FB({
    			props: {
    				zero: true,
    				c: "reticle-row",
    				$$slots: { default: [create_default_slot_1$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    			create_component(fb2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    			const fb2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				fb2_changes.$$scope = { dirty, ctx };
    			}

    			fb2.$set(fb2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(fb2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(fb2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(12:0) <FB vert zero {c}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				zero: true,
    				c: /*c*/ ctx[0],
    				$$slots: { default: [create_default_slot$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*c*/ 1) fb_changes.c = /*c*/ ctx[0];

    			if (dirty & /*$$scope*/ 16) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Reticle', slots, ['default']);
    	let { size = 5 } = $$props;
    	let rs, c;
    	const writable_props = ['size'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Reticle> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ FB, Corner, size, rs, c });

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    		if ('rs' in $$props) $$invalidate(2, rs = $$props.rs);
    		if ('c' in $$props) $$invalidate(0, c = $$props.c);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*size, rs*/ 6) {
    			{
    				$$invalidate(2, rs = size * 10);
    				$$invalidate(0, c = ['reticle', `reticle-s${rs}`]);
    			}
    		}
    	};

    	return [c, size, rs, slots, $$scope];
    }

    class Reticle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$F, safe_not_equal, { size: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Reticle",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get size() {
    		throw new Error("<Reticle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Reticle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/special/TestQR.svelte generated by Svelte v3.44.3 */

    const { console: console_1$2 } = globals;
    const file$t = "src/special/TestQR.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[21] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[24] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	return child_ctx;
    }

    function get_each_context_4$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	return child_ctx;
    }

    function get_each_context_5$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	return child_ctx;
    }

    function get_each_context_6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	return child_ctx;
    }

    // (69:6) <FB center>
    function create_default_slot_26$1(ctx) {
    	let qr;
    	let current;

    	qr = new QR({
    			props: {
    				ver: /*sbver*/ ctx[5],
    				scale: /*sbscale*/ ctx[7],
    				mask: /*sbmask*/ ctx[6],
    				data: /*sbtxt*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(qr.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(qr, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const qr_changes = {};
    			if (dirty[0] & /*sbver*/ 32) qr_changes.ver = /*sbver*/ ctx[5];
    			if (dirty[0] & /*sbscale*/ 128) qr_changes.scale = /*sbscale*/ ctx[7];
    			if (dirty[0] & /*sbmask*/ 64) qr_changes.mask = /*sbmask*/ ctx[6];
    			if (dirty[0] & /*sbtxt*/ 16) qr_changes.data = /*sbtxt*/ ctx[4];
    			qr.$set(qr_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(qr.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(qr.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(qr, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_26$1.name,
    		type: "slot",
    		source: "(69:6) <FB center>",
    		ctx
    	});

    	return block;
    }

    // (68:4) <FB center vert w={50}>
    function create_default_slot_25$1(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				center: true,
    				$$slots: { default: [create_default_slot_26$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[0] & /*sbver, sbscale, sbmask, sbtxt*/ 240 | dirty[1] & /*$$scope*/ 128) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_25$1.name,
    		type: "slot",
    		source: "(68:4) <FB center vert w={50}>",
    		ctx
    	});

    	return block;
    }

    // (76:8) <Lab txt="DATA">
    function create_default_slot_24$1(ctx) {
    	let input;
    	let updating_value;
    	let current;

    	function input_value_binding(value) {
    		/*input_value_binding*/ ctx[15](value);
    	}

    	let input_props = {};

    	if (/*sbtxt*/ ctx[4] !== void 0) {
    		input_props.value = /*sbtxt*/ ctx[4];
    	}

    	input = new Input({ props: input_props, $$inline: true });
    	binding_callbacks.push(() => bind(input, 'value', input_value_binding));

    	const block = {
    		c: function create() {
    			create_component(input.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(input, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const input_changes = {};

    			if (!updating_value && dirty[0] & /*sbtxt*/ 16) {
    				updating_value = true;
    				input_changes.value = /*sbtxt*/ ctx[4];
    				add_flush_callback(() => updating_value = false);
    			}

    			input.$set(input_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(input, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_24$1.name,
    		type: "slot",
    		source: "(76:8) <Lab txt=\\\"DATA\\\">",
    		ctx
    	});

    	return block;
    }

    // (75:6) <Line s='b1' input>
    function create_default_slot_23$1(ctx) {
    	let lab;
    	let current;

    	lab = new Lab({
    			props: {
    				txt: "DATA",
    				$$slots: { default: [create_default_slot_24$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(lab.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lab, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lab_changes = {};

    			if (dirty[0] & /*sbtxt*/ 16 | dirty[1] & /*$$scope*/ 128) {
    				lab_changes.$$scope = { dirty, ctx };
    			}

    			lab.$set(lab_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lab.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lab.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lab, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23$1.name,
    		type: "slot",
    		source: "(75:6) <Line s='b1' input>",
    		ctx
    	});

    	return block;
    }

    // (79:8) <Lab w={30} txt="VER">
    function create_default_slot_22$1(ctx) {
    	let input;
    	let updating_value;
    	let current;

    	function input_value_binding_1(value) {
    		/*input_value_binding_1*/ ctx[16](value);
    	}

    	let input_props = {};

    	if (/*inver*/ ctx[0] !== void 0) {
    		input_props.value = /*inver*/ ctx[0];
    	}

    	input = new Input({ props: input_props, $$inline: true });
    	binding_callbacks.push(() => bind(input, 'value', input_value_binding_1));

    	const block = {
    		c: function create() {
    			create_component(input.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(input, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const input_changes = {};

    			if (!updating_value && dirty[0] & /*inver*/ 1) {
    				updating_value = true;
    				input_changes.value = /*inver*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			input.$set(input_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(input, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$1.name,
    		type: "slot",
    		source: "(79:8) <Lab w={30} txt=\\\"VER\\\">",
    		ctx
    	});

    	return block;
    }

    // (80:8) <Lab w={30} txt="MASK">
    function create_default_slot_21$1(ctx) {
    	let input;
    	let updating_value;
    	let current;

    	function input_value_binding_2(value) {
    		/*input_value_binding_2*/ ctx[17](value);
    	}

    	let input_props = {};

    	if (/*inmask*/ ctx[1] !== void 0) {
    		input_props.value = /*inmask*/ ctx[1];
    	}

    	input = new Input({ props: input_props, $$inline: true });
    	binding_callbacks.push(() => bind(input, 'value', input_value_binding_2));

    	const block = {
    		c: function create() {
    			create_component(input.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(input, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const input_changes = {};

    			if (!updating_value && dirty[0] & /*inmask*/ 2) {
    				updating_value = true;
    				input_changes.value = /*inmask*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			input.$set(input_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(input, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$1.name,
    		type: "slot",
    		source: "(80:8) <Lab w={30} txt=\\\"MASK\\\">",
    		ctx
    	});

    	return block;
    }

    // (81:8) <Lab w={30} txt="SCALE">
    function create_default_slot_20$1(ctx) {
    	let input;
    	let updating_value;
    	let current;

    	function input_value_binding_3(value) {
    		/*input_value_binding_3*/ ctx[18](value);
    	}

    	let input_props = {};

    	if (/*inscale*/ ctx[2] !== void 0) {
    		input_props.value = /*inscale*/ ctx[2];
    	}

    	input = new Input({ props: input_props, $$inline: true });
    	binding_callbacks.push(() => bind(input, 'value', input_value_binding_3));

    	const block = {
    		c: function create() {
    			create_component(input.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(input, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const input_changes = {};

    			if (!updating_value && dirty[0] & /*inscale*/ 4) {
    				updating_value = true;
    				input_changes.value = /*inscale*/ ctx[2];
    				add_flush_callback(() => updating_value = false);
    			}

    			input.$set(input_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(input, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$1.name,
    		type: "slot",
    		source: "(81:8) <Lab w={30} txt=\\\"SCALE\\\">",
    		ctx
    	});

    	return block;
    }

    // (78:6) <Line s='s1' input>
    function create_default_slot_19$1(ctx) {
    	let lab0;
    	let t0;
    	let lab1;
    	let t1;
    	let lab2;
    	let current;

    	lab0 = new Lab({
    			props: {
    				w: 30,
    				txt: "VER",
    				$$slots: { default: [create_default_slot_22$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	lab1 = new Lab({
    			props: {
    				w: 30,
    				txt: "MASK",
    				$$slots: { default: [create_default_slot_21$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	lab2 = new Lab({
    			props: {
    				w: 30,
    				txt: "SCALE",
    				$$slots: { default: [create_default_slot_20$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(lab0.$$.fragment);
    			t0 = space();
    			create_component(lab1.$$.fragment);
    			t1 = space();
    			create_component(lab2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lab0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(lab1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(lab2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lab0_changes = {};

    			if (dirty[0] & /*inver*/ 1 | dirty[1] & /*$$scope*/ 128) {
    				lab0_changes.$$scope = { dirty, ctx };
    			}

    			lab0.$set(lab0_changes);
    			const lab1_changes = {};

    			if (dirty[0] & /*inmask*/ 2 | dirty[1] & /*$$scope*/ 128) {
    				lab1_changes.$$scope = { dirty, ctx };
    			}

    			lab1.$set(lab1_changes);
    			const lab2_changes = {};

    			if (dirty[0] & /*inscale*/ 4 | dirty[1] & /*$$scope*/ 128) {
    				lab2_changes.$$scope = { dirty, ctx };
    			}

    			lab2.$set(lab2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lab0.$$.fragment, local);
    			transition_in(lab1.$$.fragment, local);
    			transition_in(lab2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lab0.$$.fragment, local);
    			transition_out(lab1.$$.fragment, local);
    			transition_out(lab2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lab0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(lab1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(lab2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$1.name,
    		type: "slot",
    		source: "(78:6) <Line s='s1' input>",
    		ctx
    	});

    	return block;
    }

    // (74:4) <Doc w={50}>
    function create_default_slot_18$1(ctx) {
    	let line0;
    	let t;
    	let line1;
    	let current;

    	line0 = new Line$1({
    			props: {
    				s: "b1",
    				input: true,
    				$$slots: { default: [create_default_slot_23$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	line1 = new Line$1({
    			props: {
    				s: "s1",
    				input: true,
    				$$slots: { default: [create_default_slot_19$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(line0.$$.fragment);
    			t = space();
    			create_component(line1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(line0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(line1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const line0_changes = {};

    			if (dirty[0] & /*sbtxt*/ 16 | dirty[1] & /*$$scope*/ 128) {
    				line0_changes.$$scope = { dirty, ctx };
    			}

    			line0.$set(line0_changes);
    			const line1_changes = {};

    			if (dirty[0] & /*inscale, inmask, inver*/ 7 | dirty[1] & /*$$scope*/ 128) {
    				line1_changes.$$scope = { dirty, ctx };
    			}

    			line1.$set(line1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(line0.$$.fragment, local);
    			transition_in(line1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(line0.$$.fragment, local);
    			transition_out(line1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(line0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(line1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$1.name,
    		type: "slot",
    		source: "(74:4) <Doc w={50}>",
    		ctx
    	});

    	return block;
    }

    // (67:2) <FB>
    function create_default_slot_17$1(ctx) {
    	let fb;
    	let t;
    	let doc;
    	let current;

    	fb = new FB({
    			props: {
    				center: true,
    				vert: true,
    				w: 50,
    				$$slots: { default: [create_default_slot_25$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	doc = new Doc({
    			props: {
    				w: 50,
    				$$slots: { default: [create_default_slot_18$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t = space();
    			create_component(doc.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(doc, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[0] & /*sbver, sbscale, sbmask, sbtxt*/ 240 | dirty[1] & /*$$scope*/ 128) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    			const doc_changes = {};

    			if (dirty[0] & /*inscale, inmask, inver, sbtxt*/ 23 | dirty[1] & /*$$scope*/ 128) {
    				doc_changes.$$scope = { dirty, ctx };
    			}

    			doc.$set(doc_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			transition_in(doc.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			transition_out(doc.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(doc, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$1.name,
    		type: "slot",
    		source: "(67:2) <FB>",
    		ctx
    	});

    	return block;
    }

    // (90:6) <FB center vert c="qrt63">
    function create_default_slot_16$1(ctx) {
    	let span;
    	let t0;
    	let t1_value = /*mask*/ ctx[27] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text("m");
    			t1 = text(t1_value);
    			add_location(span, file$t, 89, 32, 2308);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$1.name,
    		type: "slot",
    		source: "(90:6) <FB center vert c=\\\"qrt63\\\">",
    		ctx
    	});

    	return block;
    }

    // (89:4) {#each masks as mask}
    function create_each_block_6(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				center: true,
    				vert: true,
    				c: "qrt63",
    				$$slots: { default: [create_default_slot_16$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_6.name,
    		type: "each",
    		source: "(89:4) {#each masks as mask}",
    		ctx
    	});

    	return block;
    }

    // (87:2) <FB between c="qr-bay">
    function create_default_slot_15$1(ctx) {
    	let fb;
    	let t;
    	let each_1_anchor;
    	let current;

    	fb = new FB({
    			props: { center: true, vert: true, c: "qrt63" },
    			$$inline: true
    		});

    	let each_value_6 = /*masks*/ ctx[12];
    	validate_each_argument(each_value_6);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_6.length; i += 1) {
    		each_blocks[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*masks*/ 4096) {
    				each_value_6 = /*masks*/ ctx[12];
    				validate_each_argument(each_value_6);
    				let i;

    				for (i = 0; i < each_value_6.length; i += 1) {
    					const child_ctx = get_each_context_6(ctx, each_value_6, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_6.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);

    			for (let i = 0; i < each_value_6.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$1.name,
    		type: "slot",
    		source: "(87:2) <FB between c=\\\"qr-bay\\\">",
    		ctx
    	});

    	return block;
    }

    // (95:4) <FB center vert c="qrblab">
    function create_default_slot_14$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "0s";
    			add_location(span, file$t, 94, 31, 2412);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$1.name,
    		type: "slot",
    		source: "(95:4) <FB center vert c=\\\"qrblab\\\">",
    		ctx
    	});

    	return block;
    }

    // (96:4) {#each masks as mask}
    function create_each_block_5$1(ctx) {
    	let qr;
    	let current;

    	qr = new QR({
    			props: {
    				ver: 1,
    				scale: 3,
    				mask: /*mask*/ ctx[27],
    				data: /*n41*/ ctx[9]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(qr.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(qr, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(qr.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(qr.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(qr, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5$1.name,
    		type: "each",
    		source: "(96:4) {#each masks as mask}",
    		ctx
    	});

    	return block;
    }

    // (94:2) <FB between c="qr-bay">
    function create_default_slot_13$1(ctx) {
    	let fb;
    	let t;
    	let each_1_anchor;
    	let current;

    	fb = new FB({
    			props: {
    				center: true,
    				vert: true,
    				c: "qrblab",
    				$$slots: { default: [create_default_slot_14$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value_5 = /*masks*/ ctx[12];
    	validate_each_argument(each_value_5);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks[i] = create_each_block_5$1(get_each_context_5$1(ctx, each_value_5, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);

    			if (dirty[0] & /*masks, n41*/ 4608) {
    				each_value_5 = /*masks*/ ctx[12];
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5$1(ctx, each_value_5, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_5$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_5.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);

    			for (let i = 0; i < each_value_5.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$1.name,
    		type: "slot",
    		source: "(94:2) <FB between c=\\\"qr-bay\\\">",
    		ctx
    	});

    	return block;
    }

    // (102:4) <FB center vert c="qrblab">
    function create_default_slot_12$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "9s";
    			add_location(span, file$t, 101, 31, 2585);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$1.name,
    		type: "slot",
    		source: "(102:4) <FB center vert c=\\\"qrblab\\\">",
    		ctx
    	});

    	return block;
    }

    // (103:4) {#each masks as mask}
    function create_each_block_4$1(ctx) {
    	let qr;
    	let current;

    	qr = new QR({
    			props: {
    				ver: 1,
    				scale: 3,
    				mask: /*mask*/ ctx[27],
    				data: /*n41b*/ ctx[10]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(qr.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(qr, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(qr.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(qr.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(qr, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4$1.name,
    		type: "each",
    		source: "(103:4) {#each masks as mask}",
    		ctx
    	});

    	return block;
    }

    // (101:2) <FB between c="qr-bay">
    function create_default_slot_11$2(ctx) {
    	let fb;
    	let t;
    	let each_1_anchor;
    	let current;

    	fb = new FB({
    			props: {
    				center: true,
    				vert: true,
    				c: "qrblab",
    				$$slots: { default: [create_default_slot_12$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value_4 = /*masks*/ ctx[12];
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4$1(get_each_context_4$1(ctx, each_value_4, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);

    			if (dirty[0] & /*masks, n41b*/ 5120) {
    				each_value_4 = /*masks*/ ctx[12];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4$1(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_4$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_4.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);

    			for (let i = 0; i < each_value_4.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$2.name,
    		type: "slot",
    		source: "(101:2) <FB between c=\\\"qr-bay\\\">",
    		ctx
    	});

    	return block;
    }

    // (111:6) <Link global nolink first={rern}>
    function create_default_slot_10$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("GEN");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$2.name,
    		type: "slot",
    		source: "(111:6) <Link global nolink first={rern}>",
    		ctx
    	});

    	return block;
    }

    // (109:4) <FB center vert c="qrblab">
    function create_default_slot_9$2(ctx) {
    	let span;
    	let t1;
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				global: true,
    				nolink: true,
    				first: /*rern*/ ctx[8],
    				$$slots: { default: [create_default_slot_10$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "rand";
    			t1 = space();
    			create_component(link.$$.fragment);
    			add_location(span, file$t, 109, 6, 2766);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t1);
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$2.name,
    		type: "slot",
    		source: "(109:4) <FB center vert c=\\\"qrblab\\\">",
    		ctx
    	});

    	return block;
    }

    // (113:4) {#each masks as mask}
    function create_each_block_3$2(ctx) {
    	let qr;
    	let current;

    	qr = new QR({
    			props: {
    				ver: 1,
    				scale: 3,
    				mask: /*mask*/ ctx[27],
    				data: /*rn*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(qr.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(qr, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const qr_changes = {};
    			if (dirty[0] & /*rn*/ 8) qr_changes.data = /*rn*/ ctx[3];
    			qr.$set(qr_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(qr.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(qr.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(qr, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$2.name,
    		type: "each",
    		source: "(113:4) {#each masks as mask}",
    		ctx
    	});

    	return block;
    }

    // (108:2) <FB between c="qr-bay">
    function create_default_slot_8$2(ctx) {
    	let fb;
    	let t;
    	let each_1_anchor;
    	let current;

    	fb = new FB({
    			props: {
    				center: true,
    				vert: true,
    				c: "qrblab",
    				$$slots: { default: [create_default_slot_9$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value_3 = /*masks*/ ctx[12];
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3$2(get_each_context_3$2(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);

    			if (dirty[0] & /*masks, rn*/ 4104) {
    				each_value_3 = /*masks*/ ctx[12];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$2(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$2.name,
    		type: "slot",
    		source: "(108:2) <FB between c=\\\"qr-bay\\\">",
    		ctx
    	});

    	return block;
    }

    // (119:4) <FB center vert c="qrblab">
    function create_default_slot_7$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "bin 0";
    			add_location(span, file$t, 118, 31, 2995);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$3.name,
    		type: "slot",
    		source: "(119:4) <FB center vert c=\\\"qrblab\\\">",
    		ctx
    	});

    	return block;
    }

    // (120:4) {#each masks as mask}
    function create_each_block_2$3(ctx) {
    	let qr;
    	let current;

    	qr = new QR({
    			props: {
    				ver: 1,
    				scale: 3,
    				mask: /*mask*/ ctx[27],
    				data: /*v1b0*/ ctx[11]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(qr.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(qr, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(qr.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(qr.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(qr, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$3.name,
    		type: "each",
    		source: "(120:4) {#each masks as mask}",
    		ctx
    	});

    	return block;
    }

    // (118:2) <FB between c="qr-bay">
    function create_default_slot_6$3(ctx) {
    	let fb;
    	let t;
    	let each_1_anchor;
    	let current;

    	fb = new FB({
    			props: {
    				center: true,
    				vert: true,
    				c: "qrblab",
    				$$slots: { default: [create_default_slot_7$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value_2 = /*masks*/ ctx[12];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$3(get_each_context_2$3(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);

    			if (dirty[0] & /*masks, v1b0*/ 6144) {
    				each_value_2 = /*masks*/ ctx[12];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$3(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$3.name,
    		type: "slot",
    		source: "(118:2) <FB between c=\\\"qr-bay\\\">",
    		ctx
    	});

    	return block;
    }

    // (128:6) <Link nolink global first={regen}>
    function create_default_slot_5$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("REGEN");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$3.name,
    		type: "slot",
    		source: "(128:6) <Link nolink global first={regen}>",
    		ctx
    	});

    	return block;
    }

    // (127:4) <FB vert flip>
    function create_default_slot_4$3(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				nolink: true,
    				global: true,
    				first: /*regen*/ ctx[14],
    				$$slots: { default: [create_default_slot_5$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(127:4) <FB vert flip>",
    		ctx
    	});

    	return block;
    }

    // (125:2) <FB>
    function create_default_slot_3$5(ctx) {
    	let h3;
    	let t1;
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				flip: true,
    				$$slots: { default: [create_default_slot_4$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			h3.textContent = "UUIDs";
    			t1 = space();
    			create_component(fb.$$.fragment);
    			add_location(h3, file$t, 125, 4, 3126);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(125:2) <FB>",
    		ctx
    	});

    	return block;
    }

    // (133:6) <FB center vert c="qrblab">
    function create_default_slot_2$7(ctx) {
    	let span;
    	let t0;
    	let t1_value = /*set*/ ctx[21].mask + "";
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text("m");
    			t1 = text(t1_value);
    			add_location(span, file$t, 132, 33, 3314);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(133:6) <FB center vert c=\\\"qrblab\\\">",
    		ctx
    	});

    	return block;
    }

    // (134:6) {#each set.uuids as uuid}
    function create_each_block_1$3(ctx) {
    	let qr;
    	let current;

    	qr = new QR({
    			props: {
    				ver: 2,
    				scale: 3,
    				mask: /*set*/ ctx[21].mask,
    				data: /*uuid*/ ctx[24]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(qr.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(qr, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(qr.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(qr.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(qr, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(134:6) {#each set.uuids as uuid}",
    		ctx
    	});

    	return block;
    }

    // (132:4) <FB between c="qr-bay">
    function create_default_slot_1$8(ctx) {
    	let fb;
    	let t0;
    	let t1;
    	let current;

    	fb = new FB({
    			props: {
    				center: true,
    				vert: true,
    				c: "qrblab",
    				$$slots: { default: [create_default_slot_2$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value_1 = /*set*/ ctx[21].uuids;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t0, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);

    			if (dirty[0] & /*sets*/ 8192) {
    				each_value_1 = /*set*/ ctx[21].uuids;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t1.parentNode, t1);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(132:4) <FB between c=\\\"qr-bay\\\">",
    		ctx
    	});

    	return block;
    }

    // (131:2) {#each sets as set}
    function create_each_block$4(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				between: true,
    				c: "qr-bay",
    				$$slots: { default: [create_default_slot_1$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(131:2) {#each sets as set}",
    		ctx
    	});

    	return block;
    }

    // (65:0) <FB vert c="qr-tests">
    function create_default_slot$b(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let fb2;
    	let t2;
    	let fb3;
    	let t3;
    	let fb4;
    	let t4;
    	let fb5;
    	let t5;
    	let fb6;
    	let t6;
    	let each_1_anchor;
    	let current;

    	fb0 = new FB({
    			props: {
    				$$slots: { default: [create_default_slot_17$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				between: true,
    				c: "qr-bay",
    				$$slots: { default: [create_default_slot_15$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb2 = new FB({
    			props: {
    				between: true,
    				c: "qr-bay",
    				$$slots: { default: [create_default_slot_13$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb3 = new FB({
    			props: {
    				between: true,
    				c: "qr-bay",
    				$$slots: { default: [create_default_slot_11$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb4 = new FB({
    			props: {
    				between: true,
    				c: "qr-bay",
    				$$slots: { default: [create_default_slot_8$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb5 = new FB({
    			props: {
    				between: true,
    				c: "qr-bay",
    				$$slots: { default: [create_default_slot_6$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb6 = new FB({
    			props: {
    				$$slots: { default: [create_default_slot_3$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value = /*sets*/ ctx[13];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    			create_component(fb2.$$.fragment);
    			t2 = space();
    			create_component(fb3.$$.fragment);
    			t3 = space();
    			create_component(fb4.$$.fragment);
    			t4 = space();
    			create_component(fb5.$$.fragment);
    			t5 = space();
    			create_component(fb6.$$.fragment);
    			t6 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(fb3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(fb4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(fb5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(fb6, target, anchor);
    			insert_dev(target, t6, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty[0] & /*inscale, inmask, inver, sbtxt, sbver, sbscale, sbmask*/ 247 | dirty[1] & /*$$scope*/ 128) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    			const fb2_changes = {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				fb2_changes.$$scope = { dirty, ctx };
    			}

    			fb2.$set(fb2_changes);
    			const fb3_changes = {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				fb3_changes.$$scope = { dirty, ctx };
    			}

    			fb3.$set(fb3_changes);
    			const fb4_changes = {};

    			if (dirty[0] & /*rn*/ 8 | dirty[1] & /*$$scope*/ 128) {
    				fb4_changes.$$scope = { dirty, ctx };
    			}

    			fb4.$set(fb4_changes);
    			const fb5_changes = {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				fb5_changes.$$scope = { dirty, ctx };
    			}

    			fb5.$set(fb5_changes);
    			const fb6_changes = {};

    			if (dirty[1] & /*$$scope*/ 128) {
    				fb6_changes.$$scope = { dirty, ctx };
    			}

    			fb6.$set(fb6_changes);

    			if (dirty[0] & /*sets*/ 8192) {
    				each_value = /*sets*/ ctx[13];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(fb2.$$.fragment, local);
    			transition_in(fb3.$$.fragment, local);
    			transition_in(fb4.$$.fragment, local);
    			transition_in(fb5.$$.fragment, local);
    			transition_in(fb6.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(fb2.$$.fragment, local);
    			transition_out(fb3.$$.fragment, local);
    			transition_out(fb4.$$.fragment, local);
    			transition_out(fb5.$$.fragment, local);
    			transition_out(fb6.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(fb3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(fb4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(fb5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(fb6, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(65:0) <FB vert c=\\\"qr-tests\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				c: "qr-tests",
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty[0] & /*rn, inscale, inmask, inver, sbtxt, sbver, sbscale, sbmask*/ 255 | dirty[1] & /*$$scope*/ 128) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function rand(min, max) {
    	min = Math.ceil(min);
    	max = Math.floor(max);
    	return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TestQR', slots, []);

    	const rint = () => {
    		const nums = [...Array(41).keys()];

    		return [
    			{
    				data: nums.map(x => rand(0, 9)).join(''),
    				mode: 'numeric'
    			}
    		];
    	};

    	let rn = rint();
    	const rern = () => $$invalidate(3, rn = rint());

    	const n41 = [
    		{
    			data: '00000000000000000000000000000000000000000',
    			mode: 'numeric'
    		}
    	];

    	const n41b = [
    		{
    			data: '99999999999999999999999999999999999999999',
    			mode: 'numeric'
    		}
    	];

    	const v1b0 = [{ data: [], mode: 'byte' }];
    	const masks = [...Array(8).keys()];

    	class Uset {
    		constructor(mask) {
    			this.mask = mask;
    			this.generate();
    		}

    		generate() {
    			this.uuids = masks.map(x => v4());
    		}
    	}

    	const sets = masks.map(x => new Uset(x));

    	const regen = () => {
    		console.log('regenning');
    		sets.forEach(s => s.generate());
    		return new Promise(res => res(sets));
    	};

    	let sbtxt = 'what are the roots clutch';
    	let inver = 1;
    	let inmask = 0;
    	let inscale = 4;
    	let sbver = inver;
    	let sbmask = inmask;
    	let sbscale = inscale;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<TestQR> was created with unknown prop '${key}'`);
    	});

    	function input_value_binding(value) {
    		sbtxt = value;
    		$$invalidate(4, sbtxt);
    	}

    	function input_value_binding_1(value) {
    		inver = value;
    		$$invalidate(0, inver);
    	}

    	function input_value_binding_2(value) {
    		inmask = value;
    		$$invalidate(1, inmask);
    	}

    	function input_value_binding_3(value) {
    		inscale = value;
    		$$invalidate(2, inscale);
    	}

    	$$self.$capture_state = () => ({
    		FB,
    		QR,
    		Link: Link$1,
    		Doc,
    		Line: Line$1,
    		Lab,
    		Input,
    		Reticle,
    		v4,
    		rand,
    		rint,
    		rn,
    		rern,
    		n41,
    		n41b,
    		v1b0,
    		masks,
    		Uset,
    		sets,
    		regen,
    		sbtxt,
    		inver,
    		inmask,
    		inscale,
    		sbver,
    		sbmask,
    		sbscale
    	});

    	$$self.$inject_state = $$props => {
    		if ('rn' in $$props) $$invalidate(3, rn = $$props.rn);
    		if ('sbtxt' in $$props) $$invalidate(4, sbtxt = $$props.sbtxt);
    		if ('inver' in $$props) $$invalidate(0, inver = $$props.inver);
    		if ('inmask' in $$props) $$invalidate(1, inmask = $$props.inmask);
    		if ('inscale' in $$props) $$invalidate(2, inscale = $$props.inscale);
    		if ('sbver' in $$props) $$invalidate(5, sbver = $$props.sbver);
    		if ('sbmask' in $$props) $$invalidate(6, sbmask = $$props.sbmask);
    		if ('sbscale' in $$props) $$invalidate(7, sbscale = $$props.sbscale);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*inver*/ 1) {
    			if (inver) $$invalidate(5, sbver = Math.min(Math.max(inver, 1), 40));
    		}

    		if ($$self.$$.dirty[0] & /*inmask*/ 2) {
    			if (inmask) $$invalidate(6, sbmask = Math.min(Math.max(inmask, 0), 7));
    		}

    		if ($$self.$$.dirty[0] & /*inscale*/ 4) {
    			if (inscale) $$invalidate(7, sbscale = Math.min(Math.max(inscale, 1), 8));
    		}
    	};

    	return [
    		inver,
    		inmask,
    		inscale,
    		rn,
    		sbtxt,
    		sbver,
    		sbmask,
    		sbscale,
    		rern,
    		n41,
    		n41b,
    		v1b0,
    		masks,
    		sets,
    		regen,
    		input_value_binding,
    		input_value_binding_1,
    		input_value_binding_2,
    		input_value_binding_3
    	];
    }

    class TestQR extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TestQR",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    /* src/special/Test.svelte generated by Svelte v3.44.3 */

    function create_fragment$D(ctx) {
    	let testqr;
    	let current;
    	testqr = new TestQR({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(testqr.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(testqr, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(testqr.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(testqr.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(testqr, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Test', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Test> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ TestQR });
    	return [];
    }

    class Test extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Test",
    			options,
    			id: create_fragment$D.name
    		});
    	}
    }

    /* src/util/Table.svelte generated by Svelte v3.44.3 */

    const { Object: Object_1$1 } = globals;

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[8] = i;
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[11] = i;
    	return child_ctx;
    }

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[11] = i;
    	return child_ctx;
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[11] = i;
    	return child_ctx;
    }

    // (44:12) {:else}
    function create_else_block_1$1(ctx) {
    	let strike;
    	let current;
    	strike = new Strike({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(strike.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(strike, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(strike.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(strike.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(strike, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(44:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (42:12) {#if key}
    function create_if_block_1$4(ctx) {
    	let t_value = /*key*/ ctx[9] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chunks*/ 2 && t_value !== (t_value = /*key*/ ctx[9] + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(42:12) {#if key}",
    		ctx
    	});

    	return block;
    }

    // (41:10) <FB {line} c="cpbtab-key row{ri+1}" end>
    function create_default_slot_7$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let current;
    	const if_block_creators = [create_if_block_1$4, create_else_block_1$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*key*/ ctx[9]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(t.parentNode, t);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$2.name,
    		type: "slot",
    		source: "(41:10) <FB {line} c=\\\"cpbtab-key row{ri+1}\\\" end>",
    		ctx
    	});

    	return block;
    }

    // (40:8) {#each chunk.keys as key, ri}
    function create_each_block_3$1(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				line: /*line*/ ctx[0],
    				c: "cpbtab-key row" + (/*ri*/ ctx[11] + 1),
    				end: true,
    				$$slots: { default: [create_default_slot_7$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};
    			if (dirty & /*line*/ 1) fb_changes.line = /*line*/ ctx[0];

    			if (dirty & /*$$scope, chunks*/ 16386) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$1.name,
    		type: "each",
    		source: "(40:8) {#each chunk.keys as key, ri}",
    		ctx
    	});

    	return block;
    }

    // (39:6) <FB vert c="cpbtab-kcol">
    function create_default_slot_6$2(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_3 = /*chunk*/ ctx[6].keys;
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*line, chunks*/ 3) {
    				each_value_3 = /*chunk*/ ctx[6].keys;
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$2.name,
    		type: "slot",
    		source: "(39:6) <FB vert c=\\\"cpbtab-kcol\\\">",
    		ctx
    	});

    	return block;
    }

    // (52:10) <FB {line} c="cpbtab-gap row{ri+1}">
    function create_default_slot_5$2(ctx) {
    	let strike;
    	let t;
    	let current;
    	strike = new Strike({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(strike.$$.fragment);
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(strike, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(strike.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(strike.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(strike, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(52:10) <FB {line} c=\\\"cpbtab-gap row{ri+1}\\\">",
    		ctx
    	});

    	return block;
    }

    // (51:8) {#each chunk.keys as key, ri}
    function create_each_block_2$2(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				line: /*line*/ ctx[0],
    				c: "cpbtab-gap row" + (/*ri*/ ctx[11] + 1),
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};
    			if (dirty & /*line*/ 1) fb_changes.line = /*line*/ ctx[0];

    			if (dirty & /*$$scope*/ 16384) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$2.name,
    		type: "each",
    		source: "(51:8) {#each chunk.keys as key, ri}",
    		ctx
    	});

    	return block;
    }

    // (50:6) <FB expand vert c="cpbtab-gapcol">
    function create_default_slot_4$2(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_2 = /*chunk*/ ctx[6].keys;
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*line, chunks*/ 3) {
    				each_value_2 = /*chunk*/ ctx[6].keys;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(50:6) <FB expand vert c=\\\"cpbtab-gapcol\\\">",
    		ctx
    	});

    	return block;
    }

    // (62:12) {:else}
    function create_else_block$5(ctx) {
    	let strike;
    	let current;
    	strike = new Strike({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(strike.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(strike, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(strike.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(strike.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(strike, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(62:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (60:12) {#if key}
    function create_if_block$9(ctx) {
    	let t_value = /*chunk*/ ctx[6].vals[/*ri*/ ctx[11]] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chunks*/ 2 && t_value !== (t_value = /*chunk*/ ctx[6].vals[/*ri*/ ctx[11]] + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(60:12) {#if key}",
    		ctx
    	});

    	return block;
    }

    // (59:10) <FB {line} c="cpbtab-val row{ri+1}">
    function create_default_slot_3$4(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let current;
    	const if_block_creators = [create_if_block$9, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*key*/ ctx[9]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(t.parentNode, t);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(59:10) <FB {line} c=\\\"cpbtab-val row{ri+1}\\\">",
    		ctx
    	});

    	return block;
    }

    // (58:8) {#each chunk.keys as key, ri}
    function create_each_block_1$2(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				line: /*line*/ ctx[0],
    				c: "cpbtab-val row" + (/*ri*/ ctx[11] + 1),
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};
    			if (dirty & /*line*/ 1) fb_changes.line = /*line*/ ctx[0];

    			if (dirty & /*$$scope, chunks*/ 16386) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(58:8) {#each chunk.keys as key, ri}",
    		ctx
    	});

    	return block;
    }

    // (57:6) <FB vert c="cpbtab-vcol">
    function create_default_slot_2$6(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*chunk*/ ctx[6].keys;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*line, chunks*/ 3) {
    				each_value_1 = /*chunk*/ ctx[6].keys;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(57:6) <FB vert c=\\\"cpbtab-vcol\\\">",
    		ctx
    	});

    	return block;
    }

    // (38:4) <FB c="cpbtab-col col{ci+1}">
    function create_default_slot_1$7(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let fb2;
    	let t2;
    	let current;

    	fb0 = new FB({
    			props: {
    				vert: true,
    				c: "cpbtab-kcol",
    				$$slots: { default: [create_default_slot_6$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				expand: true,
    				vert: true,
    				c: "cpbtab-gapcol",
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb2 = new FB({
    			props: {
    				vert: true,
    				c: "cpbtab-vcol",
    				$$slots: { default: [create_default_slot_2$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    			create_component(fb2.$$.fragment);
    			t2 = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb2, target, anchor);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope, chunks, line*/ 16387) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope, chunks, line*/ 16387) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    			const fb2_changes = {};

    			if (dirty & /*$$scope, chunks, line*/ 16387) {
    				fb2_changes.$$scope = { dirty, ctx };
    			}

    			fb2.$set(fb2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(fb2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(fb2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb2, detaching);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(38:4) <FB c=\\\"cpbtab-col col{ci+1}\\\">",
    		ctx
    	});

    	return block;
    }

    // (37:2) {#each chunks as chunk, ci}
    function create_each_block$3(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: "cpbtab-col col" + (/*ci*/ ctx[8] + 1),
    				$$slots: { default: [create_default_slot_1$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, chunks, line*/ 16387) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(37:2) {#each chunks as chunk, ci}",
    		ctx
    	});

    	return block;
    }

    // (36:0) <FB c="cpbtab cols-{cols}" around>
    function create_default_slot$a(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*chunks*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chunks, line*/ 3) {
    				each_value = /*chunks*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(36:0) <FB c=\\\"cpbtab cols-{cols}\\\" around>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: "cpbtab cols-" + /*cols*/ ctx[2],
    				around: true,
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};
    			if (dirty & /*cols*/ 4) fb_changes.c = "cpbtab cols-" + /*cols*/ ctx[2];

    			if (dirty & /*$$scope, chunks, line*/ 16387) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Table', slots, []);
    	let { data = {} } = $$props;
    	let { rows = 3 } = $$props;
    	let { line = 'n' } = $$props;
    	let chunks = [];
    	let cols = 0;

    	const parse = () => {
    		const entries = Object.entries(data);
    		$$invalidate(1, chunks = []);

    		for (let i = 0; i < entries.length; i += rows) {
    			const chunk = entries.slice(i, i + rows);
    			const short = rows - chunk.length;
    			const co = { keys: [], vals: [] };

    			chunk.forEach(p => {
    				co.keys.push(p[0]);
    				co.vals.push(p[1]);
    			});

    			[...Array(short).keys()].forEach(s => {
    				co.keys.push(null);
    			});

    			chunks.push(co);
    		}

    		$$invalidate(2, cols = chunks.length);
    	};

    	const writable_props = ['data', 'rows', 'line'];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Table> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('data' in $$props) $$invalidate(3, data = $$props.data);
    		if ('rows' in $$props) $$invalidate(4, rows = $$props.rows);
    		if ('line' in $$props) $$invalidate(0, line = $$props.line);
    	};

    	$$self.$capture_state = () => ({
    		FB,
    		Strike,
    		data,
    		rows,
    		line,
    		chunks,
    		cols,
    		parse
    	});

    	$$self.$inject_state = $$props => {
    		if ('data' in $$props) $$invalidate(3, data = $$props.data);
    		if ('rows' in $$props) $$invalidate(4, rows = $$props.rows);
    		if ('line' in $$props) $$invalidate(0, line = $$props.line);
    		if ('chunks' in $$props) $$invalidate(1, chunks = $$props.chunks);
    		if ('cols' in $$props) $$invalidate(2, cols = $$props.cols);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data, rows*/ 24) {
    			parse();
    		}
    	};

    	return [line, chunks, cols, data, rows];
    }

    class Table$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, { data: 3, rows: 4, line: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Table",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get data() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rows() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rows(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get line() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set line(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/special/TestForms.svelte generated by Svelte v3.44.3 */
    const file$s = "src/special/TestForms.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    // (26:8) <FB leaf wr={2}>
    function create_default_slot_46(ctx) {
    	let t_value = /*size*/ ctx[2] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_46.name,
    		type: "slot",
    		source: "(26:8) <FB leaf wr={2}>",
    		ctx
    	});

    	return block;
    }

    // (25:6) <FB line={size}>
    function create_default_slot_45(ctx) {
    	let fb;
    	let t0;
    	let check0;
    	let t1;
    	let check1;
    	let current;

    	fb = new FB({
    			props: {
    				leaf: true,
    				wr: 2,
    				$$slots: { default: [create_default_slot_46] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	check0 = new Check({ props: { lab: "foo" }, $$inline: true });
    	check1 = new Check({ props: { lab: "bar" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t0 = space();
    			create_component(check0.$$.fragment);
    			t1 = space();
    			create_component(check1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(check0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(check1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			transition_in(check0.$$.fragment, local);
    			transition_in(check1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			transition_out(check0.$$.fragment, local);
    			transition_out(check1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(check0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(check1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_45.name,
    		type: "slot",
    		source: "(25:6) <FB line={size}>",
    		ctx
    	});

    	return block;
    }

    // (30:6) <FB line={size}>
    function create_default_slot_44(ctx) {
    	let fb;
    	let t0;
    	let span;
    	let t2;
    	let current;

    	fb = new FB({
    			props: { leaf: true, wr: 2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t0 = space();
    			span = element("span");
    			span.textContent = "what are the roots that clutch";
    			t2 = space();
    			add_location(span, file$s, 31, 8, 766);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_44.name,
    		type: "slot",
    		source: "(30:6) <FB line={size}>",
    		ctx
    	});

    	return block;
    }

    // (24:4) {#each sizes as size}
    function create_each_block_2$1(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				line: /*size*/ ctx[2],
    				$$slots: { default: [create_default_slot_45] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				line: /*size*/ ctx[2],
    				$$slots: { default: [create_default_slot_44] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(24:4) {#each sizes as size}",
    		ctx
    	});

    	return block;
    }

    // (23:2) <FB vert>
    function create_default_slot_43(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_2 = /*sizes*/ ctx[0];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*sizes*/ 1) {
    				each_value_2 = /*sizes*/ ctx[0];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_43.name,
    		type: "slot",
    		source: "(23:2) <FB vert>",
    		ctx
    	});

    	return block;
    }

    // (39:8) <FB leaf wr={2}>
    function create_default_slot_42(ctx) {
    	let t_value = /*size*/ ctx[2] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_42.name,
    		type: "slot",
    		source: "(39:8) <FB leaf wr={2}>",
    		ctx
    	});

    	return block;
    }

    // (38:6) <FB line={size}>
    function create_default_slot_41(ctx) {
    	let fb;
    	let t;
    	let text_1;
    	let current;

    	fb = new FB({
    			props: {
    				leaf: true,
    				wr: 2,
    				$$slots: { default: [create_default_slot_42] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	text_1 = new Text$1({ props: { lab: "foo" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t = space();
    			create_component(text_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(text_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			transition_in(text_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			transition_out(text_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(text_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_41.name,
    		type: "slot",
    		source: "(38:6) <FB line={size}>",
    		ctx
    	});

    	return block;
    }

    // (42:6) <FB line={size}>
    function create_default_slot_40(ctx) {
    	let fb;
    	let t0;
    	let span;
    	let t2;
    	let current;

    	fb = new FB({
    			props: { leaf: true, wr: 2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t0 = space();
    			span = element("span");
    			span.textContent = "what branches grow";
    			t2 = space();
    			add_location(span, file$s, 43, 8, 1034);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_40.name,
    		type: "slot",
    		source: "(42:6) <FB line={size}>",
    		ctx
    	});

    	return block;
    }

    // (37:4) {#each sizes as size}
    function create_each_block_1$1(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				line: /*size*/ ctx[2],
    				$$slots: { default: [create_default_slot_41] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				line: /*size*/ ctx[2],
    				$$slots: { default: [create_default_slot_40] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(37:4) {#each sizes as size}",
    		ctx
    	});

    	return block;
    }

    // (36:2) <FB vert>
    function create_default_slot_39(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*sizes*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*sizes*/ 1) {
    				each_value_1 = /*sizes*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_39.name,
    		type: "slot",
    		source: "(36:2) <FB vert>",
    		ctx
    	});

    	return block;
    }

    // (51:8) <FB leaf wr={2}>
    function create_default_slot_38(ctx) {
    	let t_value = /*size*/ ctx[2] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_38.name,
    		type: "slot",
    		source: "(51:8) <FB leaf wr={2}>",
    		ctx
    	});

    	return block;
    }

    // (50:6) <FB line={size}>
    function create_default_slot_37(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let numeric;
    	let current;

    	fb0 = new FB({
    			props: {
    				leaf: true,
    				wr: 2,
    				$$slots: { default: [create_default_slot_38] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({ props: { expand: true }, $$inline: true });
    	numeric = new Numeric({ props: { lab: "xxx" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    			create_component(numeric.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(numeric, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(numeric.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(numeric.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(numeric, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_37.name,
    		type: "slot",
    		source: "(50:6) <FB line={size}>",
    		ctx
    	});

    	return block;
    }

    // (55:6) <FB line={size}>
    function create_default_slot_36(ctx) {
    	let fb;
    	let t0;
    	let span;
    	let t2;
    	let current;

    	fb = new FB({
    			props: { leaf: true, wr: 2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t0 = space();
    			span = element("span");
    			span.textContent = "out of this stony rubbish";
    			t2 = space();
    			add_location(span, file$s, 56, 8, 1314);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_36.name,
    		type: "slot",
    		source: "(55:6) <FB line={size}>",
    		ctx
    	});

    	return block;
    }

    // (49:4) {#each sizes as size}
    function create_each_block$2(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				line: /*size*/ ctx[2],
    				$$slots: { default: [create_default_slot_37] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				line: /*size*/ ctx[2],
    				$$slots: { default: [create_default_slot_36] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(49:4) {#each sizes as size}",
    		ctx
    	});

    	return block;
    }

    // (48:2) <FB vert>
    function create_default_slot_35(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*sizes*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*sizes*/ 1) {
    				each_value = /*sizes*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_35.name,
    		type: "slot",
    		source: "(48:2) <FB vert>",
    		ctx
    	});

    	return block;
    }

    // (22:0) <FB grid={3} around>
    function create_default_slot_34(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let fb2;
    	let current;

    	fb0 = new FB({
    			props: {
    				vert: true,
    				$$slots: { default: [create_default_slot_43] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				vert: true,
    				$$slots: { default: [create_default_slot_39] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb2 = new FB({
    			props: {
    				vert: true,
    				$$slots: { default: [create_default_slot_35] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    			create_component(fb2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    			const fb2_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb2_changes.$$scope = { dirty, ctx };
    			}

    			fb2.$set(fb2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(fb2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(fb2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_34.name,
    		type: "slot",
    		source: "(22:0) <FB grid={3} around>",
    		ctx
    	});

    	return block;
    }

    // (65:0) <FB line grid={10} around>
    function create_default_slot_33(ctx) {
    	let check0;
    	let t0;
    	let check1;
    	let t1;
    	let check2;
    	let current;

    	check0 = new Check({
    			props: { lab: "foo", just: "e" },
    			$$inline: true
    		});

    	check1 = new Check({
    			props: { lab: "bar", just: "e" },
    			$$inline: true
    		});

    	check2 = new Check({
    			props: { lab: "baz", just: "e" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(check0.$$.fragment);
    			t0 = space();
    			create_component(check1.$$.fragment);
    			t1 = space();
    			create_component(check2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(check0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(check1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(check2, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(check0.$$.fragment, local);
    			transition_in(check1.$$.fragment, local);
    			transition_in(check2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(check0.$$.fragment, local);
    			transition_out(check1.$$.fragment, local);
    			transition_out(check2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(check0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(check1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(check2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_33.name,
    		type: "slot",
    		source: "(65:0) <FB line grid={10} around>",
    		ctx
    	});

    	return block;
    }

    // (71:0) <FB line grid={10} around>
    function create_default_slot_32(ctx) {
    	let check0;
    	let t0;
    	let check1;
    	let t1;
    	let check2;
    	let current;
    	check0 = new Check({ props: { lab: "foo" }, $$inline: true });
    	check1 = new Check({ props: { lab: "bar" }, $$inline: true });
    	check2 = new Check({ props: { lab: "baz" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(check0.$$.fragment);
    			t0 = space();
    			create_component(check1.$$.fragment);
    			t1 = space();
    			create_component(check2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(check0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(check1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(check2, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(check0.$$.fragment, local);
    			transition_in(check1.$$.fragment, local);
    			transition_in(check2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(check0.$$.fragment, local);
    			transition_out(check1.$$.fragment, local);
    			transition_out(check2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(check0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(check1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(check2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_32.name,
    		type: "slot",
    		source: "(71:0) <FB line grid={10} around>",
    		ctx
    	});

    	return block;
    }

    // (76:0) <FB line grid={10} around>
    function create_default_slot_31(ctx) {
    	let check0;
    	let t0;
    	let check1;
    	let t1;
    	let check2;
    	let current;

    	check0 = new Check({
    			props: { lab: "foo", just: "s" },
    			$$inline: true
    		});

    	check1 = new Check({
    			props: { lab: "bar", just: "s" },
    			$$inline: true
    		});

    	check2 = new Check({
    			props: { lab: "baz", just: "s" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(check0.$$.fragment);
    			t0 = space();
    			create_component(check1.$$.fragment);
    			t1 = space();
    			create_component(check2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(check0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(check1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(check2, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(check0.$$.fragment, local);
    			transition_in(check1.$$.fragment, local);
    			transition_in(check2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(check0.$$.fragment, local);
    			transition_out(check1.$$.fragment, local);
    			transition_out(check2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(check0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(check1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(check2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_31.name,
    		type: "slot",
    		source: "(76:0) <FB line grid={10} around>",
    		ctx
    	});

    	return block;
    }

    // (81:0) <FB line grid={10} around>
    function create_default_slot_30(ctx) {
    	let text0;
    	let t0;
    	let text1;
    	let t1;
    	let text2;
    	let current;
    	text0 = new Text$1({ props: { lab: "foo" }, $$inline: true });
    	text1 = new Text$1({ props: { lab: "bar" }, $$inline: true });
    	text2 = new Text$1({ props: { lab: "baz" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(text0.$$.fragment);
    			t0 = space();
    			create_component(text1.$$.fragment);
    			t1 = space();
    			create_component(text2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(text0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(text1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(text2, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(text0.$$.fragment, local);
    			transition_in(text1.$$.fragment, local);
    			transition_in(text2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(text0.$$.fragment, local);
    			transition_out(text1.$$.fragment, local);
    			transition_out(text2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(text0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(text1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(text2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_30.name,
    		type: "slot",
    		source: "(81:0) <FB line grid={10} around>",
    		ctx
    	});

    	return block;
    }

    // (86:0) <FB line grid={10} around>
    function create_default_slot_29(ctx) {
    	let check0;
    	let t0;
    	let check1;
    	let t1;
    	let check2;
    	let current;

    	check0 = new Check({
    			props: { lab: "foo", just: "s" },
    			$$inline: true
    		});

    	check1 = new Check({
    			props: { lab: "bar", just: "s" },
    			$$inline: true
    		});

    	check2 = new Check({
    			props: { lab: "baz", just: "s" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(check0.$$.fragment);
    			t0 = space();
    			create_component(check1.$$.fragment);
    			t1 = space();
    			create_component(check2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(check0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(check1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(check2, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(check0.$$.fragment, local);
    			transition_in(check1.$$.fragment, local);
    			transition_in(check2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(check0.$$.fragment, local);
    			transition_out(check1.$$.fragment, local);
    			transition_out(check2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(check0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(check1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(check2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_29.name,
    		type: "slot",
    		source: "(86:0) <FB line grid={10} around>",
    		ctx
    	});

    	return block;
    }

    // (93:0) <FB line grid={10} around>
    function create_default_slot_28(ctx) {
    	let check0;
    	let t0;
    	let check1;
    	let t1;
    	let check2;
    	let current;
    	check0 = new Check({ props: { lab: "foo" }, $$inline: true });
    	check1 = new Check({ props: { lab: "bar" }, $$inline: true });
    	check2 = new Check({ props: { lab: "baz" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(check0.$$.fragment);
    			t0 = space();
    			create_component(check1.$$.fragment);
    			t1 = space();
    			create_component(check2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(check0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(check1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(check2, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(check0.$$.fragment, local);
    			transition_in(check1.$$.fragment, local);
    			transition_in(check2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(check0.$$.fragment, local);
    			transition_out(check1.$$.fragment, local);
    			transition_out(check2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(check0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(check1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(check2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_28.name,
    		type: "slot",
    		source: "(93:0) <FB line grid={10} around>",
    		ctx
    	});

    	return block;
    }

    // (99:0) <FB line grid={10} around>
    function create_default_slot_27(ctx) {
    	let check0;
    	let t0;
    	let check1;
    	let t1;
    	let check2;
    	let current;

    	check0 = new Check({
    			props: { lab: "foo", just: "e" },
    			$$inline: true
    		});

    	check1 = new Check({
    			props: { lab: "bar", just: "e" },
    			$$inline: true
    		});

    	check2 = new Check({
    			props: { lab: "baz", just: "e" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(check0.$$.fragment);
    			t0 = space();
    			create_component(check1.$$.fragment);
    			t1 = space();
    			create_component(check2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(check0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(check1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(check2, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(check0.$$.fragment, local);
    			transition_in(check1.$$.fragment, local);
    			transition_in(check2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(check0.$$.fragment, local);
    			transition_out(check1.$$.fragment, local);
    			transition_out(check2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(check0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(check1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(check2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_27.name,
    		type: "slot",
    		source: "(99:0) <FB line grid={10} around>",
    		ctx
    	});

    	return block;
    }

    // (109:2) <FB line="b6" vc fw={9}>
    function create_default_slot_26(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "SON";
    			add_location(span, file$s, 109, 4, 2261);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_26.name,
    		type: "slot",
    		source: "(109:2) <FB line=\\\"b6\\\" vc fw={9}>",
    		ctx
    	});

    	return block;
    }

    // (113:4) <FB line="s2" vc fw={9}>
    function create_default_slot_25(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "OF";
    			add_location(span, file$s, 113, 6, 2340);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_25.name,
    		type: "slot",
    		source: "(113:4) <FB line=\\\"s2\\\" vc fw={9}>",
    		ctx
    	});

    	return block;
    }

    // (112:2) <FB vert center>
    function create_default_slot_24(ctx) {
    	let fb;
    	let t;
    	let div;
    	let current;

    	fb = new FB({
    			props: {
    				line: "s2",
    				vc: true,
    				fw: 9,
    				$$slots: { default: [create_default_slot_25] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t = space();
    			div = element("div");
    			attr_dev(div, "class", "expander fill");
    			set_style(div, "height", "1.8rem");
    			add_location(div, file$s, 115, 4, 2370);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_24.name,
    		type: "slot",
    		source: "(112:2) <FB vert center>",
    		ctx
    	});

    	return block;
    }

    // (118:2) <FB line="b6" vc fw={9}>
    function create_default_slot_23(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "MAN";
    			add_location(span, file$s, 118, 4, 2467);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23.name,
    		type: "slot",
    		source: "(118:2) <FB line=\\\"b6\\\" vc fw={9}>",
    		ctx
    	});

    	return block;
    }

    // (122:4) <FB line="s2">
    function create_default_slot_22(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "you cannot";
    			add_location(span, file$s, 122, 6, 2532);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22.name,
    		type: "slot",
    		source: "(122:4) <FB line=\\\"s2\\\">",
    		ctx
    	});

    	return block;
    }

    // (126:6) <FB line="b4" vc>
    function create_default_slot_21(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "SAY";
    			add_location(span, file$s, 126, 8, 2619);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21.name,
    		type: "slot",
    		source: "(126:6) <FB line=\\\"b4\\\" vc>",
    		ctx
    	});

    	return block;
    }

    // (129:6) <FB line="s3" vc>
    function create_default_slot_20(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "or";
    			add_location(span, file$s, 129, 8, 2680);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20.name,
    		type: "slot",
    		source: "(129:6) <FB line=\\\"s3\\\" vc>",
    		ctx
    	});

    	return block;
    }

    // (125:4) <FB center zero>
    function create_default_slot_19(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				line: "b4",
    				vc: true,
    				$$slots: { default: [create_default_slot_21] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				line: "s3",
    				vc: true,
    				$$slots: { default: [create_default_slot_20] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19.name,
    		type: "slot",
    		source: "(125:4) <FB center zero>",
    		ctx
    	});

    	return block;
    }

    // (121:2) <FB vert vc>
    function create_default_slot_18(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				line: "s2",
    				$$slots: { default: [create_default_slot_22] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				center: true,
    				zero: true,
    				$$slots: { default: [create_default_slot_19] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18.name,
    		type: "slot",
    		source: "(121:2) <FB vert vc>",
    		ctx
    	});

    	return block;
    }

    // (134:2) <FB line="b6" vc>
    function create_default_slot_17(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "GUESS";
    			add_location(span, file$s, 134, 4, 2750);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17.name,
    		type: "slot",
    		source: "(134:2) <FB line=\\\"b6\\\" vc>",
    		ctx
    	});

    	return block;
    }

    // (108:0) <FB center fw={9}>
    function create_default_slot_16(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let fb2;
    	let t2;
    	let fb3;
    	let t3;
    	let fb4;
    	let current;

    	fb0 = new FB({
    			props: {
    				line: "b6",
    				vc: true,
    				fw: 9,
    				$$slots: { default: [create_default_slot_26] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				vert: true,
    				center: true,
    				$$slots: { default: [create_default_slot_24] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb2 = new FB({
    			props: {
    				line: "b6",
    				vc: true,
    				fw: 9,
    				$$slots: { default: [create_default_slot_23] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb3 = new FB({
    			props: {
    				vert: true,
    				vc: true,
    				$$slots: { default: [create_default_slot_18] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb4 = new FB({
    			props: {
    				line: "b6",
    				vc: true,
    				$$slots: { default: [create_default_slot_17] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    			create_component(fb2.$$.fragment);
    			t2 = space();
    			create_component(fb3.$$.fragment);
    			t3 = space();
    			create_component(fb4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(fb3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(fb4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    			const fb2_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb2_changes.$$scope = { dirty, ctx };
    			}

    			fb2.$set(fb2_changes);
    			const fb3_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb3_changes.$$scope = { dirty, ctx };
    			}

    			fb3.$set(fb3_changes);
    			const fb4_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb4_changes.$$scope = { dirty, ctx };
    			}

    			fb4.$set(fb4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(fb2.$$.fragment, local);
    			transition_in(fb3.$$.fragment, local);
    			transition_in(fb4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(fb2.$$.fragment, local);
    			transition_out(fb3.$$.fragment, local);
    			transition_out(fb4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(fb3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(fb4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16.name,
    		type: "slot",
    		source: "(108:0) <FB center fw={9}>",
    		ctx
    	});

    	return block;
    }

    // (140:4) <FB line="s3" vc>
    function create_default_slot_15(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "for you";
    			add_location(span, file$s, 140, 6, 2854);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15.name,
    		type: "slot",
    		source: "(140:4) <FB line=\\\"s3\\\" vc>",
    		ctx
    	});

    	return block;
    }

    // (143:4) <FB line="s3" vc end>
    function create_default_slot_14(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "know";
    			add_location(span, file$s, 143, 6, 2917);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14.name,
    		type: "slot",
    		source: "(143:4) <FB line=\\\"s3\\\" vc end>",
    		ctx
    	});

    	return block;
    }

    // (139:2) <FB vert center zero>
    function create_default_slot_13(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				line: "s3",
    				vc: true,
    				$$slots: { default: [create_default_slot_15] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				line: "s3",
    				vc: true,
    				end: true,
    				$$slots: { default: [create_default_slot_14] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13.name,
    		type: "slot",
    		source: "(139:2) <FB vert center zero>",
    		ctx
    	});

    	return block;
    }

    // (147:2) <FB line="b3" fw="6">
    function create_default_slot_12(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("ONLY");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(147:2) <FB line=\\\"b3\\\" fw=\\\"6\\\">",
    		ctx
    	});

    	return block;
    }

    // (138:0) <FB center fw={9}>
    function create_default_slot_11$1(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				vert: true,
    				center: true,
    				zero: true,
    				$$slots: { default: [create_default_slot_13] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				line: "b3",
    				fw: "6",
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$1.name,
    		type: "slot",
    		source: "(138:0) <FB center fw={9}>",
    		ctx
    	});

    	return block;
    }

    // (151:4) <FB line="b5" vc>
    function create_default_slot_10$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "A";
    			add_location(span, file$s, 151, 6, 3058);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$1.name,
    		type: "slot",
    		source: "(151:4) <FB line=\\\"b5\\\" vc>",
    		ctx
    	});

    	return block;
    }

    // (150:2) <FB vert center>
    function create_default_slot_9$1(ctx) {
    	let fb;
    	let t;
    	let div;
    	let current;

    	fb = new FB({
    			props: {
    				line: "b5",
    				vc: true,
    				$$slots: { default: [create_default_slot_10$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    			t = space();
    			div = element("div");
    			attr_dev(div, "class", "expander fill");
    			set_style(div, "height", "0.4rem");
    			add_location(div, file$s, 153, 4, 3087);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$1.name,
    		type: "slot",
    		source: "(150:2) <FB vert center>",
    		ctx
    	});

    	return block;
    }

    // (156:2) <FB line="b6" vc>
    function create_default_slot_8$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "HEAP";
    			add_location(span, file$s, 156, 4, 3177);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$1.name,
    		type: "slot",
    		source: "(156:2) <FB line=\\\"b6\\\" vc>",
    		ctx
    	});

    	return block;
    }

    // (160:6) <FB line="s1" vc>
    function create_default_slot_7$1(ctx) {
    	let span;
    	let t1;
    	let pipe;
    	let current;
    	pipe = new Pipe({ $$inline: true });

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "of";
    			t1 = space();
    			create_component(pipe.$$.fragment);
    			add_location(span, file$s, 160, 8, 3262);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(pipe, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pipe.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pipe.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t1);
    			destroy_component(pipe, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$1.name,
    		type: "slot",
    		source: "(160:6) <FB line=\\\"s1\\\" vc>",
    		ctx
    	});

    	return block;
    }

    // (164:6) <FB line="b5" vc>
    function create_default_slot_6$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "BROKEN";
    			add_location(span, file$s, 164, 8, 3338);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(164:6) <FB line=\\\"b5\\\" vc>",
    		ctx
    	});

    	return block;
    }

    // (159:2) <FB vert vc center zero>
    function create_default_slot_5$1(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				line: "s1",
    				vc: true,
    				$$slots: { default: [create_default_slot_7$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				line: "b5",
    				vc: true,
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(159:2) <FB vert vc center zero>",
    		ctx
    	});

    	return block;
    }

    // (169:6) <FB line="b5" vc>
    function create_default_slot_4$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "IMAGES";
    			add_location(span, file$s, 169, 8, 3437);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(169:6) <FB line=\\\"b5\\\" vc>",
    		ctx
    	});

    	return block;
    }

    // (172:6) <FB line="s1" vc end>
    function create_default_slot_3$3(ctx) {
    	let span0;
    	let t1;
    	let span1;
    	let t3;
    	let span2;
    	let t5;
    	let span3;

    	const block = {
    		c: function create() {
    			span0 = element("span");
    			span0.textContent = "where";
    			t1 = space();
    			span1 = element("span");
    			span1.textContent = "the";
    			t3 = space();
    			span2 = element("span");
    			span2.textContent = "sun";
    			t5 = space();
    			span3 = element("span");
    			span3.textContent = "beats";
    			add_location(span0, file$s, 172, 8, 3505);
    			add_location(span1, file$s, 173, 8, 3532);
    			add_location(span2, file$s, 174, 8, 3557);
    			add_location(span3, file$s, 175, 8, 3582);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, span1, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, span2, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, span3, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(span1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(span2);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(span3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(172:6) <FB line=\\\"s1\\\" vc end>",
    		ctx
    	});

    	return block;
    }

    // (168:2) <FB vert vc center zero>
    function create_default_slot_2$5(ctx) {
    	let fb0;
    	let t;
    	let fb1;
    	let current;

    	fb0 = new FB({
    			props: {
    				line: "b5",
    				vc: true,
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				line: "s1",
    				vc: true,
    				end: true,
    				$$slots: { default: [create_default_slot_3$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t = space();
    			create_component(fb1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(fb1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(fb1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(168:2) <FB vert vc center zero>",
    		ctx
    	});

    	return block;
    }

    // (149:0) <FB center fw={9}>
    function create_default_slot_1$6(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let fb2;
    	let t2;
    	let fb3;
    	let current;

    	fb0 = new FB({
    			props: {
    				vert: true,
    				center: true,
    				$$slots: { default: [create_default_slot_9$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				line: "b6",
    				vc: true,
    				$$slots: { default: [create_default_slot_8$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb2 = new FB({
    			props: {
    				vert: true,
    				vc: true,
    				center: true,
    				zero: true,
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb3 = new FB({
    			props: {
    				vert: true,
    				vc: true,
    				center: true,
    				zero: true,
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    			create_component(fb2.$$.fragment);
    			t2 = space();
    			create_component(fb3.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(fb3, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);
    			const fb2_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb2_changes.$$scope = { dirty, ctx };
    			}

    			fb2.$set(fb2_changes);
    			const fb3_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb3_changes.$$scope = { dirty, ctx };
    			}

    			fb3.$set(fb3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(fb2.$$.fragment, local);
    			transition_in(fb3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(fb2.$$.fragment, local);
    			transition_out(fb3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(fb3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(149:0) <FB center fw={9}>",
    		ctx
    	});

    	return block;
    }

    // (21:0) <FB vert>
    function create_default_slot$9(ctx) {
    	let fb0;
    	let t0;
    	let fb1;
    	let t1;
    	let fb2;
    	let t2;
    	let fb3;
    	let t3;
    	let fb4;
    	let t4;
    	let fb5;
    	let t5;
    	let fb6;
    	let t6;
    	let fb7;
    	let t7;
    	let fb8;
    	let t8;
    	let fb9;
    	let t9;
    	let fb10;
    	let t10;
    	let fb11;
    	let t11;
    	let fb12;
    	let t12;
    	let table;
    	let current;

    	fb0 = new FB({
    			props: {
    				grid: 3,
    				around: true,
    				$$slots: { default: [create_default_slot_34] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb1 = new FB({ props: { spacer: "3" }, $$inline: true });

    	fb2 = new FB({
    			props: {
    				line: true,
    				grid: 10,
    				around: true,
    				$$slots: { default: [create_default_slot_33] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb3 = new FB({
    			props: {
    				line: true,
    				grid: 10,
    				around: true,
    				$$slots: { default: [create_default_slot_32] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb4 = new FB({
    			props: {
    				line: true,
    				grid: 10,
    				around: true,
    				$$slots: { default: [create_default_slot_31] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb5 = new FB({
    			props: {
    				line: true,
    				grid: 10,
    				around: true,
    				$$slots: { default: [create_default_slot_30] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb6 = new FB({
    			props: {
    				line: true,
    				grid: 10,
    				around: true,
    				$$slots: { default: [create_default_slot_29] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb7 = new FB({
    			props: {
    				line: true,
    				grid: 10,
    				around: true,
    				$$slots: { default: [create_default_slot_28] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb8 = new FB({
    			props: {
    				line: true,
    				grid: 10,
    				around: true,
    				$$slots: { default: [create_default_slot_27] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb9 = new FB({ props: { spacer: "5" }, $$inline: true });

    	fb10 = new FB({
    			props: {
    				center: true,
    				fw: 9,
    				$$slots: { default: [create_default_slot_16] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb11 = new FB({
    			props: {
    				center: true,
    				fw: 9,
    				$$slots: { default: [create_default_slot_11$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb12 = new FB({
    			props: {
    				center: true,
    				fw: 9,
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	table = new Table$1({
    			props: { data: /*data*/ ctx[1], line: "s3" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			create_component(fb1.$$.fragment);
    			t1 = space();
    			create_component(fb2.$$.fragment);
    			t2 = space();
    			create_component(fb3.$$.fragment);
    			t3 = space();
    			create_component(fb4.$$.fragment);
    			t4 = space();
    			create_component(fb5.$$.fragment);
    			t5 = space();
    			create_component(fb6.$$.fragment);
    			t6 = space();
    			create_component(fb7.$$.fragment);
    			t7 = space();
    			create_component(fb8.$$.fragment);
    			t8 = space();
    			create_component(fb9.$$.fragment);
    			t9 = space();
    			create_component(fb10.$$.fragment);
    			t10 = space();
    			create_component(fb11.$$.fragment);
    			t11 = space();
    			create_component(fb12.$$.fragment);
    			t12 = space();
    			create_component(table.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(fb2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(fb3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(fb4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(fb5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(fb6, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(fb7, target, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(fb8, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(fb9, target, anchor);
    			insert_dev(target, t9, anchor);
    			mount_component(fb10, target, anchor);
    			insert_dev(target, t10, anchor);
    			mount_component(fb11, target, anchor);
    			insert_dev(target, t11, anchor);
    			mount_component(fb12, target, anchor);
    			insert_dev(target, t12, anchor);
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);
    			const fb2_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb2_changes.$$scope = { dirty, ctx };
    			}

    			fb2.$set(fb2_changes);
    			const fb3_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb3_changes.$$scope = { dirty, ctx };
    			}

    			fb3.$set(fb3_changes);
    			const fb4_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb4_changes.$$scope = { dirty, ctx };
    			}

    			fb4.$set(fb4_changes);
    			const fb5_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb5_changes.$$scope = { dirty, ctx };
    			}

    			fb5.$set(fb5_changes);
    			const fb6_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb6_changes.$$scope = { dirty, ctx };
    			}

    			fb6.$set(fb6_changes);
    			const fb7_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb7_changes.$$scope = { dirty, ctx };
    			}

    			fb7.$set(fb7_changes);
    			const fb8_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb8_changes.$$scope = { dirty, ctx };
    			}

    			fb8.$set(fb8_changes);
    			const fb10_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb10_changes.$$scope = { dirty, ctx };
    			}

    			fb10.$set(fb10_changes);
    			const fb11_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb11_changes.$$scope = { dirty, ctx };
    			}

    			fb11.$set(fb11_changes);
    			const fb12_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb12_changes.$$scope = { dirty, ctx };
    			}

    			fb12.$set(fb12_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(fb2.$$.fragment, local);
    			transition_in(fb3.$$.fragment, local);
    			transition_in(fb4.$$.fragment, local);
    			transition_in(fb5.$$.fragment, local);
    			transition_in(fb6.$$.fragment, local);
    			transition_in(fb7.$$.fragment, local);
    			transition_in(fb8.$$.fragment, local);
    			transition_in(fb9.$$.fragment, local);
    			transition_in(fb10.$$.fragment, local);
    			transition_in(fb11.$$.fragment, local);
    			transition_in(fb12.$$.fragment, local);
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(fb2.$$.fragment, local);
    			transition_out(fb3.$$.fragment, local);
    			transition_out(fb4.$$.fragment, local);
    			transition_out(fb5.$$.fragment, local);
    			transition_out(fb6.$$.fragment, local);
    			transition_out(fb7.$$.fragment, local);
    			transition_out(fb8.$$.fragment, local);
    			transition_out(fb9.$$.fragment, local);
    			transition_out(fb10.$$.fragment, local);
    			transition_out(fb11.$$.fragment, local);
    			transition_out(fb12.$$.fragment, local);
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(fb2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(fb3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(fb4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(fb5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(fb6, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(fb7, detaching);
    			if (detaching) detach_dev(t7);
    			destroy_component(fb8, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(fb9, detaching);
    			if (detaching) detach_dev(t9);
    			destroy_component(fb10, detaching);
    			if (detaching) detach_dev(t10);
    			destroy_component(fb11, detaching);
    			if (detaching) detach_dev(t11);
    			destroy_component(fb12, detaching);
    			if (detaching) detach_dev(t12);
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(21:0) <FB vert>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TestForms', slots, []);
    	const sizes = ['s3', 's2', 's1', 'n', 'b1', 'b2', 'b3'];

    	const data = {
    		author: "Gideon",
    		views: 30959694,
    		version: 858,
    		foo: 'bar',
    		baz: 'bat',
    		date: '03-18-1987',
    		era: 'third'
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TestForms> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		FB,
    		Pipe,
    		Balance,
    		Check,
    		Text: Text$1,
    		Numeric,
    		Table: Table$1,
    		sizes,
    		data
    	});

    	return [sizes, data];
    }

    class TestForms extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TestForms",
    			options,
    			id: create_fragment$B.name
    		});
    	}
    }

    /* src/special/TestLinks.svelte generated by Svelte v3.44.3 */

    // (10:0) <Link nst="foo" dbg>
    function create_default_slot_3$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("NST: 'foo'");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(10:0) <Link nst=\\\"foo\\\" dbg>",
    		ctx
    	});

    	return block;
    }

    // (11:0) <Link nst="main:bar" dbg>
    function create_default_slot_2$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("NST: 'main:bar'");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(11:0) <Link nst=\\\"main:bar\\\" dbg>",
    		ctx
    	});

    	return block;
    }

    // (12:0) <Link title="bar" dbg>
    function create_default_slot_1$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("TITLE ONLY: 'bar'");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(12:0) <Link title=\\\"bar\\\" dbg>",
    		ctx
    	});

    	return block;
    }

    // (13:0) <Link space="xxx" dbg>
    function create_default_slot$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("SPACE ONLY: 'xxx'");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(13:0) <Link space=\\\"xxx\\\" dbg>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let link0;
    	let t0;
    	let link1;
    	let t1;
    	let link2;
    	let t2;
    	let link3;
    	let current;

    	link0 = new Link$1({
    			props: {
    				nst: "foo",
    				dbg: true,
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link$1({
    			props: {
    				nst: "main:bar",
    				dbg: true,
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link2 = new Link$1({
    			props: {
    				title: "bar",
    				dbg: true,
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link3 = new Link$1({
    			props: {
    				space: "xxx",
    				dbg: true,
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link0.$$.fragment);
    			t0 = space();
    			create_component(link1.$$.fragment);
    			t1 = space();
    			create_component(link2.$$.fragment);
    			t2 = space();
    			create_component(link3.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(link0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(link1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(link2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(link3, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const link0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    			const link2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				link2_changes.$$scope = { dirty, ctx };
    			}

    			link2.$set(link2_changes);
    			const link3_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				link3_changes.$$scope = { dirty, ctx };
    			}

    			link3.$set(link3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(link2.$$.fragment, local);
    			transition_in(link3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(link2.$$.fragment, local);
    			transition_out(link3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(link1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(link2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(link3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TestLinks', slots, []);
    	let h1;
    	let h2;
    	let h3;
    	let h4;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TestLinks> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ FB, Link: Link$1, h1, h2, h3, h4 });

    	$$self.$inject_state = $$props => {
    		if ('h1' in $$props) h1 = $$props.h1;
    		if ('h2' in $$props) h2 = $$props.h2;
    		if ('h3' in $$props) h3 = $$props.h3;
    		if ('h4' in $$props) h4 = $$props.h4;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class TestLinks extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TestLinks",
    			options,
    			id: create_fragment$A.name
    		});
    	}
    }

    /* src/err/E401.svelte generated by Svelte v3.44.3 */

    const file$r = "src/err/E401.svelte";

    function create_fragment$z(ctx) {
    	let h1;
    	let t1;
    	let p;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "ERROR 401 (CE2)";
    			t1 = space();
    			p = element("p");
    			p.textContent = "Unauthorized action.";
    			add_location(h1, file$r, 0, 0, 0);
    			add_location(p, file$r, 1, 0, 25);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('E401', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<E401> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class E401 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "E401",
    			options,
    			id: create_fragment$z.name
    		});
    	}
    }

    /* src/err/E404.svelte generated by Svelte v3.44.3 */

    const file$q = "src/err/E404.svelte";

    function create_fragment$y(ctx) {
    	let h1;
    	let t1;
    	let p;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "404";
    			t1 = space();
    			p = element("p");
    			p.textContent = "404 not found";
    			add_location(h1, file$q, 0, 0, 0);
    			add_location(p, file$q, 1, 0, 13);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('E404', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<E404> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class E404 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "E404",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    /* src/err/E500.svelte generated by Svelte v3.44.3 */

    const file$p = "src/err/E500.svelte";

    function create_fragment$x(ctx) {
    	let h1;
    	let t1;
    	let p;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "500";
    			t1 = space();
    			p = element("p");
    			p.textContent = "500 internal error";
    			add_location(h1, file$p, 0, 0, 0);
    			add_location(p, file$p, 1, 0, 13);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('E500', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<E500> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class E500 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "E500",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    /* src/HistoryItem.svelte generated by Svelte v3.44.3 */
    const file$o = "src/HistoryItem.svelte";

    // (15:42) <UUID>
    function create_default_slot_2$3(ctx) {
    	let t_value = /*item*/ ctx[0].uuid + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*item*/ 1 && t_value !== (t_value = /*item*/ ctx[0].uuid + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(15:42) <UUID>",
    		ctx
    	});

    	return block;
    }

    // (15:19) <Link uuid={item.uuid}>
    function create_default_slot_1$4(ctx) {
    	let uuid;
    	let current;

    	uuid = new UUID({
    			props: {
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(uuid.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(uuid, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const uuid_changes = {};

    			if (dirty & /*$$scope, item*/ 5) {
    				uuid_changes.$$scope = { dirty, ctx };
    			}

    			uuid.$set(uuid_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(uuid.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(uuid.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(uuid, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(15:19) <Link uuid={item.uuid}>",
    		ctx
    	});

    	return block;
    }

    // (15:4) <Balance right>
    function create_default_slot$7(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				uuid: /*item*/ ctx[0].uuid,
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const link_changes = {};
    			if (dirty & /*item*/ 1) link_changes.uuid = /*item*/ ctx[0].uuid;

    			if (dirty & /*$$scope, item*/ 5) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(15:4) <Balance right>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*item*/ ctx[0].vnum + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*item*/ ctx[0].user.handle + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*item*/ ctx[0].title + "";
    	let t4;
    	let t5;
    	let td3;
    	let balance;
    	let current;

    	balance = new Balance({
    			props: {
    				right: true,
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text(t4_value);
    			t5 = space();
    			td3 = element("td");
    			create_component(balance.$$.fragment);
    			attr_dev(td0, "class", "history-num");
    			add_location(td0, file$o, 10, 2, 245);
    			attr_dev(td1, "class", "history-user");
    			add_location(td1, file$o, 11, 2, 288);
    			attr_dev(td2, "class", "history-title");
    			add_location(td2, file$o, 12, 2, 339);
    			attr_dev(td3, "class", "history-vuuid grow");
    			add_location(td3, file$o, 13, 2, 385);
    			attr_dev(tr, "class", "history-item");
    			add_location(tr, file$o, 9, 0, 217);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			mount_component(balance, td3, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*item*/ 1) && t0_value !== (t0_value = /*item*/ ctx[0].vnum + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*item*/ 1) && t2_value !== (t2_value = /*item*/ ctx[0].user.handle + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty & /*item*/ 1) && t4_value !== (t4_value = /*item*/ ctx[0].title + "")) set_data_dev(t4, t4_value);
    			const balance_changes = {};

    			if (dirty & /*$$scope, item*/ 5) {
    				balance_changes.$$scope = { dirty, ctx };
    			}

    			balance.$set(balance_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(balance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(balance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_component(balance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HistoryItem', slots, []);
    	const gs = getContext('gs');
    	let { item } = $$props;
    	const writable_props = ['item'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HistoryItem> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('item' in $$props) $$invalidate(0, item = $$props.item);
    	};

    	$$self.$capture_state = () => ({
    		Link: Link$1,
    		UUID,
    		Balance,
    		getContext,
    		gs,
    		item
    	});

    	$$self.$inject_state = $$props => {
    		if ('item' in $$props) $$invalidate(0, item = $$props.item);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [item];
    }

    class HistoryItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, { item: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HistoryItem",
    			options,
    			id: create_fragment$w.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*item*/ ctx[0] === undefined && !('item' in props)) {
    			console.warn("<HistoryItem> was created without expected prop 'item'");
    		}
    	}

    	get item() {
    		throw new Error("<HistoryItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<HistoryItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/History.svelte generated by Svelte v3.44.3 */
    const file$n = "src/History.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (16:0) {#if $hashistory}
    function create_if_block$8(ctx) {
    	let table;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let t8;
    	let fb;
    	let t9;
    	let searchpagination;
    	let current;
    	let each_value = /*$history*/ ctx[1].val.items;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	fb = new FB({ props: { expand: true }, $$inline: true });

    	searchpagination = new SearchPagination({
    			props: { result: /*$history*/ ctx[1].val },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			table = element("table");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "VER.";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "USER";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "TITLE";
    			t5 = space();
    			th3 = element("th");
    			th3.textContent = "UUID";
    			t7 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t8 = space();
    			create_component(fb.$$.fragment);
    			t9 = space();
    			create_component(searchpagination.$$.fragment);
    			add_location(th0, file$n, 18, 4, 457);
    			add_location(th1, file$n, 19, 4, 475);
    			add_location(th2, file$n, 20, 4, 493);
    			attr_dev(th3, "class", "grow");
    			add_location(th3, file$n, 21, 4, 512);
    			add_location(tr, file$n, 17, 2, 448);
    			attr_dev(table, "class", "history-items");
    			add_location(table, file$n, 16, 2, 416);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(table, t7);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}

    			insert_dev(target, t8, anchor);
    			mount_component(fb, target, anchor);
    			insert_dev(target, t9, anchor);
    			mount_component(searchpagination, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$history*/ 2) {
    				each_value = /*$history*/ ctx[1].val.items;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(table, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const searchpagination_changes = {};
    			if (dirty & /*$history*/ 2) searchpagination_changes.result = /*$history*/ ctx[1].val;
    			searchpagination.$set(searchpagination_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(fb.$$.fragment, local);
    			transition_in(searchpagination.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(fb.$$.fragment, local);
    			transition_out(searchpagination.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t9);
    			destroy_component(searchpagination, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(16:0) {#if $hashistory}",
    		ctx
    	});

    	return block;
    }

    // (24:2) {#each $history.val.items as item}
    function create_each_block$1(ctx) {
    	let historyitem;
    	let current;

    	historyitem = new HistoryItem({
    			props: { item: /*item*/ ctx[5] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(historyitem.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(historyitem, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const historyitem_changes = {};
    			if (dirty & /*$history*/ 2) historyitem_changes.item = /*item*/ ctx[5];
    			historyitem.$set(historyitem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(historyitem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(historyitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(historyitem, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(24:2) {#each $history.val.items as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$hashistory*/ ctx[0] && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$hashistory*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$hashistory*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let $hashistory;
    	let $history;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('History', slots, []);
    	const history = getContext('history');
    	validate_store(history, 'history');
    	component_subscribe($$self, history, value => $$invalidate(1, $history = value));
    	const hashistory = getContext('hashistory');
    	validate_store(hashistory, 'hashistory');
    	component_subscribe($$self, hashistory, value => $$invalidate(0, $hashistory = value));

    	const heading = {
    		vnum: 'VERSION',
    		user: { handle: 'AUTHOR' },
    		title: 'TITLE',
    		uuid: 'UUID'
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<History> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		HistoryItem,
    		SearchPagination,
    		FB,
    		getContext,
    		history,
    		hashistory,
    		heading,
    		$hashistory,
    		$history
    	});

    	return [$hashistory, $history, history, hashistory];
    }

    class History extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "History",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* src/LinkShim.svelte generated by Svelte v3.44.3 */

    // (9:0) <Link {nst} {title}>
    function create_default_slot$6(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(9:0) <Link {nst} {title}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				nst: /*nst*/ ctx[1],
    				title: /*title*/ ctx[0],
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const link_changes = {};
    			if (dirty & /*title*/ 1) link_changes.title = /*title*/ ctx[0];

    			if (dirty & /*$$scope*/ 16) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LinkShim', slots, ['default']);
    	let { href = '' } = $$props;
    	let { title = undefined } = $$props;
    	let nst = href;
    	const writable_props = ['href', 'title'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LinkShim> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('href' in $$props) $$invalidate(2, href = $$props.href);
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ Link: Link$1, util, href, title, nst });

    	$$self.$inject_state = $$props => {
    		if ('href' in $$props) $$invalidate(2, href = $$props.href);
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('nst' in $$props) $$invalidate(1, nst = $$props.nst);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [title, nst, href, slots, $$scope];
    }

    class LinkShim extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, { href: 2, title: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LinkShim",
    			options,
    			id: create_fragment$u.name
    		});
    	}

    	get href() {
    		throw new Error("<LinkShim>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<LinkShim>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<LinkShim>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<LinkShim>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/CPBLinkShim.svelte generated by Svelte v3.44.3 */

    // (9:0) <Link {nst}>
    function create_default_slot$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*display*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*display*/ 2) set_data_dev(t, /*display*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(9:0) <Link {nst}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let link;
    	let current;

    	link = new Link$1({
    			props: {
    				nst: /*nst*/ ctx[0],
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(link.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(link, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const link_changes = {};
    			if (dirty & /*nst*/ 1) link_changes.nst = /*nst*/ ctx[0];

    			if (dirty & /*$$scope, display*/ 10) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(link, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let display;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CPBLinkShim', slots, []);
    	let { nst } = $$props;
    	let { text = null } = $$props;
    	const writable_props = ['nst', 'text'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CPBLinkShim> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('nst' in $$props) $$invalidate(0, nst = $$props.nst);
    		if ('text' in $$props) $$invalidate(2, text = $$props.text);
    	};

    	$$self.$capture_state = () => ({ Link: Link$1, util, nst, text, display });

    	$$self.$inject_state = $$props => {
    		if ('nst' in $$props) $$invalidate(0, nst = $$props.nst);
    		if ('text' in $$props) $$invalidate(2, text = $$props.text);
    		if ('display' in $$props) $$invalidate(1, display = $$props.display);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*text, nst*/ 5) {
    			$$invalidate(1, display = text || nst);
    		}
    	};

    	return [nst, display, text];
    }

    class CPBLinkShim extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, { nst: 0, text: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CPBLinkShim",
    			options,
    			id: create_fragment$t.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*nst*/ ctx[0] === undefined && !('nst' in props)) {
    			console.warn("<CPBLinkShim> was created without expected prop 'nst'");
    		}
    	}

    	get nst() {
    		throw new Error("<CPBLinkShim>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nst(value) {
    		throw new Error("<CPBLinkShim>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<CPBLinkShim>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<CPBLinkShim>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/infobar/InfoModule.svelte generated by Svelte v3.44.3 */
    const get_body_slot_changes = dirty => ({});
    const get_body_slot_context = ctx => ({});
    const get_title_slot_changes = dirty => ({});
    const get_title_slot_context = ctx => ({});

    // (6:2) {#if $$slots.title}
    function create_if_block_1$3(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				center: true,
    				line: "s1",
    				c: "info-head blacktag",
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(6:2) {#if $$slots.title}",
    		ctx
    	});

    	return block;
    }

    // (7:4) <FB center line="s1" c="info-head blacktag">
    function create_default_slot_2$2(ctx) {
    	let current;
    	const title_slot_template = /*#slots*/ ctx[1].title;
    	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[2], get_title_slot_context);

    	const block = {
    		c: function create() {
    			if (title_slot) title_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (title_slot) {
    				title_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (title_slot) {
    				if (title_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						title_slot,
    						title_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[2], dirty, get_title_slot_changes),
    						get_title_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(title_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(title_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (title_slot) title_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(7:4) <FB center line=\\\"s1\\\" c=\\\"info-head blacktag\\\">",
    		ctx
    	});

    	return block;
    }

    // (11:2) {#if $$slots.body}
    function create_if_block$7(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				expand: true,
    				c: "info-body",
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(11:2) {#if $$slots.body}",
    		ctx
    	});

    	return block;
    }

    // (12:4) <FB expand c="info-body">
    function create_default_slot_1$3(ctx) {
    	let current;
    	const body_slot_template = /*#slots*/ ctx[1].body;
    	const body_slot = create_slot(body_slot_template, ctx, /*$$scope*/ ctx[2], get_body_slot_context);

    	const block = {
    		c: function create() {
    			if (body_slot) body_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (body_slot) {
    				body_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (body_slot) {
    				if (body_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						body_slot,
    						body_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(body_slot_template, /*$$scope*/ ctx[2], dirty, get_body_slot_changes),
    						get_body_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(body_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(body_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (body_slot) body_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(12:4) <FB expand c=\\\"info-body\\\">",
    		ctx
    	});

    	return block;
    }

    // (5:0) <FB vert c="info-module">
    function create_default_slot$4(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*$$slots*/ ctx[0].title && create_if_block_1$3(ctx);
    	let if_block1 = /*$$slots*/ ctx[0].body && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$$slots*/ ctx[0].title) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$$slots*/ ctx[0].body) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$7(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(5:0) <FB vert c=\\\"info-module\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				c: "info-module",
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, $$slots*/ 5) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('InfoModule', slots, ['title','body']);
    	const $$slots = compute_slots(slots);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<InfoModule> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ FB });
    	return [$$slots, slots, $$scope];
    }

    class InfoModule extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InfoModule",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* src/infobar/InfoTOC.svelte generated by Svelte v3.44.3 */

    // (11:2) <svelte:fragment slot="title">
    function create_title_slot(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("CONTENTS");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot.name,
    		type: "slot",
    		source: "(11:2) <svelte:fragment slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (13:2) <svelte:fragment slot="body">
    function create_body_slot(ctx) {
    	let toc;
    	let current;
    	toc = new TOC({ props: { limit: 2 }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(toc.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(toc, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toc.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toc.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(toc, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot.name,
    		type: "slot",
    		source: "(13:2) <svelte:fragment slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let infomodule;
    	let current;

    	infomodule = new InfoModule({
    			props: {
    				$$slots: {
    					body: [create_body_slot],
    					title: [create_title_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(infomodule.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(infomodule, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const infomodule_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				infomodule_changes.$$scope = { dirty, ctx };
    			}

    			infomodule.$set(infomodule_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(infomodule.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(infomodule.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(infomodule, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('InfoTOC', slots, []);
    	const state = getContext('state');
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<InfoTOC> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ InfoModule, TOC, getContext, state });
    	return [];
    }

    class InfoTOC extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InfoTOC",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    /* src/infobar/Infobar.svelte generated by Svelte v3.44.3 */
    const file$m = "src/infobar/Infobar.svelte";

    // (49:6) {:else}
    function create_else_block$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("VERSION");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(49:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (47:6) {#if $state.head || $state.anchor}
    function create_if_block_2$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("PAGE");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(47:6) {#if $state.head || $state.anchor}",
    		ctx
    	});

    	return block;
    }

    // (45:2) <FB center line="s1" c="blacktag">
    function create_default_slot_3$1(ctx) {
    	let t;
    	let span;

    	function select_block_type(ctx, dirty) {
    		if (/*$state*/ ctx[4].head || /*$state*/ ctx[4].anchor) return create_if_block_2$2;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			t = text("TYPE: ");
    			span = element("span");
    			if_block.c();
    			attr_dev(span, "class", "blackval");
    			add_location(span, file$m, 45, 10, 1183);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, span, anchor);
    			if_block.m(span, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(span);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(45:2) <FB center line=\\\"s1\\\" c=\\\"blacktag\\\">",
    		ctx
    	});

    	return block;
    }

    // (55:2) {#if $state.pageperm || $state.verperm}
    function create_if_block_1$2(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				center: true,
    				line: "s1",
    				c: "blacktag",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(55:2) {#if $state.pageperm || $state.verperm}",
    		ctx
    	});

    	return block;
    }

    // (56:4) <FB center line="s1" c="blacktag">
    function create_default_slot_2$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("PERMALINK");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(56:4) <FB center line=\\\"s1\\\" c=\\\"blacktag\\\">",
    		ctx
    	});

    	return block;
    }

    // (63:2) <FB c="qrcodes" around>
    function create_default_slot_1$2(ctx) {
    	let qr0;
    	let t;
    	let qr1;
    	let current;

    	qr0 = new QR({
    			props: {
    				data: /*vpermac*/ ctx[2],
    				ver: 3,
    				scale: 2,
    				uuid: /*$page*/ ctx[0].val.uuid,
    				title: "Version Permalink"
    			},
    			$$inline: true
    		});

    	qr1 = new QR({
    			props: {
    				data: /*permac*/ ctx[1],
    				ver: 3,
    				scale: 2,
    				uuid: /*$page*/ ctx[0].val.pageUuid,
    				title: "Page Permalink"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(qr0.$$.fragment);
    			t = space();
    			create_component(qr1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(qr0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(qr1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const qr0_changes = {};
    			if (dirty & /*vpermac*/ 4) qr0_changes.data = /*vpermac*/ ctx[2];
    			if (dirty & /*$page*/ 1) qr0_changes.uuid = /*$page*/ ctx[0].val.uuid;
    			qr0.$set(qr0_changes);
    			const qr1_changes = {};
    			if (dirty & /*permac*/ 2) qr1_changes.data = /*permac*/ ctx[1];
    			if (dirty & /*$page*/ 1) qr1_changes.uuid = /*$page*/ ctx[0].val.pageUuid;
    			qr1.$set(qr1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(qr0.$$.fragment, local);
    			transition_in(qr1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(qr0.$$.fragment, local);
    			transition_out(qr1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(qr0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(qr1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(63:2) <FB c=\\\"qrcodes\\\" around>",
    		ctx
    	});

    	return block;
    }

    // (68:2) {#if $ui <= 1}
    function create_if_block$6(ctx) {
    	let infotoc;
    	let current;
    	infotoc = new InfoTOC({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(infotoc.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(infotoc, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(infotoc.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(infotoc.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(infotoc, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(68:2) {#if $ui <= 1}",
    		ctx
    	});

    	return block;
    }

    // (43:0) <FB c="infobar" vert>
    function create_default_slot$3(ctx) {
    	let fb0;
    	let t0;
    	let t1;
    	let tabulate;
    	let t2;
    	let fb1;
    	let t3;
    	let if_block1_anchor;
    	let current;

    	fb0 = new FB({
    			props: {
    				center: true,
    				line: "s1",
    				c: "blacktag",
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block0 = (/*$state*/ ctx[4].pageperm || /*$state*/ ctx[4].verperm) && create_if_block_1$2(ctx);

    	tabulate = new Tabulate({
    			props: {
    				data: /*data*/ ctx[3],
    				line: "s1",
    				rows: 9,
    				usew: 10
    			},
    			$$inline: true
    		});

    	fb1 = new FB({
    			props: {
    				c: "qrcodes",
    				around: true,
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block1 = /*$ui*/ ctx[5] <= 1 && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			create_component(fb0.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			create_component(tabulate.$$.fragment);
    			t2 = space();
    			create_component(fb1.$$.fragment);
    			t3 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb0, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tabulate, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(fb1, target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fb0_changes = {};

    			if (dirty & /*$$scope, $state*/ 524304) {
    				fb0_changes.$$scope = { dirty, ctx };
    			}

    			fb0.$set(fb0_changes);

    			if (/*$state*/ ctx[4].pageperm || /*$state*/ ctx[4].verperm) {
    				if (if_block0) {
    					if (dirty & /*$state*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const tabulate_changes = {};
    			if (dirty & /*data*/ 8) tabulate_changes.data = /*data*/ ctx[3];
    			tabulate.$set(tabulate_changes);
    			const fb1_changes = {};

    			if (dirty & /*$$scope, permac, $page, vpermac*/ 524295) {
    				fb1_changes.$$scope = { dirty, ctx };
    			}

    			fb1.$set(fb1_changes);

    			if (/*$ui*/ ctx[5] <= 1) {
    				if (if_block1) {
    					if (dirty & /*$ui*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$6(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb0.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(tabulate.$$.fragment, local);
    			transition_in(fb1.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb0.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(tabulate.$$.fragment, local);
    			transition_out(fb1.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb0, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tabulate, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(fb1, detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(43:0) <FB c=\\\"infobar\\\" vert>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				c: "infobar",
    				vert: true,
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, $ui, permac, $page, vpermac, data, $state*/ 524351) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let data;
    	let $page;
    	let $pageinfo;
    	let $haspage;
    	let $gs;
    	let $state;
    	let $ui;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Infobar', slots, []);
    	const gs = getContext('gs');
    	validate_store(gs, 'gs');
    	component_subscribe($$self, gs, value => $$invalidate(16, $gs = value));
    	const haspage = getContext('haspage');
    	validate_store(haspage, 'haspage');
    	component_subscribe($$self, haspage, value => $$invalidate(15, $haspage = value));
    	const page = getContext('page');
    	validate_store(page, 'page');
    	component_subscribe($$self, page, value => $$invalidate(0, $page = value));
    	const pageinfo = getContext('pageinfo');
    	validate_store(pageinfo, 'pageinfo');
    	component_subscribe($$self, pageinfo, value => $$invalidate(14, $pageinfo = value));
    	const state = getContext('state');
    	validate_store(state, 'state');
    	component_subscribe($$self, state, value => $$invalidate(4, $state = value));
    	const ui = getContext('ui');
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, value => $$invalidate(5, $ui = value));
    	const crop = u => u.match(/.*?\/\/(.*)/)[1];
    	let perma, vperma, permac, vpermac;

    	const fmtdate = s => {
    		const d = new Date(s);
    		return date$1.format(d, 'MM-DD-YYYY');
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Infobar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		FB,
    		InfoTOC,
    		Tabulate,
    		QR,
    		getContext,
    		date: date$1,
    		gs,
    		haspage,
    		page,
    		pageinfo,
    		state,
    		ui,
    		crop,
    		perma,
    		vperma,
    		permac,
    		vpermac,
    		fmtdate,
    		data,
    		$page,
    		$pageinfo,
    		$haspage,
    		$gs,
    		$state,
    		$ui
    	});

    	$$self.$inject_state = $$props => {
    		if ('perma' in $$props) $$invalidate(12, perma = $$props.perma);
    		if ('vperma' in $$props) $$invalidate(13, vperma = $$props.vperma);
    		if ('permac' in $$props) $$invalidate(1, permac = $$props.permac);
    		if ('vpermac' in $$props) $$invalidate(2, vpermac = $$props.vpermac);
    		if ('data' in $$props) $$invalidate(3, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$haspage, $gs, $page, perma, vperma*/ 110593) {
    			if ($haspage) {
    				$$invalidate(12, perma = $gs.full($page.val.pageUuid));
    				$$invalidate(13, vperma = $gs.full($page.val.uuid));
    				$$invalidate(1, permac = crop(perma));
    				$$invalidate(2, vpermac = crop(vperma));
    			}
    		}

    		if ($$self.$$.dirty & /*$haspage, $pageinfo, $page*/ 49153) {
    			$$invalidate(3, data = $haspage
    			? {
    					time: $pageinfo.time,
    					words: $pageinfo.wc,
    					links: $pageinfo.links,
    					views: $page.val.views,
    					version: $page.val.vnum,
    					editor: $page.val.user.handle,
    					creator: $page.val.page.user.handle,
    					created: fmtdate($page.val.page.createdAt),
    					edited: fmtdate($page.val.createdAt)
    				}
    			: {});
    		}
    	};

    	return [
    		$page,
    		permac,
    		vpermac,
    		data,
    		$state,
    		$ui,
    		gs,
    		haspage,
    		page,
    		pageinfo,
    		state,
    		ui,
    		perma,
    		vperma,
    		$pageinfo,
    		$haspage,
    		$gs
    	];
    }

    class Infobar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Infobar",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    var lib$5 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
    /** Types of elements found in htmlparser2's DOM */
    var ElementType;
    (function (ElementType) {
        /** Type for the root element of a document */
        ElementType["Root"] = "root";
        /** Type for Text */
        ElementType["Text"] = "text";
        /** Type for <? ... ?> */
        ElementType["Directive"] = "directive";
        /** Type for <!-- ... --> */
        ElementType["Comment"] = "comment";
        /** Type for <script> tags */
        ElementType["Script"] = "script";
        /** Type for <style> tags */
        ElementType["Style"] = "style";
        /** Type for Any tag */
        ElementType["Tag"] = "tag";
        /** Type for <![CDATA[ ... ]]> */
        ElementType["CDATA"] = "cdata";
        /** Type for <!doctype ...> */
        ElementType["Doctype"] = "doctype";
    })(ElementType = exports.ElementType || (exports.ElementType = {}));
    /**
     * Tests whether an element is a tag or not.
     *
     * @param elem Element to test
     */
    function isTag(elem) {
        return (elem.type === ElementType.Tag ||
            elem.type === ElementType.Script ||
            elem.type === ElementType.Style);
    }
    exports.isTag = isTag;
    // Exports for backwards compatibility
    /** Type for the root element of a document */
    exports.Root = ElementType.Root;
    /** Type for Text */
    exports.Text = ElementType.Text;
    /** Type for <? ... ?> */
    exports.Directive = ElementType.Directive;
    /** Type for <!-- ... --> */
    exports.Comment = ElementType.Comment;
    /** Type for <script> tags */
    exports.Script = ElementType.Script;
    /** Type for <style> tags */
    exports.Style = ElementType.Style;
    /** Type for Any tag */
    exports.Tag = ElementType.Tag;
    /** Type for <![CDATA[ ... ]]> */
    exports.CDATA = ElementType.CDATA;
    /** Type for <!doctype ...> */
    exports.Doctype = ElementType.Doctype;
    });

    var require$$0$4 = lib$5;

    var node = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;

    var nodeTypes = new Map([
        [require$$0$4.ElementType.Tag, 1],
        [require$$0$4.ElementType.Script, 1],
        [require$$0$4.ElementType.Style, 1],
        [require$$0$4.ElementType.Directive, 1],
        [require$$0$4.ElementType.Text, 3],
        [require$$0$4.ElementType.CDATA, 4],
        [require$$0$4.ElementType.Comment, 8],
        [require$$0$4.ElementType.Root, 9],
    ]);
    /**
     * This object will be used as the prototype for Nodes when creating a
     * DOM-Level-1-compliant structure.
     */
    var Node = /** @class */ (function () {
        /**
         *
         * @param type The type of the node.
         */
        function Node(type) {
            this.type = type;
            /** Parent of the node */
            this.parent = null;
            /** Previous sibling */
            this.prev = null;
            /** Next sibling */
            this.next = null;
            /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
            this.startIndex = null;
            /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
            this.endIndex = null;
        }
        Object.defineProperty(Node.prototype, "nodeType", {
            // Read-only aliases
            /**
             * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible
             * node {@link type}.
             */
            get: function () {
                var _a;
                return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Node.prototype, "parentNode", {
            // Read-write aliases for properties
            /**
             * Same as {@link parent}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function () {
                return this.parent;
            },
            set: function (parent) {
                this.parent = parent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Node.prototype, "previousSibling", {
            /**
             * Same as {@link prev}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function () {
                return this.prev;
            },
            set: function (prev) {
                this.prev = prev;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Node.prototype, "nextSibling", {
            /**
             * Same as {@link next}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function () {
                return this.next;
            },
            set: function (next) {
                this.next = next;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Clone this node, and optionally its children.
         *
         * @param recursive Clone child nodes as well.
         * @returns A clone of the node.
         */
        Node.prototype.cloneNode = function (recursive) {
            if (recursive === void 0) { recursive = false; }
            return cloneNode(this, recursive);
        };
        return Node;
    }());
    exports.Node = Node;
    /**
     * A node that contains some data.
     */
    var DataNode = /** @class */ (function (_super) {
        __extends(DataNode, _super);
        /**
         * @param type The type of the node
         * @param data The content of the data node
         */
        function DataNode(type, data) {
            var _this = _super.call(this, type) || this;
            _this.data = data;
            return _this;
        }
        Object.defineProperty(DataNode.prototype, "nodeValue", {
            /**
             * Same as {@link data}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function () {
                return this.data;
            },
            set: function (data) {
                this.data = data;
            },
            enumerable: false,
            configurable: true
        });
        return DataNode;
    }(Node));
    exports.DataNode = DataNode;
    /**
     * Text within the document.
     */
    var Text = /** @class */ (function (_super) {
        __extends(Text, _super);
        function Text(data) {
            return _super.call(this, require$$0$4.ElementType.Text, data) || this;
        }
        return Text;
    }(DataNode));
    exports.Text = Text;
    /**
     * Comments within the document.
     */
    var Comment = /** @class */ (function (_super) {
        __extends(Comment, _super);
        function Comment(data) {
            return _super.call(this, require$$0$4.ElementType.Comment, data) || this;
        }
        return Comment;
    }(DataNode));
    exports.Comment = Comment;
    /**
     * Processing instructions, including doc types.
     */
    var ProcessingInstruction = /** @class */ (function (_super) {
        __extends(ProcessingInstruction, _super);
        function ProcessingInstruction(name, data) {
            var _this = _super.call(this, require$$0$4.ElementType.Directive, data) || this;
            _this.name = name;
            return _this;
        }
        return ProcessingInstruction;
    }(DataNode));
    exports.ProcessingInstruction = ProcessingInstruction;
    /**
     * A `Node` that can have children.
     */
    var NodeWithChildren = /** @class */ (function (_super) {
        __extends(NodeWithChildren, _super);
        /**
         * @param type Type of the node.
         * @param children Children of the node. Only certain node types can have children.
         */
        function NodeWithChildren(type, children) {
            var _this = _super.call(this, type) || this;
            _this.children = children;
            return _this;
        }
        Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
            // Aliases
            /** First child of the node. */
            get: function () {
                var _a;
                return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
            /** Last child of the node. */
            get: function () {
                return this.children.length > 0
                    ? this.children[this.children.length - 1]
                    : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
            /**
             * Same as {@link children}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function () {
                return this.children;
            },
            set: function (children) {
                this.children = children;
            },
            enumerable: false,
            configurable: true
        });
        return NodeWithChildren;
    }(Node));
    exports.NodeWithChildren = NodeWithChildren;
    /**
     * The root node of the document.
     */
    var Document = /** @class */ (function (_super) {
        __extends(Document, _super);
        function Document(children) {
            return _super.call(this, require$$0$4.ElementType.Root, children) || this;
        }
        return Document;
    }(NodeWithChildren));
    exports.Document = Document;
    /**
     * An element within the DOM.
     */
    var Element = /** @class */ (function (_super) {
        __extends(Element, _super);
        /**
         * @param name Name of the tag, eg. `div`, `span`.
         * @param attribs Object mapping attribute names to attribute values.
         * @param children Children of the node.
         */
        function Element(name, attribs, children, type) {
            if (children === void 0) { children = []; }
            if (type === void 0) { type = name === "script"
                ? require$$0$4.ElementType.Script
                : name === "style"
                    ? require$$0$4.ElementType.Style
                    : require$$0$4.ElementType.Tag; }
            var _this = _super.call(this, type, children) || this;
            _this.name = name;
            _this.attribs = attribs;
            return _this;
        }
        Object.defineProperty(Element.prototype, "tagName", {
            // DOM Level 1 aliases
            /**
             * Same as {@link name}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function () {
                return this.name;
            },
            set: function (name) {
                this.name = name;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Element.prototype, "attributes", {
            get: function () {
                var _this = this;
                return Object.keys(this.attribs).map(function (name) {
                    var _a, _b;
                    return ({
                        name: name,
                        value: _this.attribs[name],
                        namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                        prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
                    });
                });
            },
            enumerable: false,
            configurable: true
        });
        return Element;
    }(NodeWithChildren));
    exports.Element = Element;
    /**
     * @param node Node to check.
     * @returns `true` if the node is a `Element`, `false` otherwise.
     */
    function isTag(node) {
        return (0, require$$0$4.isTag)(node);
    }
    exports.isTag = isTag;
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `CDATA`, `false` otherwise.
     */
    function isCDATA(node) {
        return node.type === require$$0$4.ElementType.CDATA;
    }
    exports.isCDATA = isCDATA;
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `Text`, `false` otherwise.
     */
    function isText(node) {
        return node.type === require$$0$4.ElementType.Text;
    }
    exports.isText = isText;
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `Comment`, `false` otherwise.
     */
    function isComment(node) {
        return node.type === require$$0$4.ElementType.Comment;
    }
    exports.isComment = isComment;
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
     */
    function isDirective(node) {
        return node.type === require$$0$4.ElementType.Directive;
    }
    exports.isDirective = isDirective;
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
     */
    function isDocument(node) {
        return node.type === require$$0$4.ElementType.Root;
    }
    exports.isDocument = isDocument;
    /**
     * @param node Node to check.
     * @returns `true` if the node is a `NodeWithChildren` (has children), `false` otherwise.
     */
    function hasChildren(node) {
        return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports.hasChildren = hasChildren;
    /**
     * Clone a node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
    function cloneNode(node, recursive) {
        if (recursive === void 0) { recursive = false; }
        var result;
        if (isText(node)) {
            result = new Text(node.data);
        }
        else if (isComment(node)) {
            result = new Comment(node.data);
        }
        else if (isTag(node)) {
            var children = recursive ? cloneChildren(node.children) : [];
            var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
            children.forEach(function (child) { return (child.parent = clone_1); });
            if (node.namespace != null) {
                clone_1.namespace = node.namespace;
            }
            if (node["x-attribsNamespace"]) {
                clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
            }
            if (node["x-attribsPrefix"]) {
                clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
            }
            result = clone_1;
        }
        else if (isCDATA(node)) {
            var children = recursive ? cloneChildren(node.children) : [];
            var clone_2 = new NodeWithChildren(require$$0$4.ElementType.CDATA, children);
            children.forEach(function (child) { return (child.parent = clone_2); });
            result = clone_2;
        }
        else if (isDocument(node)) {
            var children = recursive ? cloneChildren(node.children) : [];
            var clone_3 = new Document(children);
            children.forEach(function (child) { return (child.parent = clone_3); });
            if (node["x-mode"]) {
                clone_3["x-mode"] = node["x-mode"];
            }
            result = clone_3;
        }
        else if (isDirective(node)) {
            var instruction = new ProcessingInstruction(node.name, node.data);
            if (node["x-name"] != null) {
                instruction["x-name"] = node["x-name"];
                instruction["x-publicId"] = node["x-publicId"];
                instruction["x-systemId"] = node["x-systemId"];
            }
            result = instruction;
        }
        else {
            throw new Error("Not implemented yet: ".concat(node.type));
        }
        result.startIndex = node.startIndex;
        result.endIndex = node.endIndex;
        if (node.sourceCodeLocation != null) {
            result.sourceCodeLocation = node.sourceCodeLocation;
        }
        return result;
    }
    exports.cloneNode = cloneNode;
    function cloneChildren(childs) {
        var children = childs.map(function (child) { return cloneNode(child, true); });
        for (var i = 1; i < children.length; i++) {
            children[i].prev = children[i - 1];
            children[i - 1].next = children[i];
        }
        return children;
    }
    });

    var node_1 = node;

    var lib$4 = createCommonjsModule(function (module, exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DomHandler = void 0;


    __exportStar(node_1, exports);
    var reWhitespace = /\s+/g;
    // Default options
    var defaultOpts = {
        normalizeWhitespace: false,
        withStartIndices: false,
        withEndIndices: false,
        xmlMode: false,
    };
    var DomHandler = /** @class */ (function () {
        /**
         * @param callback Called once parsing has completed.
         * @param options Settings for the handler.
         * @param elementCB Callback whenever a tag is closed.
         */
        function DomHandler(callback, options, elementCB) {
            /** The elements of the DOM */
            this.dom = [];
            /** The root element for the DOM */
            this.root = new node_1.Document(this.dom);
            /** Indicated whether parsing has been completed. */
            this.done = false;
            /** Stack of open tags. */
            this.tagStack = [this.root];
            /** A data node that is still being written to. */
            this.lastNode = null;
            /** Reference to the parser instance. Used for location information. */
            this.parser = null;
            // Make it possible to skip arguments, for backwards-compatibility
            if (typeof options === "function") {
                elementCB = options;
                options = defaultOpts;
            }
            if (typeof callback === "object") {
                options = callback;
                callback = undefined;
            }
            this.callback = callback !== null && callback !== void 0 ? callback : null;
            this.options = options !== null && options !== void 0 ? options : defaultOpts;
            this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler.prototype.onparserinit = function (parser) {
            this.parser = parser;
        };
        // Resets the handler back to starting state
        DomHandler.prototype.onreset = function () {
            this.dom = [];
            this.root = new node_1.Document(this.dom);
            this.done = false;
            this.tagStack = [this.root];
            this.lastNode = null;
            this.parser = null;
        };
        // Signals the handler that parsing is done
        DomHandler.prototype.onend = function () {
            if (this.done)
                return;
            this.done = true;
            this.parser = null;
            this.handleCallback(null);
        };
        DomHandler.prototype.onerror = function (error) {
            this.handleCallback(error);
        };
        DomHandler.prototype.onclosetag = function () {
            this.lastNode = null;
            var elem = this.tagStack.pop();
            if (this.options.withEndIndices) {
                elem.endIndex = this.parser.endIndex;
            }
            if (this.elementCB)
                this.elementCB(elem);
        };
        DomHandler.prototype.onopentag = function (name, attribs) {
            var type = this.options.xmlMode ? require$$0$4.ElementType.Tag : undefined;
            var element = new node_1.Element(name, attribs, undefined, type);
            this.addNode(element);
            this.tagStack.push(element);
        };
        DomHandler.prototype.ontext = function (data) {
            var normalizeWhitespace = this.options.normalizeWhitespace;
            var lastNode = this.lastNode;
            if (lastNode && lastNode.type === require$$0$4.ElementType.Text) {
                if (normalizeWhitespace) {
                    lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
                }
                else {
                    lastNode.data += data;
                }
                if (this.options.withEndIndices) {
                    lastNode.endIndex = this.parser.endIndex;
                }
            }
            else {
                if (normalizeWhitespace) {
                    data = data.replace(reWhitespace, " ");
                }
                var node = new node_1.Text(data);
                this.addNode(node);
                this.lastNode = node;
            }
        };
        DomHandler.prototype.oncomment = function (data) {
            if (this.lastNode && this.lastNode.type === require$$0$4.ElementType.Comment) {
                this.lastNode.data += data;
                return;
            }
            var node = new node_1.Comment(data);
            this.addNode(node);
            this.lastNode = node;
        };
        DomHandler.prototype.oncommentend = function () {
            this.lastNode = null;
        };
        DomHandler.prototype.oncdatastart = function () {
            var text = new node_1.Text("");
            var node = new node_1.NodeWithChildren(require$$0$4.ElementType.CDATA, [text]);
            this.addNode(node);
            text.parent = node;
            this.lastNode = text;
        };
        DomHandler.prototype.oncdataend = function () {
            this.lastNode = null;
        };
        DomHandler.prototype.onprocessinginstruction = function (name, data) {
            var node = new node_1.ProcessingInstruction(name, data);
            this.addNode(node);
        };
        DomHandler.prototype.handleCallback = function (error) {
            if (typeof this.callback === "function") {
                this.callback(error, this.dom);
            }
            else if (error) {
                throw error;
            }
        };
        DomHandler.prototype.addNode = function (node) {
            var parent = this.tagStack[this.tagStack.length - 1];
            var previousSibling = parent.children[parent.children.length - 1];
            if (this.options.withStartIndices) {
                node.startIndex = this.parser.startIndex;
            }
            if (this.options.withEndIndices) {
                node.endIndex = this.parser.endIndex;
            }
            parent.children.push(node);
            if (previousSibling) {
                node.prev = previousSibling;
                previousSibling.next = node;
            }
            node.parent = parent;
            this.lastNode = null;
        };
        return DomHandler;
    }());
    exports.DomHandler = DomHandler;
    exports.default = DomHandler;
    });

    var nearley = createCommonjsModule(function (module) {
    (function(root, factory) {
        if (module.exports) {
            module.exports = factory();
        } else {
            root.nearley = factory();
        }
    }(commonjsGlobal, function() {

        function Rule(name, symbols, postprocess) {
            this.id = ++Rule.highestId;
            this.name = name;
            this.symbols = symbols;        // a list of literal | regex class | nonterminal
            this.postprocess = postprocess;
            return this;
        }
        Rule.highestId = 0;

        Rule.prototype.toString = function(withCursorAt) {
            var symbolSequence = (typeof withCursorAt === "undefined")
                                 ? this.symbols.map(getSymbolShortDisplay).join(' ')
                                 : (   this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(' ')
                                     + " ● "
                                     + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(' ')     );
            return this.name + " → " + symbolSequence;
        };


        // a State is a rule at a position from a given starting point in the input stream (reference)
        function State(rule, dot, reference, wantedBy) {
            this.rule = rule;
            this.dot = dot;
            this.reference = reference;
            this.data = [];
            this.wantedBy = wantedBy;
            this.isComplete = this.dot === rule.symbols.length;
        }

        State.prototype.toString = function() {
            return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
        };

        State.prototype.nextState = function(child) {
            var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
            state.left = this;
            state.right = child;
            if (state.isComplete) {
                state.data = state.build();
                // Having right set here will prevent the right state and its children
                // form being garbage collected
                state.right = undefined;
            }
            return state;
        };

        State.prototype.build = function() {
            var children = [];
            var node = this;
            do {
                children.push(node.right.data);
                node = node.left;
            } while (node.left);
            children.reverse();
            return children;
        };

        State.prototype.finish = function() {
            if (this.rule.postprocess) {
                this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
            }
        };


        function Column(grammar, index) {
            this.grammar = grammar;
            this.index = index;
            this.states = [];
            this.wants = {}; // states indexed by the non-terminal they expect
            this.scannable = []; // list of states that expect a token
            this.completed = {}; // states that are nullable
        }


        Column.prototype.process = function(nextColumn) {
            var states = this.states;
            var wants = this.wants;
            var completed = this.completed;

            for (var w = 0; w < states.length; w++) { // nb. we push() during iteration
                var state = states[w];

                if (state.isComplete) {
                    state.finish();
                    if (state.data !== Parser.fail) {
                        // complete
                        var wantedBy = state.wantedBy;
                        for (var i = wantedBy.length; i--; ) { // this line is hot
                            var left = wantedBy[i];
                            this.complete(left, state);
                        }

                        // special-case nullables
                        if (state.reference === this.index) {
                            // make sure future predictors of this rule get completed.
                            var exp = state.rule.name;
                            (this.completed[exp] = this.completed[exp] || []).push(state);
                        }
                    }

                } else {
                    // queue scannable states
                    var exp = state.rule.symbols[state.dot];
                    if (typeof exp !== 'string') {
                        this.scannable.push(state);
                        continue;
                    }

                    // predict
                    if (wants[exp]) {
                        wants[exp].push(state);

                        if (completed.hasOwnProperty(exp)) {
                            var nulls = completed[exp];
                            for (var i = 0; i < nulls.length; i++) {
                                var right = nulls[i];
                                this.complete(state, right);
                            }
                        }
                    } else {
                        wants[exp] = [state];
                        this.predict(exp);
                    }
                }
            }
        };

        Column.prototype.predict = function(exp) {
            var rules = this.grammar.byName[exp] || [];

            for (var i = 0; i < rules.length; i++) {
                var r = rules[i];
                var wantedBy = this.wants[exp];
                var s = new State(r, 0, this.index, wantedBy);
                this.states.push(s);
            }
        };

        Column.prototype.complete = function(left, right) {
            var copy = left.nextState(right);
            this.states.push(copy);
        };


        function Grammar(rules, start) {
            this.rules = rules;
            this.start = start || this.rules[0].name;
            var byName = this.byName = {};
            this.rules.forEach(function(rule) {
                if (!byName.hasOwnProperty(rule.name)) {
                    byName[rule.name] = [];
                }
                byName[rule.name].push(rule);
            });
        }

        // So we can allow passing (rules, start) directly to Parser for backwards compatibility
        Grammar.fromCompiled = function(rules, start) {
            var lexer = rules.Lexer;
            if (rules.ParserStart) {
              start = rules.ParserStart;
              rules = rules.ParserRules;
            }
            var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });
            var g = new Grammar(rules, start);
            g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable
            return g;
        };


        function StreamLexer() {
          this.reset("");
        }

        StreamLexer.prototype.reset = function(data, state) {
            this.buffer = data;
            this.index = 0;
            this.line = state ? state.line : 1;
            this.lastLineBreak = state ? -state.col : 0;
        };

        StreamLexer.prototype.next = function() {
            if (this.index < this.buffer.length) {
                var ch = this.buffer[this.index++];
                if (ch === '\n') {
                  this.line += 1;
                  this.lastLineBreak = this.index;
                }
                return {value: ch};
            }
        };

        StreamLexer.prototype.save = function() {
          return {
            line: this.line,
            col: this.index - this.lastLineBreak,
          }
        };

        StreamLexer.prototype.formatError = function(token, message) {
            // nb. this gets called after consuming the offending token,
            // so the culprit is index-1
            var buffer = this.buffer;
            if (typeof buffer === 'string') {
                var lines = buffer
                    .split("\n")
                    .slice(
                        Math.max(0, this.line - 5), 
                        this.line
                    );

                buffer.indexOf('\n', this.index);
                var col = this.index - this.lastLineBreak;
                var lastLineDigits = String(this.line).length;
                message += " at line " + this.line + " col " + col + ":\n\n";
                message += lines
                    .map(function(line, i) {
                        return pad(this.line - lines.length + i + 1, lastLineDigits) + " " + line;
                    }, this)
                    .join("\n");
                message += "\n" + pad("", lastLineDigits + col) + "^\n";
                return message;
            } else {
                return message + " at index " + (this.index - 1);
            }

            function pad(n, length) {
                var s = String(n);
                return Array(length - s.length + 1).join(" ") + s;
            }
        };

        function Parser(rules, start, options) {
            if (rules instanceof Grammar) {
                var grammar = rules;
                var options = start;
            } else {
                var grammar = Grammar.fromCompiled(rules, start);
            }
            this.grammar = grammar;

            // Read options
            this.options = {
                keepHistory: false,
                lexer: grammar.lexer || new StreamLexer,
            };
            for (var key in (options || {})) {
                this.options[key] = options[key];
            }

            // Setup lexer
            this.lexer = this.options.lexer;
            this.lexerState = undefined;

            // Setup a table
            var column = new Column(grammar, 0);
            this.table = [column];

            // I could be expecting anything.
            column.wants[grammar.start] = [];
            column.predict(grammar.start);
            // TODO what if start rule is nullable?
            column.process();
            this.current = 0; // token index
        }

        // create a reserved token for indicating a parse fail
        Parser.fail = {};

        Parser.prototype.feed = function(chunk) {
            var lexer = this.lexer;
            lexer.reset(chunk, this.lexerState);

            var token;
            while (true) {
                try {
                    token = lexer.next();
                    if (!token) {
                        break;
                    }
                } catch (e) {
                    // Create the next column so that the error reporter
                    // can display the correctly predicted states.
                    var nextColumn = new Column(this.grammar, this.current + 1);
                    this.table.push(nextColumn);
                    var err = new Error(this.reportLexerError(e));
                    err.offset = this.current;
                    err.token = e.token;
                    throw err;
                }
                // We add new states to table[current+1]
                var column = this.table[this.current];

                // GC unused states
                if (!this.options.keepHistory) {
                    delete this.table[this.current - 1];
                }

                var n = this.current + 1;
                var nextColumn = new Column(this.grammar, n);
                this.table.push(nextColumn);

                // Advance all tokens that expect the symbol
                var literal = token.text !== undefined ? token.text : token.value;
                var value = lexer.constructor === StreamLexer ? token.value : token;
                var scannable = column.scannable;
                for (var w = scannable.length; w--; ) {
                    var state = scannable[w];
                    var expect = state.rule.symbols[state.dot];
                    // Try to consume the token
                    // either regex or literal
                    if (expect.test ? expect.test(value) :
                        expect.type ? expect.type === token.type
                                    : expect.literal === literal) {
                        // Add it
                        var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});
                        nextColumn.states.push(next);
                    }
                }

                // Next, for each of the rules, we either
                // (a) complete it, and try to see if the reference row expected that
                //     rule
                // (b) predict the next nonterminal it expects by adding that
                //     nonterminal's start state
                // To prevent duplication, we also keep track of rules we have already
                // added

                nextColumn.process();

                // If needed, throw an error:
                if (nextColumn.states.length === 0) {
                    // No states at all! This is not good.
                    var err = new Error(this.reportError(token));
                    err.offset = this.current;
                    err.token = token;
                    throw err;
                }

                // maybe save lexer state
                if (this.options.keepHistory) {
                  column.lexerState = lexer.save();
                }

                this.current++;
            }
            if (column) {
              this.lexerState = lexer.save();
            }

            // Incrementally keep track of results
            this.results = this.finish();

            // Allow chaining, for whatever it's worth
            return this;
        };

        Parser.prototype.reportLexerError = function(lexerError) {
            var tokenDisplay, lexerMessage;
            // Planning to add a token property to moo's thrown error
            // even on erroring tokens to be used in error display below
            var token = lexerError.token;
            if (token) {
                tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";
                lexerMessage = this.lexer.formatError(token, "Syntax error");
            } else {
                tokenDisplay = "input (lexer error)";
                lexerMessage = lexerError.message;
            }
            return this.reportErrorCommon(lexerMessage, tokenDisplay);
        };

        Parser.prototype.reportError = function(token) {
            var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== undefined ? token.value : token);
            var lexerMessage = this.lexer.formatError(token, "Syntax error");
            return this.reportErrorCommon(lexerMessage, tokenDisplay);
        };

        Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {
            var lines = [];
            lines.push(lexerMessage);
            var lastColumnIndex = this.table.length - 2;
            var lastColumn = this.table[lastColumnIndex];
            var expectantStates = lastColumn.states
                .filter(function(state) {
                    var nextSymbol = state.rule.symbols[state.dot];
                    return nextSymbol && typeof nextSymbol !== "string";
                });

            if (expectantStates.length === 0) {
                lines.push('Unexpected ' + tokenDisplay + '. I did not expect any more input. Here is the state of my parse table:\n');
                this.displayStateStack(lastColumn.states, lines);
            } else {
                lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\n');
                // Display a "state stack" for each expectant state
                // - which shows you how this state came to be, step by step.
                // If there is more than one derivation, we only display the first one.
                var stateStacks = expectantStates
                    .map(function(state) {
                        return this.buildFirstStateStack(state, []) || [state];
                    }, this);
                // Display each state that is expecting a terminal symbol next.
                stateStacks.forEach(function(stateStack) {
                    var state = stateStack[0];
                    var nextSymbol = state.rule.symbols[state.dot];
                    var symbolDisplay = this.getSymbolDisplay(nextSymbol);
                    lines.push('A ' + symbolDisplay + ' based on:');
                    this.displayStateStack(stateStack, lines);
                }, this);
            }
            lines.push("");
            return lines.join("\n");
        };
        
        Parser.prototype.displayStateStack = function(stateStack, lines) {
            var lastDisplay;
            var sameDisplayCount = 0;
            for (var j = 0; j < stateStack.length; j++) {
                var state = stateStack[j];
                var display = state.rule.toString(state.dot);
                if (display === lastDisplay) {
                    sameDisplayCount++;
                } else {
                    if (sameDisplayCount > 0) {
                        lines.push('    ^ ' + sameDisplayCount + ' more lines identical to this');
                    }
                    sameDisplayCount = 0;
                    lines.push('    ' + display);
                }
                lastDisplay = display;
            }
        };

        Parser.prototype.getSymbolDisplay = function(symbol) {
            return getSymbolLongDisplay(symbol);
        };

        /*
        Builds a the first state stack. You can think of a state stack as the call stack
        of the recursive-descent parser which the Nearley parse algorithm simulates.
        A state stack is represented as an array of state objects. Within a
        state stack, the first item of the array will be the starting
        state, with each successive item in the array going further back into history.

        This function needs to be given a starting state and an empty array representing
        the visited states, and it returns an single state stack.

        */
        Parser.prototype.buildFirstStateStack = function(state, visited) {
            if (visited.indexOf(state) !== -1) {
                // Found cycle, return null
                // to eliminate this path from the results, because
                // we don't know how to display it meaningfully
                return null;
            }
            if (state.wantedBy.length === 0) {
                return [state];
            }
            var prevState = state.wantedBy[0];
            var childVisited = [state].concat(visited);
            var childResult = this.buildFirstStateStack(prevState, childVisited);
            if (childResult === null) {
                return null;
            }
            return [state].concat(childResult);
        };

        Parser.prototype.save = function() {
            var column = this.table[this.current];
            column.lexerState = this.lexerState;
            return column;
        };

        Parser.prototype.restore = function(column) {
            var index = column.index;
            this.current = index;
            this.table[index] = column;
            this.table.splice(index + 1);
            this.lexerState = column.lexerState;

            // Incrementally keep track of results
            this.results = this.finish();
        };

        // nb. deprecated: use save/restore instead!
        Parser.prototype.rewind = function(index) {
            if (!this.options.keepHistory) {
                throw new Error('set option `keepHistory` to enable rewinding')
            }
            // nb. recall column (table) indicies fall between token indicies.
            //        col 0   --   token 0   --   col 1
            this.restore(this.table[index]);
        };

        Parser.prototype.finish = function() {
            // Return the possible parsings
            var considerations = [];
            var start = this.grammar.start;
            var column = this.table[this.table.length - 1];
            column.states.forEach(function (t) {
                if (t.rule.name === start
                        && t.dot === t.rule.symbols.length
                        && t.reference === 0
                        && t.data !== Parser.fail) {
                    considerations.push(t);
                }
            });
            return considerations.map(function(c) {return c.data; });
        };

        function getSymbolLongDisplay(symbol) {
            var type = typeof symbol;
            if (type === "string") {
                return symbol;
            } else if (type === "object") {
                if (symbol.literal) {
                    return JSON.stringify(symbol.literal);
                } else if (symbol instanceof RegExp) {
                    return 'character matching ' + symbol;
                } else if (symbol.type) {
                    return symbol.type + ' token';
                } else if (symbol.test) {
                    return 'token matching ' + String(symbol.test);
                } else {
                    throw new Error('Unknown symbol type: ' + symbol);
                }
            }
        }

        function getSymbolShortDisplay(symbol) {
            var type = typeof symbol;
            if (type === "string") {
                return symbol;
            } else if (type === "object") {
                if (symbol.literal) {
                    return JSON.stringify(symbol.literal);
                } else if (symbol instanceof RegExp) {
                    return symbol.toString();
                } else if (symbol.type) {
                    return '%' + symbol.type;
                } else if (symbol.test) {
                    return '<' + String(symbol.test) + '>';
                } else {
                    throw new Error('Unknown symbol type: ' + symbol);
                }
            }
        }

        return {
            Parser: Parser,
            Grammar: Grammar,
            Rule: Rule,
        };

    }));
    });

    var moo = createCommonjsModule(function (module) {
    (function(root, factory) {
      if (module.exports) {
        module.exports = factory();
      } else {
        root.moo = factory();
      }
    }(commonjsGlobal, function() {

      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var toString = Object.prototype.toString;
      var hasSticky = typeof new RegExp().sticky === 'boolean';

      /***************************************************************************/

      function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }
      function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }

      function reEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')
      }
      function reGroups(s) {
        var re = new RegExp('|' + s);
        return re.exec('').length - 1
      }
      function reCapture(s) {
        return '(' + s + ')'
      }
      function reUnion(regexps) {
        if (!regexps.length) return '(?!)'
        var source =  regexps.map(function(s) {
          return "(?:" + s + ")"
        }).join('|');
        return "(?:" + source + ")"
      }

      function regexpOrLiteral(obj) {
        if (typeof obj === 'string') {
          return '(?:' + reEscape(obj) + ')'

        } else if (isRegExp(obj)) {
          // TODO: consider /u support
          if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')
          if (obj.global) throw new Error('RegExp /g flag is implied')
          if (obj.sticky) throw new Error('RegExp /y flag is implied')
          if (obj.multiline) throw new Error('RegExp /m flag is implied')
          return obj.source

        } else {
          throw new Error('Not a pattern: ' + obj)
        }
      }

      function objectToRules(object) {
        var keys = Object.getOwnPropertyNames(object);
        var result = [];
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var thing = object[key];
          var rules = [].concat(thing);
          if (key === 'include') {
            for (var j = 0; j < rules.length; j++) {
              result.push({include: rules[j]});
            }
            continue
          }
          var match = [];
          rules.forEach(function(rule) {
            if (isObject(rule)) {
              if (match.length) result.push(ruleOptions(key, match));
              result.push(ruleOptions(key, rule));
              match = [];
            } else {
              match.push(rule);
            }
          });
          if (match.length) result.push(ruleOptions(key, match));
        }
        return result
      }

      function arrayToRules(array) {
        var result = [];
        for (var i = 0; i < array.length; i++) {
          var obj = array[i];
          if (obj.include) {
            var include = [].concat(obj.include);
            for (var j = 0; j < include.length; j++) {
              result.push({include: include[j]});
            }
            continue
          }
          if (!obj.type) {
            throw new Error('Rule has no type: ' + JSON.stringify(obj))
          }
          result.push(ruleOptions(obj.type, obj));
        }
        return result
      }

      function ruleOptions(type, obj) {
        if (!isObject(obj)) {
          obj = { match: obj };
        }
        if (obj.include) {
          throw new Error('Matching rules cannot also include states')
        }

        // nb. error and fallback imply lineBreaks
        var options = {
          defaultType: type,
          lineBreaks: !!obj.error || !!obj.fallback,
          pop: false,
          next: null,
          push: null,
          error: false,
          fallback: false,
          value: null,
          type: null,
          shouldThrow: false,
        };

        // Avoid Object.assign(), so we support IE9+
        for (var key in obj) {
          if (hasOwnProperty.call(obj, key)) {
            options[key] = obj[key];
          }
        }

        // type transform cannot be a string
        if (typeof options.type === 'string' && type !== options.type) {
          throw new Error("Type transform cannot be a string (type '" + options.type + "' for token '" + type + "')")
        }

        // convert to array
        var match = options.match;
        options.match = Array.isArray(match) ? match : match ? [match] : [];
        options.match.sort(function(a, b) {
          return isRegExp(a) && isRegExp(b) ? 0
               : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length
        });
        return options
      }

      function toRules(spec) {
        return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)
      }

      var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true});
      function compileRules(rules, hasStates) {
        var errorRule = null;
        var fast = Object.create(null);
        var fastAllowed = true;
        var unicodeFlag = null;
        var groups = [];
        var parts = [];

        // If there is a fallback rule, then disable fast matching
        for (var i = 0; i < rules.length; i++) {
          if (rules[i].fallback) {
            fastAllowed = false;
          }
        }

        for (var i = 0; i < rules.length; i++) {
          var options = rules[i];

          if (options.include) {
            // all valid inclusions are removed by states() preprocessor
            throw new Error('Inheritance is not allowed in stateless lexers')
          }

          if (options.error || options.fallback) {
            // errorRule can only be set once
            if (errorRule) {
              if (!options.fallback === !errorRule.fallback) {
                throw new Error("Multiple " + (options.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options.defaultType + "')")
              } else {
                throw new Error("fallback and error are mutually exclusive (for token '" + options.defaultType + "')")
              }
            }
            errorRule = options;
          }

          var match = options.match.slice();
          if (fastAllowed) {
            while (match.length && typeof match[0] === 'string' && match[0].length === 1) {
              var word = match.shift();
              fast[word.charCodeAt(0)] = options;
            }
          }

          // Warn about inappropriate state-switching options
          if (options.pop || options.push || options.next) {
            if (!hasStates) {
              throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options.defaultType + "')")
            }
            if (options.fallback) {
              throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options.defaultType + "')")
            }
          }

          // Only rules with a .match are included in the RegExp
          if (match.length === 0) {
            continue
          }
          fastAllowed = false;

          groups.push(options);

          // Check unicode flag is used everywhere or nowhere
          for (var j = 0; j < match.length; j++) {
            var obj = match[j];
            if (!isRegExp(obj)) {
              continue
            }

            if (unicodeFlag === null) {
              unicodeFlag = obj.unicode;
            } else if (unicodeFlag !== obj.unicode && options.fallback === false) {
              throw new Error('If one rule is /u then all must be')
            }
          }

          // convert to RegExp
          var pat = reUnion(match.map(regexpOrLiteral));

          // validate
          var regexp = new RegExp(pat);
          if (regexp.test("")) {
            throw new Error("RegExp matches empty string: " + regexp)
          }
          var groupCount = reGroups(pat);
          if (groupCount > 0) {
            throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: … ) instead")
          }

          // try and detect rules matching newlines
          if (!options.lineBreaks && regexp.test('\n')) {
            throw new Error('Rule should declare lineBreaks: ' + regexp)
          }

          // store regex
          parts.push(reCapture(pat));
        }


        // If there's no fallback rule, use the sticky flag so we only look for
        // matches at the current index.
        //
        // If we don't support the sticky flag, then fake it using an irrefutable
        // match (i.e. an empty pattern).
        var fallbackRule = errorRule && errorRule.fallback;
        var flags = hasSticky && !fallbackRule ? 'ym' : 'gm';
        var suffix = hasSticky || fallbackRule ? '' : '|';

        if (unicodeFlag === true) flags += "u";
        var combined = new RegExp(reUnion(parts) + suffix, flags);
        return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}
      }

      function compile(rules) {
        var result = compileRules(toRules(rules));
        return new Lexer({start: result}, 'start')
      }

      function checkStateGroup(g, name, map) {
        var state = g && (g.push || g.next);
        if (state && !map[state]) {
          throw new Error("Missing state '" + state + "' (in token '" + g.defaultType + "' of state '" + name + "')")
        }
        if (g && g.pop && +g.pop !== 1) {
          throw new Error("pop must be 1 (in token '" + g.defaultType + "' of state '" + name + "')")
        }
      }
      function compileStates(states, start) {
        var all = states.$all ? toRules(states.$all) : [];
        delete states.$all;

        var keys = Object.getOwnPropertyNames(states);
        if (!start) start = keys[0];

        var ruleMap = Object.create(null);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          ruleMap[key] = toRules(states[key]).concat(all);
        }
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var rules = ruleMap[key];
          var included = Object.create(null);
          for (var j = 0; j < rules.length; j++) {
            var rule = rules[j];
            if (!rule.include) continue
            var splice = [j, 1];
            if (rule.include !== key && !included[rule.include]) {
              included[rule.include] = true;
              var newRules = ruleMap[rule.include];
              if (!newRules) {
                throw new Error("Cannot include nonexistent state '" + rule.include + "' (in state '" + key + "')")
              }
              for (var k = 0; k < newRules.length; k++) {
                var newRule = newRules[k];
                if (rules.indexOf(newRule) !== -1) continue
                splice.push(newRule);
              }
            }
            rules.splice.apply(rules, splice);
            j--;
          }
        }

        var map = Object.create(null);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          map[key] = compileRules(ruleMap[key], true);
        }

        for (var i = 0; i < keys.length; i++) {
          var name = keys[i];
          var state = map[name];
          var groups = state.groups;
          for (var j = 0; j < groups.length; j++) {
            checkStateGroup(groups[j], name, map);
          }
          var fastKeys = Object.getOwnPropertyNames(state.fast);
          for (var j = 0; j < fastKeys.length; j++) {
            checkStateGroup(state.fast[fastKeys[j]], name, map);
          }
        }

        return new Lexer(map, start)
      }

      function keywordTransform(map) {
        var reverseMap = Object.create(null);
        var byLength = Object.create(null);
        var types = Object.getOwnPropertyNames(map);
        for (var i = 0; i < types.length; i++) {
          var tokenType = types[i];
          var item = map[tokenType];
          var keywordList = Array.isArray(item) ? item : [item];
          keywordList.forEach(function(keyword) {
            (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword);
            if (typeof keyword !== 'string') {
              throw new Error("keyword must be string (in keyword '" + tokenType + "')")
            }
            reverseMap[keyword] = tokenType;
          });
        }

        // fast string lookup
        // https://jsperf.com/string-lookups
        function str(x) { return JSON.stringify(x) }
        var source = '';
        source += 'switch (value.length) {\n';
        for (var length in byLength) {
          var keywords = byLength[length];
          source += 'case ' + length + ':\n';
          source += 'switch (value) {\n';
          keywords.forEach(function(keyword) {
            var tokenType = reverseMap[keyword];
            source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\n';
          });
          source += '}\n';
        }
        source += '}\n';
        return Function('value', source) // type
      }

      /***************************************************************************/

      var Lexer = function(states, state) {
        this.startState = state;
        this.states = states;
        this.buffer = '';
        this.stack = [];
        this.reset();
      };

      Lexer.prototype.reset = function(data, info) {
        this.buffer = data || '';
        this.index = 0;
        this.line = info ? info.line : 1;
        this.col = info ? info.col : 1;
        this.queuedToken = info ? info.queuedToken : null;
        this.queuedThrow = info ? info.queuedThrow : null;
        this.setState(info ? info.state : this.startState);
        this.stack = info && info.stack ? info.stack.slice() : [];
        return this
      };

      Lexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.col,
          state: this.state,
          stack: this.stack.slice(),
          queuedToken: this.queuedToken,
          queuedThrow: this.queuedThrow,
        }
      };

      Lexer.prototype.setState = function(state) {
        if (!state || this.state === state) return
        this.state = state;
        var info = this.states[state];
        this.groups = info.groups;
        this.error = info.error;
        this.re = info.regexp;
        this.fast = info.fast;
      };

      Lexer.prototype.popState = function() {
        this.setState(this.stack.pop());
      };

      Lexer.prototype.pushState = function(state) {
        this.stack.push(this.state);
        this.setState(state);
      };

      var eat = hasSticky ? function(re, buffer) { // assume re is /y
        return re.exec(buffer)
      } : function(re, buffer) { // assume re is /g
        var match = re.exec(buffer);
        // will always match, since we used the |(?:) trick
        if (match[0].length === 0) {
          return null
        }
        return match
      };

      Lexer.prototype._getGroup = function(match) {
        var groupCount = this.groups.length;
        for (var i = 0; i < groupCount; i++) {
          if (match[i + 1] !== undefined) {
            return this.groups[i]
          }
        }
        throw new Error('Cannot find token type for matched text')
      };

      function tokenToString() {
        return this.value
      }

      Lexer.prototype.next = function() {
        var index = this.index;

        // If a fallback token matched, we don't need to re-run the RegExp
        if (this.queuedGroup) {
          var token = this._token(this.queuedGroup, this.queuedText, index);
          this.queuedGroup = null;
          this.queuedText = "";
          return token
        }

        var buffer = this.buffer;
        if (index === buffer.length) {
          return // EOF
        }

        // Fast matching for single characters
        var group = this.fast[buffer.charCodeAt(index)];
        if (group) {
          return this._token(group, buffer.charAt(index), index)
        }

        // Execute RegExp
        var re = this.re;
        re.lastIndex = index;
        var match = eat(re, buffer);

        // Error tokens match the remaining buffer
        var error = this.error;
        if (match == null) {
          return this._token(error, buffer.slice(index, buffer.length), index)
        }

        var group = this._getGroup(match);
        var text = match[0];

        if (error.fallback && match.index !== index) {
          this.queuedGroup = group;
          this.queuedText = text;

          // Fallback tokens contain the unmatched portion of the buffer
          return this._token(error, buffer.slice(index, match.index), index)
        }

        return this._token(group, text, index)
      };

      Lexer.prototype._token = function(group, text, offset) {
        // count line breaks
        var lineBreaks = 0;
        if (group.lineBreaks) {
          var matchNL = /\n/g;
          var nl = 1;
          if (text === '\n') {
            lineBreaks = 1;
          } else {
            while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex; }
          }
        }

        var token = {
          type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,
          value: typeof group.value === 'function' ? group.value(text) : text,
          text: text,
          toString: tokenToString,
          offset: offset,
          lineBreaks: lineBreaks,
          line: this.line,
          col: this.col,
        };
        // nb. adding more props to token object will make V8 sad!

        var size = text.length;
        this.index += size;
        this.line += lineBreaks;
        if (lineBreaks !== 0) {
          this.col = size - nl + 1;
        } else {
          this.col += size;
        }

        // throw, if no rule with {error: true}
        if (group.shouldThrow) {
          throw new Error(this.formatError(token, "invalid syntax"))
        }

        if (group.pop) this.popState();
        else if (group.push) this.pushState(group.push);
        else if (group.next) this.setState(group.next);

        return token
      };

      if (typeof Symbol !== 'undefined' && Symbol.iterator) {
        var LexerIterator = function(lexer) {
          this.lexer = lexer;
        };

        LexerIterator.prototype.next = function() {
          var token = this.lexer.next();
          return {value: token, done: !token}
        };

        LexerIterator.prototype[Symbol.iterator] = function() {
          return this
        };

        Lexer.prototype[Symbol.iterator] = function() {
          return new LexerIterator(this)
        };
      }

      Lexer.prototype.formatError = function(token, message) {
        if (token == null) {
          // An undefined token indicates EOF
          var text = this.buffer.slice(this.index);
          var token = {
            text: text,
            offset: this.index,
            lineBreaks: text.indexOf('\n') === -1 ? 0 : 1,
            line: this.line,
            col: this.col,
          };
        }
        var start = Math.max(0, token.offset - token.col + 1);
        var eol = token.lineBreaks ? token.text.indexOf('\n') : token.text.length;
        var firstLine = this.buffer.substring(start, token.offset + eol);
        message += " at line " + token.line + " col " + token.col + ":\n\n";
        message += "  " + firstLine + "\n";
        message += "  " + Array(token.col).join(" ") + "^";
        return message
      };

      Lexer.prototype.clone = function() {
        return new Lexer(this.states, this.state)
      };

      Lexer.prototype.has = function(tokenType) {
        return true
      };


      return {
        compile: compile,
        states: compileStates,
        error: Object.freeze({error: true}),
        fallback: Object.freeze({fallback: true}),
        keywords: keywordTransform,
      }

    }));
    });

    function _interopNamespace$2(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var moo__namespace = /*#__PURE__*/_interopNamespace$2(moo);

    // Generated automatically by nearley, version 2.20.1
    // http://github.com/Hardmath123/nearley
    // Bypasses TS6133. Allow declared but unused functions.
    // @ts-ignore
    function id(d) { return d[0]; }
    const lexer = moo__namespace.compile({
        ws: { match: /[ \t\r\n\f]+/, lineBreaks: true },
        idn: { match: /[a-zA-Z_-][a-zA-Z0-9_-]*/ },
        hashToken: { match: /#[a-zA-Z0-9_-]+/, value: (s) => s.slice(1) },
        str1: { match: /'(?:\\['\\]|[^\n'\\])*'/, value: (s) => s.slice(1, -1) },
        str2: { match: /"(?:\\["\\]|[^\n"\\])*"/, value: (s) => s.slice(1, -1) },
        asterisk: '*',
        fullstop: '.',
        comma: ',',
        lbr: '[',
        rbr: ']',
        eq: '=',
        gt: '>',
        vbar: '|',
        plus: '+',
        tilde: '~',
        caret: '^',
        dollar: '$',
        //colon:      ':',
        //lpar:       '(',
        //rpar:       ')',
    });
    function firstTokenValue(tokens) {
        return tokens[0].value;
    }
    function second(tokens) {
        return tokens[1];
    }
    function sumSpec([a0, a1, a2], [b0, b1, b2]) {
        return [a0 + b0, a1 + b1, a2 + b2];
    }
    const grammar = {
        Lexer: lexer,
        ParserRules: [
            { "name": "main", "symbols": ["_", "listSelector", "_"], "postprocess": second },
            { "name": "mainNoList", "symbols": ["_", "complexSelector", "_"], "postprocess": second },
            { "name": "listSelector", "symbols": ["complexSelector"], "postprocess": ([next]) => ({ type: 'list', list: [next] }) },
            { "name": "listSelector", "symbols": ["listSelector", "_", (lexer.has("comma") ? { type: "comma" } : comma), "_", "complexSelector"], "postprocess": ([acc, , , , next]) => ({ type: 'list', list: [...acc.list, next] }) },
            { "name": "complexSelector", "symbols": ["compoundSelector"], "postprocess": id },
            { "name": "complexSelector", "symbols": ["complexSelector", "__", "compoundSelector"], "postprocess": ([left, , right]) => ({
                    type: 'compound',
                    list: [...right.list, { type: 'combinator', combinator: ' ', left: left, specificity: left.specificity }],
                    specificity: sumSpec(left.specificity, right.specificity)
                }) },
            { "name": "complexSelector", "symbols": ["complexSelector", "_", "combinator", "_", "compoundSelector"], "postprocess": ([left, , c, , right]) => ({
                    type: 'compound',
                    list: [...right.list, { type: 'combinator', combinator: c, left: left, specificity: left.specificity }],
                    specificity: sumSpec(left.specificity, right.specificity)
                }) },
            { "name": "combinator", "symbols": [(lexer.has("gt") ? { type: "gt" } : gt)], "postprocess": () => '>' },
            { "name": "combinator", "symbols": [(lexer.has("plus") ? { type: "plus" } : plus)], "postprocess": () => '+' },
            { "name": "combinator", "symbols": [(lexer.has("tilde") ? { type: "tilde" } : tilde)], "postprocess": () => '~' },
            { "name": "combinator", "symbols": [(lexer.has("vbar") ? { type: "vbar" } : vbar), (lexer.has("vbar") ? { type: "vbar" } : vbar)], "postprocess": () => '||' },
            { "name": "compoundSelector", "symbols": ["typeSelector"], "postprocess": ([next]) => ({
                    type: 'compound',
                    list: [next],
                    specificity: next.specificity
                }) },
            { "name": "compoundSelector", "symbols": ["subclassSelector"], "postprocess": ([next]) => ({
                    type: 'compound',
                    list: [next],
                    specificity: next.specificity
                }) },
            { "name": "compoundSelector", "symbols": ["compoundSelector", "subclassSelector"], "postprocess": ([acc, next]) => ({
                    type: 'compound',
                    list: [...acc.list, next],
                    specificity: sumSpec(acc.specificity, next.specificity)
                }) },
            { "name": "subclassSelector", "symbols": ["idSelector"], "postprocess": id },
            { "name": "subclassSelector", "symbols": ["classSelector"], "postprocess": id },
            { "name": "subclassSelector", "symbols": ["attrSelector"], "postprocess": id },
            { "name": "attrSelector", "symbols": ["attrPresenceSelector"], "postprocess": id },
            { "name": "attrSelector", "symbols": ["attrValueSelector"], "postprocess": id },
            { "name": "typeSelector", "symbols": ["tagSelector"], "postprocess": id },
            { "name": "typeSelector", "symbols": ["uniSelector"], "postprocess": id },
            { "name": "attrPresenceSelector", "symbols": [(lexer.has("lbr") ? { type: "lbr" } : lbr), "_", "wqname", "_", (lexer.has("rbr") ? { type: "rbr" } : rbr)], "postprocess": ([, , wqname]) => ({
                    type: 'attrPresence',
                    name: wqname.name,
                    namespace: wqname.namespace,
                    specificity: [0, 1, 0]
                })
            },
            { "name": "attrValueSelector", "symbols": [(lexer.has("lbr") ? { type: "lbr" } : lbr), "_", "wqname", "_", "attrMatcher", "_", "attrValue", "_", (lexer.has("rbr") ? { type: "rbr" } : rbr)], "postprocess": ([, , wqname, , matcher, , v]) => ({
                    type: 'attrValue',
                    name: wqname.name,
                    namespace: wqname.namespace,
                    matcher: matcher,
                    value: v.value,
                    modifier: v.modifier,
                    specificity: [0, 1, 0]
                })
            },
            { "name": "attrMatcher", "symbols": [(lexer.has("eq") ? { type: "eq" } : eq)], "postprocess": () => '=' },
            { "name": "attrMatcher", "symbols": [(lexer.has("tilde") ? { type: "tilde" } : tilde), (lexer.has("eq") ? { type: "eq" } : eq)], "postprocess": () => '~=' },
            { "name": "attrMatcher", "symbols": [(lexer.has("vbar") ? { type: "vbar" } : vbar), (lexer.has("eq") ? { type: "eq" } : eq)], "postprocess": () => '|=' },
            { "name": "attrMatcher", "symbols": [(lexer.has("caret") ? { type: "caret" } : caret), (lexer.has("eq") ? { type: "eq" } : eq)], "postprocess": () => '^=' },
            { "name": "attrMatcher", "symbols": [(lexer.has("dollar") ? { type: "dollar" } : dollar), (lexer.has("eq") ? { type: "eq" } : eq)], "postprocess": () => '$=' },
            { "name": "attrMatcher", "symbols": [(lexer.has("asterisk") ? { type: "asterisk" } : asterisk), (lexer.has("eq") ? { type: "eq" } : eq)], "postprocess": () => '*=' },
            { "name": "attrValue", "symbols": ["str"], "postprocess": ([v]) => ({ value: v, modifier: null }) },
            { "name": "attrValue", "symbols": ["idn"], "postprocess": ([v]) => ({ value: v, modifier: null }) },
            { "name": "attrValue", "symbols": ["str", "_", "attrModifier"], "postprocess": ([v, , mod]) => ({ value: v, modifier: mod }) },
            { "name": "attrValue", "symbols": ["idn", "__", "attrModifier"], "postprocess": ([v, , mod]) => ({ value: v, modifier: mod }) },
            { "name": "attrModifier", "symbols": [{ "literal": "i" }], "postprocess": () => 'i' },
            { "name": "attrModifier", "symbols": [{ "literal": "I" }], "postprocess": () => 'i' },
            { "name": "attrModifier", "symbols": [{ "literal": "s" }], "postprocess": () => 's' },
            { "name": "attrModifier", "symbols": [{ "literal": "S" }], "postprocess": () => 's' },
            { "name": "idSelector", "symbols": [(lexer.has("hashToken") ? { type: "hashToken" } : hashToken)], "postprocess": ([{ value: name }]) => ({ type: 'id', name: name, specificity: [1, 0, 0] }) },
            { "name": "classSelector", "symbols": [(lexer.has("fullstop") ? { type: "fullstop" } : fullstop), "idn"], "postprocess": ([, name]) => ({ type: 'class', name: name, specificity: [0, 1, 0] }) },
            { "name": "tagSelector", "symbols": ["wqname"], "postprocess": ([wqname]) => ({
                    type: 'tag',
                    name: wqname.name,
                    namespace: wqname.namespace,
                    specificity: [0, 0, 1]
                })
            },
            { "name": "uniSelector", "symbols": [(lexer.has("asterisk") ? { type: "asterisk" } : asterisk)], "postprocess": () => ({ type: 'universal', namespace: null, specificity: [0, 0, 0] }) },
            { "name": "uniSelector", "symbols": ["ns", (lexer.has("asterisk") ? { type: "asterisk" } : asterisk)], "postprocess": ([ns]) => ({ type: 'universal', namespace: ns, specificity: [0, 0, 0] }) },
            { "name": "wqname", "symbols": ["idn"], "postprocess": ([name]) => ({ name: name, namespace: null }) },
            { "name": "wqname", "symbols": ["ns", "idn"], "postprocess": ([ns, name]) => ({ name: name, namespace: ns }) },
            { "name": "ns", "symbols": [(lexer.has("vbar") ? { type: "vbar" } : vbar)], "postprocess": () => '' },
            { "name": "ns", "symbols": ["idn", (lexer.has("vbar") ? { type: "vbar" } : vbar)], "postprocess": id },
            { "name": "str", "symbols": [(lexer.has("str1") ? { type: "str1" } : str1)], "postprocess": firstTokenValue },
            { "name": "str", "symbols": [(lexer.has("str2") ? { type: "str2" } : str2)], "postprocess": firstTokenValue },
            { "name": "idn", "symbols": [(lexer.has("idn") ? { type: "idn" } : idn)], "postprocess": firstTokenValue },
            { "name": "_$ebnf$1", "symbols": [(lexer.has("ws") ? { type: "ws" } : ws)], "postprocess": id },
            { "name": "_$ebnf$1", "symbols": [], "postprocess": () => null },
            { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": () => null },
            { "name": "__", "symbols": [(lexer.has("ws") ? { type: "ws" } : ws)], "postprocess": () => null }
        ],
        ParserStart: "main",
    };

    var ast$1 = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    // Passing the start argument to a parser or grammar constructor
    // doesn't seem to work as expected.
    const compiledRulesNoList = { ...grammar, ParserStart: 'mainNoList' };
    /**
     * Parse a CSS selector string.
     *
     * This function supports comma-separated selector lists
     * and always returns an AST starting from a node of type `list`.
     *
     * @param str - CSS selector string (can contain commas).
     */
    function parse(str) {
        return _parse(grammar, str);
    }
    /**
     * Parse a CSS selector string.
     *
     * This function does not support comma-separated selector lists
     * and always returns an AST starting from a node of type `compound`.
     *
     * @param str - CSS selector string (no commas).
     */
    function parse1(str) {
        return _parse(compiledRulesNoList, str);
    }
    function _parse(compiledRules1, str) {
        const parser = new nearley.Parser(nearley.Grammar.fromCompiled(compiledRules1));
        parser.feed(str);
        if (parser.results.length === 0) {
            throw new Error('Failed to parse - input string might be incomplete.');
        }
        return parser.results[0];
    }
    /**
     * Convert a selector AST back to a string representation.
     *
     * Note: formatting is not preserved in the AST.
     *
     * @param selector - A selector AST object.
     */
    function serialize(selector) {
        if (!selector.type) {
            throw new Error('This is not an AST node.');
        }
        switch (selector.type) {
            case 'universal':
                return _serNs(selector.namespace) + '*';
            case 'tag':
                return _serNs(selector.namespace) + selector.name;
            case 'class':
                return '.' + selector.name;
            case 'id':
                return '#' + selector.name;
            case 'attrPresence':
                return `[${_serNs(selector.namespace)}${selector.name}]`;
            case 'attrValue':
                return `[${_serNs(selector.namespace)}${selector.name}${selector.matcher}${_serStr(selector.value)}${(selector.modifier ? selector.modifier : '')}]`;
            case 'combinator':
                return serialize(selector.left) + selector.combinator;
            case 'compound':
                return selector.list.reduce((acc, node) => {
                    if (node.type === 'combinator') {
                        return serialize(node) + acc;
                    }
                    else {
                        return acc + serialize(node);
                    }
                }, '');
            case 'list':
                return selector.list.map(serialize).join(',');
        }
    }
    function _serNs(ns) {
        return (ns || ns === '')
            ? ns + '|'
            : '';
    }
    function _serStr(str) {
        if (str.indexOf('"') === -1) {
            return `"${str}"`;
        }
        else if (str.indexOf("'") === -1) {
            return `'${str}'`;
        }
        else {
            return `"${str.replace('"', '\\"')}"`;
        }
    }
    /**
     * Modifies the given AST **in place** to have all internal arrays
     * in a stable order. Returns the AST.
     *
     * Intended for consitent processing and normalized `serialize()` output.
     *
     * @param selector - A selector AST object.
     */
    function normalize(selector) {
        if (!selector.type) {
            throw new Error('This is not an AST node.');
        }
        switch (selector.type) {
            case 'compound': {
                selector.list.forEach(normalize);
                selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));
                break;
            }
            case 'combinator': {
                normalize(selector.left);
                break;
            }
            case 'list': {
                selector.list.forEach(normalize);
                selector.list.sort((a, b) => (serialize(a) < serialize(b)) ? -1 : 1);
                break;
            }
        }
        return selector;
    }
    function _getSelectorPriority(selector) {
        switch (selector.type) {
            case 'universal':
                return [1];
            case 'tag':
                return [1];
            case 'id':
                return [2];
            case 'class':
                return [3, selector.name];
            case 'attrPresence':
                return [4, serialize(selector)];
            case 'attrValue':
                return [5, serialize(selector)];
            case 'combinator':
                return [15, serialize(selector)];
        }
    }
    /**
     * Compare selectors based on their specificity.
     *
     * Usable as a comparator for sorting.
     *
     * @param a - First selector.
     * @param b - Second selector.
     */
    function compareSelectors(a, b) {
        return _compareArrays(a.specificity, b.specificity);
    }
    /**
     * Compare specificity values without reducing them
     * as arbitrary base numbers.
     *
     * Usable as a comparator for sorting.
     *
     * @param a - First specificity value.
     * @param b - Second specificity value.
     */
    function compareSpecificity(a, b) {
        return _compareArrays(a, b);
    }
    function _compareArrays(a, b) {
        if (!Array.isArray(a) || !Array.isArray(b)) {
            throw new Error('Arguments must be arrays.');
        }
        const shorter = (a.length < b.length) ? a.length : b.length;
        for (let i = 0; i < shorter; i++) {
            if (a[i] === b[i]) {
                continue;
            }
            return (a[i] < b[i]) ? -1 : 1;
        }
        return a.length - b.length;
    }

    var Ast$1 = ast$1;
    var compareSelectors_1 = compareSelectors;
    var compareSpecificity_1 = compareSpecificity;
    var normalize_1 = normalize;
    var parse_1 = parse;
    var parse1_1 = parse1;
    var serialize_1 = serialize;

    var parseley = /*#__PURE__*/Object.defineProperty({
    	Ast: Ast$1,
    	compareSelectors: compareSelectors_1,
    	compareSpecificity: compareSpecificity_1,
    	normalize: normalize_1,
    	parse: parse_1,
    	parse1: parse1_1,
    	serialize: serialize_1
    }, '__esModule', {value: true});

    function _interopNamespace$1(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var parseley__namespace = /*#__PURE__*/_interopNamespace$1(parseley);

    var Ast = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    var Types = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * A {@link BuilderFunction} implementation.
     *
     * Produces a string representation of the tree
     * for testing and debug purposes.
     *
     * Only accepts `string` as the associated value type.
     * Map your input collection before creating a {@link DecisionTree}
     * if you want to use it with a different type -
     * the decision on how to stringify the value is up to you.
     *
     * @param nodes - nodes from the root level of the decision tree.
     * @returns the string representation of the tree.
     */
    const treeify = (nodes) => '▽\n' + treeifyArray(nodes, thinLines);
    const thinLines = [['├─', '│ '], ['└─', '  ']];
    const heavyLines = [['┠─', '┃ '], ['┖─', '  ']];
    const doubleLines = [['╟─', '║ '], ['╙─', '  ']];
    function treeifyArray(nodes, tpl = heavyLines) {
        return prefixItems(tpl, nodes.map(n => treeifyNode(n)));
    }
    function treeifyNode(node) {
        switch (node.type) {
            case 'terminal': {
                const vctr = node.valueContainer;
                return `◁ #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;
            }
            case 'tagName':
                return `◻ Tag name\n${treeifyArray(node.variants, doubleLines)}`;
            case 'attrValue':
                return `▣ Attr value: ${node.name}\n${treeifyArray(node.matchers, doubleLines)}`;
            case 'attrPresence':
                return `◨ Attr presence: ${node.name}\n${treeifyArray(node.cont)}`;
            case 'pushElement':
                return `◉ Push element: ${node.combinator}\n${treeifyArray(node.cont, thinLines)}`;
            case 'popElement':
                return `◌ Pop element\n${treeifyArray(node.cont, thinLines)}`;
            case 'variant':
                return `◇ = ${node.value}\n${treeifyArray(node.cont)}`;
            case 'matcher':
                return `◈ ${node.matcher} "${node.value}"${node.modifier || ''}\n${treeifyArray(node.cont)}`;
        }
    }
    function prefixItems(tpl, items) {
        return items
            .map((item, i, { length }) => prefixItem(tpl, item, i === length - 1))
            .join('\n');
    }
    function prefixItem(tpl, item, tail = true) {
        const tpl1 = tpl[tail ? 1 : 0];
        return tpl1[0] + item.split('\n').join('\n' + tpl1[1]);
    }

    var TreeifyBuilder = /*#__PURE__*/Object.freeze({
        __proto__: null,
        treeify: treeify
    });

    /**
     * CSS selectors decision tree.
     * Data structure that weaves similar selectors together
     * in order to minimize the number of checks required
     * to find the ones matching a given HTML element.
     *
     * Converted into a functioning implementation via plugins
     * tailored for specific DOM ASTs.
     *
     * @typeParam V - the type of values associated with selectors.
     */
    class DecisionTree {
        /**
         * Create new DecisionTree object.
         *
         * @param input - an array containing all selectors
         * paired with associated values.
         *
         * @typeParam V - the type of values associated with selectors.
         */
        constructor(input) {
            this.branches = weave(toAstTerminalPairs(input));
        }
        /**
         * Turn this decision tree into a usable form.
         *
         * @typeParam R - return type defined by the builder function.
         *
         * @param builder - the builder function.
         *
         * @returns the decision tree in a form ready for use.
         */
        build(builder) {
            return builder(this.branches);
        }
    }
    function toAstTerminalPairs(array) {
        const len = array.length;
        const results = new Array(len);
        for (let i = 0; i < len; i++) {
            const [selectorString, val] = array[i];
            const ast = preprocess(parseley__namespace.parse1(selectorString));
            results[i] = {
                ast: ast,
                terminal: {
                    type: 'terminal',
                    valueContainer: { index: i, value: val, specificity: ast.specificity }
                }
            };
        }
        return results;
    }
    function preprocess(ast) {
        reduceSelectorVariants(ast);
        parseley__namespace.normalize(ast);
        return ast;
    }
    function reduceSelectorVariants(ast) {
        const newList = [];
        ast.list.forEach(sel => {
            switch (sel.type) {
                case 'class':
                    newList.push({
                        matcher: '~=',
                        modifier: null,
                        name: 'class',
                        namespace: null,
                        specificity: sel.specificity,
                        type: 'attrValue',
                        value: sel.name,
                    });
                    break;
                case 'id':
                    newList.push({
                        matcher: '=',
                        modifier: null,
                        name: 'id',
                        namespace: null,
                        specificity: sel.specificity,
                        type: 'attrValue',
                        value: sel.name,
                    });
                    break;
                case 'combinator':
                    reduceSelectorVariants(sel.left);
                    newList.push(sel);
                    break;
                case 'universal':
                    // skip it
                    break;
                default:
                    newList.push(sel);
                    break;
            }
        });
        ast.list = newList;
    }
    function weave(items) {
        const branches = [];
        while (items.length) {
            const topKind = findTopKey(items, (sel) => true, getSelectorKind);
            const { matches, nonmatches, empty } = breakByKind(items, topKind);
            items = nonmatches;
            if (matches.length) {
                branches.push(branchOfKind(topKind, matches));
            }
            if (empty.length) {
                branches.push(...terminate(empty));
            }
        }
        return branches;
    }
    function terminate(items) {
        const results = [];
        for (const item of items) {
            const terminal = item.terminal;
            if (terminal.type === 'terminal') {
                results.push(terminal);
            }
            else { // popElement - lift contained terminals
                const { matches, rest } = partition(terminal.cont, (node) => node.type === 'terminal');
                matches.forEach((node) => results.push(node));
                if (rest.length) {
                    terminal.cont = rest;
                    results.push(terminal);
                }
            }
        }
        return results;
    }
    function breakByKind(items, selectedKind) {
        const matches = [];
        const nonmatches = [];
        const empty = [];
        for (const item of items) {
            const simpsels = item.ast.list;
            if (simpsels.length) {
                const isMatch = simpsels.some(node => getSelectorKind(node) === selectedKind);
                (isMatch ? matches : nonmatches).push(item);
            }
            else {
                empty.push(item);
            }
        }
        return { matches, nonmatches, empty };
    }
    function getSelectorKind(sel) {
        switch (sel.type) {
            case 'attrPresence':
                return `attrPresence ${sel.name}`;
            case 'attrValue':
                return `attrValue ${sel.name}`;
            case 'combinator':
                return `combinator ${sel.combinator}`;
            default:
                return sel.type;
        }
    }
    function branchOfKind(kind, items) {
        if (kind === 'tag') {
            return tagNameBranch(items);
        }
        if (kind.startsWith('attrValue ')) {
            return attrValueBranch(kind.substring(10), items);
        }
        if (kind.startsWith('attrPresence ')) {
            return attrPresenceBranch(kind.substring(13), items);
        }
        if (kind === 'combinator >') {
            return combinatorBranch('>', items);
        }
        if (kind === 'combinator +') {
            return combinatorBranch('+', items);
        }
        throw new Error(`Unsupported selector kind: ${kind}`);
    }
    function tagNameBranch(items) {
        const groups = spliceAndGroup(items, (x) => x.type === 'tag', (x) => x.name);
        const variants = Object.entries(groups).map(([name, group]) => ({
            type: 'variant',
            value: name,
            cont: weave(group.items)
        }));
        return {
            type: 'tagName',
            variants: variants
        };
    }
    function attrPresenceBranch(name, items) {
        for (const item of items) {
            spliceSimpleSelector(item, (x) => (x.type === 'attrPresence') && (x.name === name));
        }
        return {
            type: 'attrPresence',
            name: name,
            cont: weave(items)
        };
    }
    function attrValueBranch(name, items) {
        const groups = spliceAndGroup(items, (x) => (x.type === 'attrValue') && (x.name === name), (x) => `${x.matcher} ${x.modifier || ''} ${x.value}`);
        const matchers = [];
        for (const group of Object.values(groups)) {
            const sel = group.oneSimpleSelector;
            const predicate = getAttrPredicate(sel);
            const continuation = weave(group.items);
            matchers.push({
                type: 'matcher',
                matcher: sel.matcher,
                modifier: sel.modifier,
                value: sel.value,
                predicate: predicate,
                cont: continuation
            });
        }
        return {
            type: 'attrValue',
            name: name,
            matchers: matchers
        };
    }
    function getAttrPredicate(sel) {
        if (sel.modifier === 'i') {
            const expected = sel.value.toLowerCase();
            switch (sel.matcher) {
                case '=':
                    return (actual) => expected === actual.toLowerCase();
                case '~=':
                    return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
                case '^=':
                    return (actual) => actual.toLowerCase().startsWith(expected);
                case '$=':
                    return (actual) => actual.toLowerCase().endsWith(expected);
                case '*=':
                    return (actual) => actual.toLowerCase().includes(expected);
                case '|=':
                    return (actual) => {
                        const lower = actual.toLowerCase();
                        return (expected === lower) || (lower.startsWith(expected) && lower[expected.length] === '-');
                    };
            }
        }
        else {
            const expected = sel.value;
            switch (sel.matcher) {
                case '=':
                    return (actual) => expected === actual;
                case '~=':
                    return (actual) => actual.split(/[ \t]+/).includes(expected);
                case '^=':
                    return (actual) => actual.startsWith(expected);
                case '$=':
                    return (actual) => actual.endsWith(expected);
                case '*=':
                    return (actual) => actual.includes(expected);
                case '|=':
                    return (actual) => (expected === actual) || (actual.startsWith(expected) && actual[expected.length] === '-');
            }
        }
    }
    function combinatorBranch(combinator, items) {
        const groups = spliceAndGroup(items, (x) => (x.type === 'combinator') && (x.combinator === combinator), (x) => parseley__namespace.serialize(x.left));
        const leftItems = [];
        for (const group of Object.values(groups)) {
            const rightCont = weave(group.items);
            const leftAst = group.oneSimpleSelector.left;
            leftItems.push({
                ast: leftAst,
                terminal: { type: 'popElement', cont: rightCont }
            });
        }
        return {
            type: 'pushElement',
            combinator: combinator,
            cont: weave(leftItems)
        };
    }
    function spliceAndGroup(items, predicate, keyCallback) {
        const groups = {};
        while (items.length) {
            const bestKey = findTopKey(items, predicate, keyCallback);
            const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
            const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
            const { matches, rest } = partition1(items, hasBestKeyPredicate);
            let oneSimpleSelector = null;
            for (const item of matches) {
                const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
                if (!oneSimpleSelector) {
                    oneSimpleSelector = splicedNode;
                }
            }
            if (oneSimpleSelector == null) {
                throw new Error('No simple selector is found.');
            }
            groups[bestKey] = { oneSimpleSelector: oneSimpleSelector, items: matches };
            items = rest;
        }
        return groups;
    }
    function spliceSimpleSelector(item, predicate) {
        const simpsels = item.ast.list;
        const matches = new Array(simpsels.length);
        let firstIndex = -1;
        for (let i = simpsels.length; i-- > 0;) {
            if (predicate(simpsels[i])) {
                matches[i] = true;
                firstIndex = i;
            }
        }
        if (firstIndex == -1) {
            throw new Error(`Couldn't find the required simple selector.`);
        }
        const result = simpsels[firstIndex];
        item.ast.list = simpsels.filter((sel, i) => !matches[i]);
        return result;
    }
    function findTopKey(items, predicate, keyCallback) {
        const candidates = {};
        for (const item of items) {
            const candidates1 = {};
            for (const node of item.ast.list.filter(predicate)) {
                candidates1[keyCallback(node)] = true;
            }
            for (const key of Object.keys(candidates1)) {
                if (candidates[key]) {
                    candidates[key]++;
                }
                else {
                    candidates[key] = 1;
                }
            }
        }
        let topKind = '';
        let topCounter = 0;
        for (const entry of Object.entries(candidates)) {
            if (entry[1] > topCounter) {
                topKind = entry[0];
                topCounter = entry[1];
            }
        }
        return topKind;
    }
    function partition(src, predicate) {
        const matches = [];
        const rest = [];
        for (const x of src) {
            if (predicate(x)) {
                matches.push(x);
            }
            else {
                rest.push(x);
            }
        }
        return { matches, rest };
    }
    function partition1(src, predicate) {
        const matches = [];
        const rest = [];
        for (const x of src) {
            if (predicate(x)) {
                matches.push(x);
            }
            else {
                rest.push(x);
            }
        }
        return { matches, rest };
    }

    /**
     * Simple wrapper around the matcher function.
     * Recommended return type for builder plugins.
     *
     * @typeParam L - the type of HTML Element in the targeted DOM AST.
     * @typeParam V - the type of associated values.
     */
    class Picker {
        /**
         * Create new Picker object.
         *
         * @typeParam L - the type of HTML Element in the targeted DOM AST.
         * @typeParam V - the type of associated values.
         *
         * @param f - the function that matches an element
         * and returns all associated values.
         */
        constructor(f) {
            this.f = f;
        }
        /**
         * Run the selectors decision tree against one HTML Element
         * and return all matched associated values
         * along with selector specificities.
         *
         * Client code then decides how to further process them
         * (sort, filter, etc).
         *
         * @param el - an HTML Element.
         *
         * @returns all associated values along with
         * selector specificities for all matched selectors.
         */
        pickAll(el) {
            return this.f(el);
        }
        /**
         * Run the selectors decision tree against one HTML Element
         * and choose the value from the most specific mached selector.
         *
         * @param el - an HTML Element.
         *
         * @param preferFirst - option to define which value to choose
         * when there are multiple matches with equal specificity.
         *
         * @returns the value from the most specific mached selector
         * or `null` if nothing matched.
         */
        pick1(el, preferFirst = false) {
            const results = this.f(el);
            const len = results.length;
            if (len === 0) {
                return null;
            }
            if (len === 1) {
                return results[0].value;
            }
            const comparator = (preferFirst)
                ? comparatorPreferFirst
                : comparatorPreferLast;
            let result = results[0];
            for (let i = 1; i < len; i++) {
                const next = results[i];
                if (comparator(result, next)) {
                    result = next;
                }
            }
            return result.value;
        }
    }
    function comparatorPreferFirst(acc, next) {
        const diff = parseley.compareSpecificity(next.specificity, acc.specificity);
        return diff > 0 || (diff === 0 && next.index < acc.index);
    }
    function comparatorPreferLast(acc, next) {
        const diff = parseley.compareSpecificity(next.specificity, acc.specificity);
        return diff > 0 || (diff === 0 && next.index > acc.index);
    }

    var Ast_1 = Ast;
    var DecisionTree_1 = DecisionTree;
    var Picker_1 = Picker;
    var Treeify = TreeifyBuilder;
    var Types_1 = Types;

    var selderee = /*#__PURE__*/Object.defineProperty({
    	Ast: Ast_1,
    	DecisionTree: DecisionTree_1,
    	Picker: Picker_1,
    	Treeify: Treeify,
    	Types: Types_1
    }, '__esModule', {value: true});

    var domhandler_1 = lib$4;

    /**
     * A {@link BuilderFunction} implementation.
     *
     * Creates a function (in a {@link Picker} wrapper) that can run
     * the decision tree against `htmlparser2` `Element` nodes.
     *
     * @typeParam V - the type of values associated with selectors.
     *
     * @param nodes - nodes ({@link DecisionTreeNode})
     * from the root level of the decision tree.
     *
     * @returns a {@link Picker} object.
     */
    function hp2Builder$1(nodes) {
        return new selderee.Picker(handleArray(nodes));
    }
    // ==============================================
    function handleArray(nodes) {
        const matchers = nodes.map(handleNode);
        return (el, ...tail) => flatMap(matchers, m => m(el, ...tail));
    }
    function handleNode(node) {
        switch (node.type) {
            case 'terminal': {
                const result = [node.valueContainer];
                return (el, ...tail) => result;
            }
            case 'tagName':
                return handleTagName(node);
            case 'attrValue':
                return handleAttrValueName(node);
            case 'attrPresence':
                return handleAttrPresenceName(node);
            case 'pushElement':
                return handlePushElementNode(node);
            case 'popElement':
                return handlePopElementNode(node);
        }
    }
    function handleTagName(node) {
        const variants = {};
        for (const variant of node.variants) {
            variants[variant.value] = handleArray(variant.cont);
        }
        return (el, ...tail) => {
            const continuation = variants[el.name];
            return (continuation) ? continuation(el, ...tail) : [];
        };
    }
    function handleAttrPresenceName(node) {
        const attrName = node.name;
        const continuation = handleArray(node.cont);
        return (el, ...tail) => (Object.prototype.hasOwnProperty.call(el.attribs, attrName))
            ? continuation(el, ...tail)
            : [];
    }
    function handleAttrValueName(node) {
        const callbacks = [];
        for (const matcher of node.matchers) {
            const predicate = matcher.predicate;
            const continuation = handleArray(matcher.cont);
            callbacks.push((attr, el, ...tail) => (predicate(attr) ? continuation(el, ...tail) : []));
        }
        const attrName = node.name;
        return (el, ...tail) => {
            const attr = el.attribs[attrName];
            return (attr || attr === '')
                ? flatMap(callbacks, cb => cb(attr, el, ...tail))
                : [];
        };
    }
    function handlePushElementNode(node) {
        const continuation = handleArray(node.cont);
        const leftElementGetter = (node.combinator === '+')
            ? getPrecedingElement
            : getParentElement;
        return (el, ...tail) => {
            const next = leftElementGetter(el);
            if (next === null) {
                return [];
            }
            return continuation(next, el, ...tail);
        };
    }
    const getPrecedingElement = (el) => {
        const prev = el.prev;
        if (prev === null) {
            return null;
        }
        return (domhandler_1.isTag(prev)) ? prev : getPrecedingElement(prev);
    };
    const getParentElement = (el) => {
        const parent = el.parent;
        return (parent && domhandler_1.isTag(parent)) ? parent : null;
    };
    function handlePopElementNode(node) {
        const continuation = handleArray(node.cont);
        return (el, next, ...tail) => continuation(next, ...tail);
    }
    // Can be removed after transition to Node 12.
    function flatMap(items, mapper) {
        return [].concat(...amap(items, mapper));
    }
    function amap(items, mapper) {
        const len = items.length;
        const res = new Array(len);
        for (let i = 0; i < len; i++) {
            res[i] = mapper(items[i]);
        }
        return res;
    }

    var hp2Builder_2 = hp2Builder$1;

    var hp2Builder_1 = /*#__PURE__*/Object.defineProperty({
    	hp2Builder: hp2Builder_2
    }, '__esModule', {value: true});

    var isMergeableObject = function isMergeableObject(value) {
    	return isNonNullObject(value)
    		&& !isSpecial(value)
    };

    function isNonNullObject(value) {
    	return !!value && typeof value === 'object'
    }

    function isSpecial(value) {
    	var stringValue = Object.prototype.toString.call(value);

    	return stringValue === '[object RegExp]'
    		|| stringValue === '[object Date]'
    		|| isReactElement(value)
    }

    // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
    var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

    function isReactElement(value) {
    	return value.$$typeof === REACT_ELEMENT_TYPE
    }

    function emptyTarget(val) {
    	return Array.isArray(val) ? [] : {}
    }

    function cloneUnlessOtherwiseSpecified(value, options) {
    	return (options.clone !== false && options.isMergeableObject(value))
    		? deepmerge(emptyTarget(value), value, options)
    		: value
    }

    function defaultArrayMerge(target, source, options) {
    	return target.concat(source).map(function(element) {
    		return cloneUnlessOtherwiseSpecified(element, options)
    	})
    }

    function getMergeFunction(key, options) {
    	if (!options.customMerge) {
    		return deepmerge
    	}
    	var customMerge = options.customMerge(key);
    	return typeof customMerge === 'function' ? customMerge : deepmerge
    }

    function getEnumerableOwnPropertySymbols(target) {
    	return Object.getOwnPropertySymbols
    		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
    			return target.propertyIsEnumerable(symbol)
    		})
    		: []
    }

    function getKeys(target) {
    	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
    }

    function propertyIsOnObject(object, property) {
    	try {
    		return property in object
    	} catch(_) {
    		return false
    	}
    }

    // Protects from prototype poisoning and unexpected merging up the prototype chain.
    function propertyIsUnsafe(target, key) {
    	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
    		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
    			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
    }

    function mergeObject(target, source, options) {
    	var destination = {};
    	if (options.isMergeableObject(target)) {
    		getKeys(target).forEach(function(key) {
    			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    		});
    	}
    	getKeys(source).forEach(function(key) {
    		if (propertyIsUnsafe(target, key)) {
    			return
    		}

    		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
    			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    		} else {
    			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    		}
    	});
    	return destination
    }

    function deepmerge(target, source, options) {
    	options = options || {};
    	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    	// implementations can use it. The caller may not replace it.
    	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

    	var sourceIsArray = Array.isArray(source);
    	var targetIsArray = Array.isArray(target);
    	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

    	if (!sourceAndTargetTypesMatch) {
    		return cloneUnlessOtherwiseSpecified(source, options)
    	} else if (sourceIsArray) {
    		return options.arrayMerge(target, source, options)
    	} else {
    		return mergeObject(target, source, options)
    	}
    }

    deepmerge.all = function deepmergeAll(array, options) {
    	if (!Array.isArray(array)) {
    		throw new Error('first argument should be an array')
    	}

    	return array.reduce(function(prev, next) {
    		return deepmerge(prev, next, options)
    	}, {})
    };

    var deepmerge_1 = deepmerge;

    var cjs = deepmerge_1;

    /*! https://mths.be/he v1.2.0 by @mathias | MIT license */

    var he = createCommonjsModule(function (module, exports) {
    (function(root) {

    	// Detect free variables `exports`.
    	var freeExports = exports;

    	// Detect free variable `module`.
    	var freeModule = module &&
    		module.exports == freeExports && module;

    	// Detect free variable `global`, from Node.js or Browserified code,
    	// and use it as `root`.
    	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;
    	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
    		root = freeGlobal;
    	}

    	/*--------------------------------------------------------------------------*/

    	// All astral symbols.
    	var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    	// All ASCII symbols (not just printable ASCII) except those listed in the
    	// first column of the overrides table.
    	// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides
    	var regexAsciiWhitelist = /[\x01-\x7F]/g;
    	// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or
    	// code points listed in the first column of the overrides table on
    	// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.
    	var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;

    	var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
    	var encodeMap = {'\xAD':'shy','\u200C':'zwnj','\u200D':'zwj','\u200E':'lrm','\u2063':'ic','\u2062':'it','\u2061':'af','\u200F':'rlm','\u200B':'ZeroWidthSpace','\u2060':'NoBreak','\u0311':'DownBreve','\u20DB':'tdot','\u20DC':'DotDot','\t':'Tab','\n':'NewLine','\u2008':'puncsp','\u205F':'MediumSpace','\u2009':'thinsp','\u200A':'hairsp','\u2004':'emsp13','\u2002':'ensp','\u2005':'emsp14','\u2003':'emsp','\u2007':'numsp','\xA0':'nbsp','\u205F\u200A':'ThickSpace','\u203E':'oline','_':'lowbar','\u2010':'dash','\u2013':'ndash','\u2014':'mdash','\u2015':'horbar',',':'comma',';':'semi','\u204F':'bsemi',':':'colon','\u2A74':'Colone','!':'excl','\xA1':'iexcl','?':'quest','\xBF':'iquest','.':'period','\u2025':'nldr','\u2026':'mldr','\xB7':'middot','\'':'apos','\u2018':'lsquo','\u2019':'rsquo','\u201A':'sbquo','\u2039':'lsaquo','\u203A':'rsaquo','"':'quot','\u201C':'ldquo','\u201D':'rdquo','\u201E':'bdquo','\xAB':'laquo','\xBB':'raquo','(':'lpar',')':'rpar','[':'lsqb',']':'rsqb','{':'lcub','}':'rcub','\u2308':'lceil','\u2309':'rceil','\u230A':'lfloor','\u230B':'rfloor','\u2985':'lopar','\u2986':'ropar','\u298B':'lbrke','\u298C':'rbrke','\u298D':'lbrkslu','\u298E':'rbrksld','\u298F':'lbrksld','\u2990':'rbrkslu','\u2991':'langd','\u2992':'rangd','\u2993':'lparlt','\u2994':'rpargt','\u2995':'gtlPar','\u2996':'ltrPar','\u27E6':'lobrk','\u27E7':'robrk','\u27E8':'lang','\u27E9':'rang','\u27EA':'Lang','\u27EB':'Rang','\u27EC':'loang','\u27ED':'roang','\u2772':'lbbrk','\u2773':'rbbrk','\u2016':'Vert','\xA7':'sect','\xB6':'para','@':'commat','*':'ast','/':'sol','undefined':null,'&':'amp','#':'num','%':'percnt','\u2030':'permil','\u2031':'pertenk','\u2020':'dagger','\u2021':'Dagger','\u2022':'bull','\u2043':'hybull','\u2032':'prime','\u2033':'Prime','\u2034':'tprime','\u2057':'qprime','\u2035':'bprime','\u2041':'caret','`':'grave','\xB4':'acute','\u02DC':'tilde','^':'Hat','\xAF':'macr','\u02D8':'breve','\u02D9':'dot','\xA8':'die','\u02DA':'ring','\u02DD':'dblac','\xB8':'cedil','\u02DB':'ogon','\u02C6':'circ','\u02C7':'caron','\xB0':'deg','\xA9':'copy','\xAE':'reg','\u2117':'copysr','\u2118':'wp','\u211E':'rx','\u2127':'mho','\u2129':'iiota','\u2190':'larr','\u219A':'nlarr','\u2192':'rarr','\u219B':'nrarr','\u2191':'uarr','\u2193':'darr','\u2194':'harr','\u21AE':'nharr','\u2195':'varr','\u2196':'nwarr','\u2197':'nearr','\u2198':'searr','\u2199':'swarr','\u219D':'rarrw','\u219D\u0338':'nrarrw','\u219E':'Larr','\u219F':'Uarr','\u21A0':'Rarr','\u21A1':'Darr','\u21A2':'larrtl','\u21A3':'rarrtl','\u21A4':'mapstoleft','\u21A5':'mapstoup','\u21A6':'map','\u21A7':'mapstodown','\u21A9':'larrhk','\u21AA':'rarrhk','\u21AB':'larrlp','\u21AC':'rarrlp','\u21AD':'harrw','\u21B0':'lsh','\u21B1':'rsh','\u21B2':'ldsh','\u21B3':'rdsh','\u21B5':'crarr','\u21B6':'cularr','\u21B7':'curarr','\u21BA':'olarr','\u21BB':'orarr','\u21BC':'lharu','\u21BD':'lhard','\u21BE':'uharr','\u21BF':'uharl','\u21C0':'rharu','\u21C1':'rhard','\u21C2':'dharr','\u21C3':'dharl','\u21C4':'rlarr','\u21C5':'udarr','\u21C6':'lrarr','\u21C7':'llarr','\u21C8':'uuarr','\u21C9':'rrarr','\u21CA':'ddarr','\u21CB':'lrhar','\u21CC':'rlhar','\u21D0':'lArr','\u21CD':'nlArr','\u21D1':'uArr','\u21D2':'rArr','\u21CF':'nrArr','\u21D3':'dArr','\u21D4':'iff','\u21CE':'nhArr','\u21D5':'vArr','\u21D6':'nwArr','\u21D7':'neArr','\u21D8':'seArr','\u21D9':'swArr','\u21DA':'lAarr','\u21DB':'rAarr','\u21DD':'zigrarr','\u21E4':'larrb','\u21E5':'rarrb','\u21F5':'duarr','\u21FD':'loarr','\u21FE':'roarr','\u21FF':'hoarr','\u2200':'forall','\u2201':'comp','\u2202':'part','\u2202\u0338':'npart','\u2203':'exist','\u2204':'nexist','\u2205':'empty','\u2207':'Del','\u2208':'in','\u2209':'notin','\u220B':'ni','\u220C':'notni','\u03F6':'bepsi','\u220F':'prod','\u2210':'coprod','\u2211':'sum','+':'plus','\xB1':'pm','\xF7':'div','\xD7':'times','<':'lt','\u226E':'nlt','<\u20D2':'nvlt','=':'equals','\u2260':'ne','=\u20E5':'bne','\u2A75':'Equal','>':'gt','\u226F':'ngt','>\u20D2':'nvgt','\xAC':'not','|':'vert','\xA6':'brvbar','\u2212':'minus','\u2213':'mp','\u2214':'plusdo','\u2044':'frasl','\u2216':'setmn','\u2217':'lowast','\u2218':'compfn','\u221A':'Sqrt','\u221D':'prop','\u221E':'infin','\u221F':'angrt','\u2220':'ang','\u2220\u20D2':'nang','\u2221':'angmsd','\u2222':'angsph','\u2223':'mid','\u2224':'nmid','\u2225':'par','\u2226':'npar','\u2227':'and','\u2228':'or','\u2229':'cap','\u2229\uFE00':'caps','\u222A':'cup','\u222A\uFE00':'cups','\u222B':'int','\u222C':'Int','\u222D':'tint','\u2A0C':'qint','\u222E':'oint','\u222F':'Conint','\u2230':'Cconint','\u2231':'cwint','\u2232':'cwconint','\u2233':'awconint','\u2234':'there4','\u2235':'becaus','\u2236':'ratio','\u2237':'Colon','\u2238':'minusd','\u223A':'mDDot','\u223B':'homtht','\u223C':'sim','\u2241':'nsim','\u223C\u20D2':'nvsim','\u223D':'bsim','\u223D\u0331':'race','\u223E':'ac','\u223E\u0333':'acE','\u223F':'acd','\u2240':'wr','\u2242':'esim','\u2242\u0338':'nesim','\u2243':'sime','\u2244':'nsime','\u2245':'cong','\u2247':'ncong','\u2246':'simne','\u2248':'ap','\u2249':'nap','\u224A':'ape','\u224B':'apid','\u224B\u0338':'napid','\u224C':'bcong','\u224D':'CupCap','\u226D':'NotCupCap','\u224D\u20D2':'nvap','\u224E':'bump','\u224E\u0338':'nbump','\u224F':'bumpe','\u224F\u0338':'nbumpe','\u2250':'doteq','\u2250\u0338':'nedot','\u2251':'eDot','\u2252':'efDot','\u2253':'erDot','\u2254':'colone','\u2255':'ecolon','\u2256':'ecir','\u2257':'cire','\u2259':'wedgeq','\u225A':'veeeq','\u225C':'trie','\u225F':'equest','\u2261':'equiv','\u2262':'nequiv','\u2261\u20E5':'bnequiv','\u2264':'le','\u2270':'nle','\u2264\u20D2':'nvle','\u2265':'ge','\u2271':'nge','\u2265\u20D2':'nvge','\u2266':'lE','\u2266\u0338':'nlE','\u2267':'gE','\u2267\u0338':'ngE','\u2268\uFE00':'lvnE','\u2268':'lnE','\u2269':'gnE','\u2269\uFE00':'gvnE','\u226A':'ll','\u226A\u0338':'nLtv','\u226A\u20D2':'nLt','\u226B':'gg','\u226B\u0338':'nGtv','\u226B\u20D2':'nGt','\u226C':'twixt','\u2272':'lsim','\u2274':'nlsim','\u2273':'gsim','\u2275':'ngsim','\u2276':'lg','\u2278':'ntlg','\u2277':'gl','\u2279':'ntgl','\u227A':'pr','\u2280':'npr','\u227B':'sc','\u2281':'nsc','\u227C':'prcue','\u22E0':'nprcue','\u227D':'sccue','\u22E1':'nsccue','\u227E':'prsim','\u227F':'scsim','\u227F\u0338':'NotSucceedsTilde','\u2282':'sub','\u2284':'nsub','\u2282\u20D2':'vnsub','\u2283':'sup','\u2285':'nsup','\u2283\u20D2':'vnsup','\u2286':'sube','\u2288':'nsube','\u2287':'supe','\u2289':'nsupe','\u228A\uFE00':'vsubne','\u228A':'subne','\u228B\uFE00':'vsupne','\u228B':'supne','\u228D':'cupdot','\u228E':'uplus','\u228F':'sqsub','\u228F\u0338':'NotSquareSubset','\u2290':'sqsup','\u2290\u0338':'NotSquareSuperset','\u2291':'sqsube','\u22E2':'nsqsube','\u2292':'sqsupe','\u22E3':'nsqsupe','\u2293':'sqcap','\u2293\uFE00':'sqcaps','\u2294':'sqcup','\u2294\uFE00':'sqcups','\u2295':'oplus','\u2296':'ominus','\u2297':'otimes','\u2298':'osol','\u2299':'odot','\u229A':'ocir','\u229B':'oast','\u229D':'odash','\u229E':'plusb','\u229F':'minusb','\u22A0':'timesb','\u22A1':'sdotb','\u22A2':'vdash','\u22AC':'nvdash','\u22A3':'dashv','\u22A4':'top','\u22A5':'bot','\u22A7':'models','\u22A8':'vDash','\u22AD':'nvDash','\u22A9':'Vdash','\u22AE':'nVdash','\u22AA':'Vvdash','\u22AB':'VDash','\u22AF':'nVDash','\u22B0':'prurel','\u22B2':'vltri','\u22EA':'nltri','\u22B3':'vrtri','\u22EB':'nrtri','\u22B4':'ltrie','\u22EC':'nltrie','\u22B4\u20D2':'nvltrie','\u22B5':'rtrie','\u22ED':'nrtrie','\u22B5\u20D2':'nvrtrie','\u22B6':'origof','\u22B7':'imof','\u22B8':'mumap','\u22B9':'hercon','\u22BA':'intcal','\u22BB':'veebar','\u22BD':'barvee','\u22BE':'angrtvb','\u22BF':'lrtri','\u22C0':'Wedge','\u22C1':'Vee','\u22C2':'xcap','\u22C3':'xcup','\u22C4':'diam','\u22C5':'sdot','\u22C6':'Star','\u22C7':'divonx','\u22C8':'bowtie','\u22C9':'ltimes','\u22CA':'rtimes','\u22CB':'lthree','\u22CC':'rthree','\u22CD':'bsime','\u22CE':'cuvee','\u22CF':'cuwed','\u22D0':'Sub','\u22D1':'Sup','\u22D2':'Cap','\u22D3':'Cup','\u22D4':'fork','\u22D5':'epar','\u22D6':'ltdot','\u22D7':'gtdot','\u22D8':'Ll','\u22D8\u0338':'nLl','\u22D9':'Gg','\u22D9\u0338':'nGg','\u22DA\uFE00':'lesg','\u22DA':'leg','\u22DB':'gel','\u22DB\uFE00':'gesl','\u22DE':'cuepr','\u22DF':'cuesc','\u22E6':'lnsim','\u22E7':'gnsim','\u22E8':'prnsim','\u22E9':'scnsim','\u22EE':'vellip','\u22EF':'ctdot','\u22F0':'utdot','\u22F1':'dtdot','\u22F2':'disin','\u22F3':'isinsv','\u22F4':'isins','\u22F5':'isindot','\u22F5\u0338':'notindot','\u22F6':'notinvc','\u22F7':'notinvb','\u22F9':'isinE','\u22F9\u0338':'notinE','\u22FA':'nisd','\u22FB':'xnis','\u22FC':'nis','\u22FD':'notnivc','\u22FE':'notnivb','\u2305':'barwed','\u2306':'Barwed','\u230C':'drcrop','\u230D':'dlcrop','\u230E':'urcrop','\u230F':'ulcrop','\u2310':'bnot','\u2312':'profline','\u2313':'profsurf','\u2315':'telrec','\u2316':'target','\u231C':'ulcorn','\u231D':'urcorn','\u231E':'dlcorn','\u231F':'drcorn','\u2322':'frown','\u2323':'smile','\u232D':'cylcty','\u232E':'profalar','\u2336':'topbot','\u233D':'ovbar','\u233F':'solbar','\u237C':'angzarr','\u23B0':'lmoust','\u23B1':'rmoust','\u23B4':'tbrk','\u23B5':'bbrk','\u23B6':'bbrktbrk','\u23DC':'OverParenthesis','\u23DD':'UnderParenthesis','\u23DE':'OverBrace','\u23DF':'UnderBrace','\u23E2':'trpezium','\u23E7':'elinters','\u2423':'blank','\u2500':'boxh','\u2502':'boxv','\u250C':'boxdr','\u2510':'boxdl','\u2514':'boxur','\u2518':'boxul','\u251C':'boxvr','\u2524':'boxvl','\u252C':'boxhd','\u2534':'boxhu','\u253C':'boxvh','\u2550':'boxH','\u2551':'boxV','\u2552':'boxdR','\u2553':'boxDr','\u2554':'boxDR','\u2555':'boxdL','\u2556':'boxDl','\u2557':'boxDL','\u2558':'boxuR','\u2559':'boxUr','\u255A':'boxUR','\u255B':'boxuL','\u255C':'boxUl','\u255D':'boxUL','\u255E':'boxvR','\u255F':'boxVr','\u2560':'boxVR','\u2561':'boxvL','\u2562':'boxVl','\u2563':'boxVL','\u2564':'boxHd','\u2565':'boxhD','\u2566':'boxHD','\u2567':'boxHu','\u2568':'boxhU','\u2569':'boxHU','\u256A':'boxvH','\u256B':'boxVh','\u256C':'boxVH','\u2580':'uhblk','\u2584':'lhblk','\u2588':'block','\u2591':'blk14','\u2592':'blk12','\u2593':'blk34','\u25A1':'squ','\u25AA':'squf','\u25AB':'EmptyVerySmallSquare','\u25AD':'rect','\u25AE':'marker','\u25B1':'fltns','\u25B3':'xutri','\u25B4':'utrif','\u25B5':'utri','\u25B8':'rtrif','\u25B9':'rtri','\u25BD':'xdtri','\u25BE':'dtrif','\u25BF':'dtri','\u25C2':'ltrif','\u25C3':'ltri','\u25CA':'loz','\u25CB':'cir','\u25EC':'tridot','\u25EF':'xcirc','\u25F8':'ultri','\u25F9':'urtri','\u25FA':'lltri','\u25FB':'EmptySmallSquare','\u25FC':'FilledSmallSquare','\u2605':'starf','\u2606':'star','\u260E':'phone','\u2640':'female','\u2642':'male','\u2660':'spades','\u2663':'clubs','\u2665':'hearts','\u2666':'diams','\u266A':'sung','\u2713':'check','\u2717':'cross','\u2720':'malt','\u2736':'sext','\u2758':'VerticalSeparator','\u27C8':'bsolhsub','\u27C9':'suphsol','\u27F5':'xlarr','\u27F6':'xrarr','\u27F7':'xharr','\u27F8':'xlArr','\u27F9':'xrArr','\u27FA':'xhArr','\u27FC':'xmap','\u27FF':'dzigrarr','\u2902':'nvlArr','\u2903':'nvrArr','\u2904':'nvHarr','\u2905':'Map','\u290C':'lbarr','\u290D':'rbarr','\u290E':'lBarr','\u290F':'rBarr','\u2910':'RBarr','\u2911':'DDotrahd','\u2912':'UpArrowBar','\u2913':'DownArrowBar','\u2916':'Rarrtl','\u2919':'latail','\u291A':'ratail','\u291B':'lAtail','\u291C':'rAtail','\u291D':'larrfs','\u291E':'rarrfs','\u291F':'larrbfs','\u2920':'rarrbfs','\u2923':'nwarhk','\u2924':'nearhk','\u2925':'searhk','\u2926':'swarhk','\u2927':'nwnear','\u2928':'toea','\u2929':'tosa','\u292A':'swnwar','\u2933':'rarrc','\u2933\u0338':'nrarrc','\u2935':'cudarrr','\u2936':'ldca','\u2937':'rdca','\u2938':'cudarrl','\u2939':'larrpl','\u293C':'curarrm','\u293D':'cularrp','\u2945':'rarrpl','\u2948':'harrcir','\u2949':'Uarrocir','\u294A':'lurdshar','\u294B':'ldrushar','\u294E':'LeftRightVector','\u294F':'RightUpDownVector','\u2950':'DownLeftRightVector','\u2951':'LeftUpDownVector','\u2952':'LeftVectorBar','\u2953':'RightVectorBar','\u2954':'RightUpVectorBar','\u2955':'RightDownVectorBar','\u2956':'DownLeftVectorBar','\u2957':'DownRightVectorBar','\u2958':'LeftUpVectorBar','\u2959':'LeftDownVectorBar','\u295A':'LeftTeeVector','\u295B':'RightTeeVector','\u295C':'RightUpTeeVector','\u295D':'RightDownTeeVector','\u295E':'DownLeftTeeVector','\u295F':'DownRightTeeVector','\u2960':'LeftUpTeeVector','\u2961':'LeftDownTeeVector','\u2962':'lHar','\u2963':'uHar','\u2964':'rHar','\u2965':'dHar','\u2966':'luruhar','\u2967':'ldrdhar','\u2968':'ruluhar','\u2969':'rdldhar','\u296A':'lharul','\u296B':'llhard','\u296C':'rharul','\u296D':'lrhard','\u296E':'udhar','\u296F':'duhar','\u2970':'RoundImplies','\u2971':'erarr','\u2972':'simrarr','\u2973':'larrsim','\u2974':'rarrsim','\u2975':'rarrap','\u2976':'ltlarr','\u2978':'gtrarr','\u2979':'subrarr','\u297B':'suplarr','\u297C':'lfisht','\u297D':'rfisht','\u297E':'ufisht','\u297F':'dfisht','\u299A':'vzigzag','\u299C':'vangrt','\u299D':'angrtvbd','\u29A4':'ange','\u29A5':'range','\u29A6':'dwangle','\u29A7':'uwangle','\u29A8':'angmsdaa','\u29A9':'angmsdab','\u29AA':'angmsdac','\u29AB':'angmsdad','\u29AC':'angmsdae','\u29AD':'angmsdaf','\u29AE':'angmsdag','\u29AF':'angmsdah','\u29B0':'bemptyv','\u29B1':'demptyv','\u29B2':'cemptyv','\u29B3':'raemptyv','\u29B4':'laemptyv','\u29B5':'ohbar','\u29B6':'omid','\u29B7':'opar','\u29B9':'operp','\u29BB':'olcross','\u29BC':'odsold','\u29BE':'olcir','\u29BF':'ofcir','\u29C0':'olt','\u29C1':'ogt','\u29C2':'cirscir','\u29C3':'cirE','\u29C4':'solb','\u29C5':'bsolb','\u29C9':'boxbox','\u29CD':'trisb','\u29CE':'rtriltri','\u29CF':'LeftTriangleBar','\u29CF\u0338':'NotLeftTriangleBar','\u29D0':'RightTriangleBar','\u29D0\u0338':'NotRightTriangleBar','\u29DC':'iinfin','\u29DD':'infintie','\u29DE':'nvinfin','\u29E3':'eparsl','\u29E4':'smeparsl','\u29E5':'eqvparsl','\u29EB':'lozf','\u29F4':'RuleDelayed','\u29F6':'dsol','\u2A00':'xodot','\u2A01':'xoplus','\u2A02':'xotime','\u2A04':'xuplus','\u2A06':'xsqcup','\u2A0D':'fpartint','\u2A10':'cirfnint','\u2A11':'awint','\u2A12':'rppolint','\u2A13':'scpolint','\u2A14':'npolint','\u2A15':'pointint','\u2A16':'quatint','\u2A17':'intlarhk','\u2A22':'pluscir','\u2A23':'plusacir','\u2A24':'simplus','\u2A25':'plusdu','\u2A26':'plussim','\u2A27':'plustwo','\u2A29':'mcomma','\u2A2A':'minusdu','\u2A2D':'loplus','\u2A2E':'roplus','\u2A2F':'Cross','\u2A30':'timesd','\u2A31':'timesbar','\u2A33':'smashp','\u2A34':'lotimes','\u2A35':'rotimes','\u2A36':'otimesas','\u2A37':'Otimes','\u2A38':'odiv','\u2A39':'triplus','\u2A3A':'triminus','\u2A3B':'tritime','\u2A3C':'iprod','\u2A3F':'amalg','\u2A40':'capdot','\u2A42':'ncup','\u2A43':'ncap','\u2A44':'capand','\u2A45':'cupor','\u2A46':'cupcap','\u2A47':'capcup','\u2A48':'cupbrcap','\u2A49':'capbrcup','\u2A4A':'cupcup','\u2A4B':'capcap','\u2A4C':'ccups','\u2A4D':'ccaps','\u2A50':'ccupssm','\u2A53':'And','\u2A54':'Or','\u2A55':'andand','\u2A56':'oror','\u2A57':'orslope','\u2A58':'andslope','\u2A5A':'andv','\u2A5B':'orv','\u2A5C':'andd','\u2A5D':'ord','\u2A5F':'wedbar','\u2A66':'sdote','\u2A6A':'simdot','\u2A6D':'congdot','\u2A6D\u0338':'ncongdot','\u2A6E':'easter','\u2A6F':'apacir','\u2A70':'apE','\u2A70\u0338':'napE','\u2A71':'eplus','\u2A72':'pluse','\u2A73':'Esim','\u2A77':'eDDot','\u2A78':'equivDD','\u2A79':'ltcir','\u2A7A':'gtcir','\u2A7B':'ltquest','\u2A7C':'gtquest','\u2A7D':'les','\u2A7D\u0338':'nles','\u2A7E':'ges','\u2A7E\u0338':'nges','\u2A7F':'lesdot','\u2A80':'gesdot','\u2A81':'lesdoto','\u2A82':'gesdoto','\u2A83':'lesdotor','\u2A84':'gesdotol','\u2A85':'lap','\u2A86':'gap','\u2A87':'lne','\u2A88':'gne','\u2A89':'lnap','\u2A8A':'gnap','\u2A8B':'lEg','\u2A8C':'gEl','\u2A8D':'lsime','\u2A8E':'gsime','\u2A8F':'lsimg','\u2A90':'gsiml','\u2A91':'lgE','\u2A92':'glE','\u2A93':'lesges','\u2A94':'gesles','\u2A95':'els','\u2A96':'egs','\u2A97':'elsdot','\u2A98':'egsdot','\u2A99':'el','\u2A9A':'eg','\u2A9D':'siml','\u2A9E':'simg','\u2A9F':'simlE','\u2AA0':'simgE','\u2AA1':'LessLess','\u2AA1\u0338':'NotNestedLessLess','\u2AA2':'GreaterGreater','\u2AA2\u0338':'NotNestedGreaterGreater','\u2AA4':'glj','\u2AA5':'gla','\u2AA6':'ltcc','\u2AA7':'gtcc','\u2AA8':'lescc','\u2AA9':'gescc','\u2AAA':'smt','\u2AAB':'lat','\u2AAC':'smte','\u2AAC\uFE00':'smtes','\u2AAD':'late','\u2AAD\uFE00':'lates','\u2AAE':'bumpE','\u2AAF':'pre','\u2AAF\u0338':'npre','\u2AB0':'sce','\u2AB0\u0338':'nsce','\u2AB3':'prE','\u2AB4':'scE','\u2AB5':'prnE','\u2AB6':'scnE','\u2AB7':'prap','\u2AB8':'scap','\u2AB9':'prnap','\u2ABA':'scnap','\u2ABB':'Pr','\u2ABC':'Sc','\u2ABD':'subdot','\u2ABE':'supdot','\u2ABF':'subplus','\u2AC0':'supplus','\u2AC1':'submult','\u2AC2':'supmult','\u2AC3':'subedot','\u2AC4':'supedot','\u2AC5':'subE','\u2AC5\u0338':'nsubE','\u2AC6':'supE','\u2AC6\u0338':'nsupE','\u2AC7':'subsim','\u2AC8':'supsim','\u2ACB\uFE00':'vsubnE','\u2ACB':'subnE','\u2ACC\uFE00':'vsupnE','\u2ACC':'supnE','\u2ACF':'csub','\u2AD0':'csup','\u2AD1':'csube','\u2AD2':'csupe','\u2AD3':'subsup','\u2AD4':'supsub','\u2AD5':'subsub','\u2AD6':'supsup','\u2AD7':'suphsub','\u2AD8':'supdsub','\u2AD9':'forkv','\u2ADA':'topfork','\u2ADB':'mlcp','\u2AE4':'Dashv','\u2AE6':'Vdashl','\u2AE7':'Barv','\u2AE8':'vBar','\u2AE9':'vBarv','\u2AEB':'Vbar','\u2AEC':'Not','\u2AED':'bNot','\u2AEE':'rnmid','\u2AEF':'cirmid','\u2AF0':'midcir','\u2AF1':'topcir','\u2AF2':'nhpar','\u2AF3':'parsim','\u2AFD':'parsl','\u2AFD\u20E5':'nparsl','\u266D':'flat','\u266E':'natur','\u266F':'sharp','\xA4':'curren','\xA2':'cent','$':'dollar','\xA3':'pound','\xA5':'yen','\u20AC':'euro','\xB9':'sup1','\xBD':'half','\u2153':'frac13','\xBC':'frac14','\u2155':'frac15','\u2159':'frac16','\u215B':'frac18','\xB2':'sup2','\u2154':'frac23','\u2156':'frac25','\xB3':'sup3','\xBE':'frac34','\u2157':'frac35','\u215C':'frac38','\u2158':'frac45','\u215A':'frac56','\u215D':'frac58','\u215E':'frac78','\uD835\uDCB6':'ascr','\uD835\uDD52':'aopf','\uD835\uDD1E':'afr','\uD835\uDD38':'Aopf','\uD835\uDD04':'Afr','\uD835\uDC9C':'Ascr','\xAA':'ordf','\xE1':'aacute','\xC1':'Aacute','\xE0':'agrave','\xC0':'Agrave','\u0103':'abreve','\u0102':'Abreve','\xE2':'acirc','\xC2':'Acirc','\xE5':'aring','\xC5':'angst','\xE4':'auml','\xC4':'Auml','\xE3':'atilde','\xC3':'Atilde','\u0105':'aogon','\u0104':'Aogon','\u0101':'amacr','\u0100':'Amacr','\xE6':'aelig','\xC6':'AElig','\uD835\uDCB7':'bscr','\uD835\uDD53':'bopf','\uD835\uDD1F':'bfr','\uD835\uDD39':'Bopf','\u212C':'Bscr','\uD835\uDD05':'Bfr','\uD835\uDD20':'cfr','\uD835\uDCB8':'cscr','\uD835\uDD54':'copf','\u212D':'Cfr','\uD835\uDC9E':'Cscr','\u2102':'Copf','\u0107':'cacute','\u0106':'Cacute','\u0109':'ccirc','\u0108':'Ccirc','\u010D':'ccaron','\u010C':'Ccaron','\u010B':'cdot','\u010A':'Cdot','\xE7':'ccedil','\xC7':'Ccedil','\u2105':'incare','\uD835\uDD21':'dfr','\u2146':'dd','\uD835\uDD55':'dopf','\uD835\uDCB9':'dscr','\uD835\uDC9F':'Dscr','\uD835\uDD07':'Dfr','\u2145':'DD','\uD835\uDD3B':'Dopf','\u010F':'dcaron','\u010E':'Dcaron','\u0111':'dstrok','\u0110':'Dstrok','\xF0':'eth','\xD0':'ETH','\u2147':'ee','\u212F':'escr','\uD835\uDD22':'efr','\uD835\uDD56':'eopf','\u2130':'Escr','\uD835\uDD08':'Efr','\uD835\uDD3C':'Eopf','\xE9':'eacute','\xC9':'Eacute','\xE8':'egrave','\xC8':'Egrave','\xEA':'ecirc','\xCA':'Ecirc','\u011B':'ecaron','\u011A':'Ecaron','\xEB':'euml','\xCB':'Euml','\u0117':'edot','\u0116':'Edot','\u0119':'eogon','\u0118':'Eogon','\u0113':'emacr','\u0112':'Emacr','\uD835\uDD23':'ffr','\uD835\uDD57':'fopf','\uD835\uDCBB':'fscr','\uD835\uDD09':'Ffr','\uD835\uDD3D':'Fopf','\u2131':'Fscr','\uFB00':'fflig','\uFB03':'ffilig','\uFB04':'ffllig','\uFB01':'filig','fj':'fjlig','\uFB02':'fllig','\u0192':'fnof','\u210A':'gscr','\uD835\uDD58':'gopf','\uD835\uDD24':'gfr','\uD835\uDCA2':'Gscr','\uD835\uDD3E':'Gopf','\uD835\uDD0A':'Gfr','\u01F5':'gacute','\u011F':'gbreve','\u011E':'Gbreve','\u011D':'gcirc','\u011C':'Gcirc','\u0121':'gdot','\u0120':'Gdot','\u0122':'Gcedil','\uD835\uDD25':'hfr','\u210E':'planckh','\uD835\uDCBD':'hscr','\uD835\uDD59':'hopf','\u210B':'Hscr','\u210C':'Hfr','\u210D':'Hopf','\u0125':'hcirc','\u0124':'Hcirc','\u210F':'hbar','\u0127':'hstrok','\u0126':'Hstrok','\uD835\uDD5A':'iopf','\uD835\uDD26':'ifr','\uD835\uDCBE':'iscr','\u2148':'ii','\uD835\uDD40':'Iopf','\u2110':'Iscr','\u2111':'Im','\xED':'iacute','\xCD':'Iacute','\xEC':'igrave','\xCC':'Igrave','\xEE':'icirc','\xCE':'Icirc','\xEF':'iuml','\xCF':'Iuml','\u0129':'itilde','\u0128':'Itilde','\u0130':'Idot','\u012F':'iogon','\u012E':'Iogon','\u012B':'imacr','\u012A':'Imacr','\u0133':'ijlig','\u0132':'IJlig','\u0131':'imath','\uD835\uDCBF':'jscr','\uD835\uDD5B':'jopf','\uD835\uDD27':'jfr','\uD835\uDCA5':'Jscr','\uD835\uDD0D':'Jfr','\uD835\uDD41':'Jopf','\u0135':'jcirc','\u0134':'Jcirc','\u0237':'jmath','\uD835\uDD5C':'kopf','\uD835\uDCC0':'kscr','\uD835\uDD28':'kfr','\uD835\uDCA6':'Kscr','\uD835\uDD42':'Kopf','\uD835\uDD0E':'Kfr','\u0137':'kcedil','\u0136':'Kcedil','\uD835\uDD29':'lfr','\uD835\uDCC1':'lscr','\u2113':'ell','\uD835\uDD5D':'lopf','\u2112':'Lscr','\uD835\uDD0F':'Lfr','\uD835\uDD43':'Lopf','\u013A':'lacute','\u0139':'Lacute','\u013E':'lcaron','\u013D':'Lcaron','\u013C':'lcedil','\u013B':'Lcedil','\u0142':'lstrok','\u0141':'Lstrok','\u0140':'lmidot','\u013F':'Lmidot','\uD835\uDD2A':'mfr','\uD835\uDD5E':'mopf','\uD835\uDCC2':'mscr','\uD835\uDD10':'Mfr','\uD835\uDD44':'Mopf','\u2133':'Mscr','\uD835\uDD2B':'nfr','\uD835\uDD5F':'nopf','\uD835\uDCC3':'nscr','\u2115':'Nopf','\uD835\uDCA9':'Nscr','\uD835\uDD11':'Nfr','\u0144':'nacute','\u0143':'Nacute','\u0148':'ncaron','\u0147':'Ncaron','\xF1':'ntilde','\xD1':'Ntilde','\u0146':'ncedil','\u0145':'Ncedil','\u2116':'numero','\u014B':'eng','\u014A':'ENG','\uD835\uDD60':'oopf','\uD835\uDD2C':'ofr','\u2134':'oscr','\uD835\uDCAA':'Oscr','\uD835\uDD12':'Ofr','\uD835\uDD46':'Oopf','\xBA':'ordm','\xF3':'oacute','\xD3':'Oacute','\xF2':'ograve','\xD2':'Ograve','\xF4':'ocirc','\xD4':'Ocirc','\xF6':'ouml','\xD6':'Ouml','\u0151':'odblac','\u0150':'Odblac','\xF5':'otilde','\xD5':'Otilde','\xF8':'oslash','\xD8':'Oslash','\u014D':'omacr','\u014C':'Omacr','\u0153':'oelig','\u0152':'OElig','\uD835\uDD2D':'pfr','\uD835\uDCC5':'pscr','\uD835\uDD61':'popf','\u2119':'Popf','\uD835\uDD13':'Pfr','\uD835\uDCAB':'Pscr','\uD835\uDD62':'qopf','\uD835\uDD2E':'qfr','\uD835\uDCC6':'qscr','\uD835\uDCAC':'Qscr','\uD835\uDD14':'Qfr','\u211A':'Qopf','\u0138':'kgreen','\uD835\uDD2F':'rfr','\uD835\uDD63':'ropf','\uD835\uDCC7':'rscr','\u211B':'Rscr','\u211C':'Re','\u211D':'Ropf','\u0155':'racute','\u0154':'Racute','\u0159':'rcaron','\u0158':'Rcaron','\u0157':'rcedil','\u0156':'Rcedil','\uD835\uDD64':'sopf','\uD835\uDCC8':'sscr','\uD835\uDD30':'sfr','\uD835\uDD4A':'Sopf','\uD835\uDD16':'Sfr','\uD835\uDCAE':'Sscr','\u24C8':'oS','\u015B':'sacute','\u015A':'Sacute','\u015D':'scirc','\u015C':'Scirc','\u0161':'scaron','\u0160':'Scaron','\u015F':'scedil','\u015E':'Scedil','\xDF':'szlig','\uD835\uDD31':'tfr','\uD835\uDCC9':'tscr','\uD835\uDD65':'topf','\uD835\uDCAF':'Tscr','\uD835\uDD17':'Tfr','\uD835\uDD4B':'Topf','\u0165':'tcaron','\u0164':'Tcaron','\u0163':'tcedil','\u0162':'Tcedil','\u2122':'trade','\u0167':'tstrok','\u0166':'Tstrok','\uD835\uDCCA':'uscr','\uD835\uDD66':'uopf','\uD835\uDD32':'ufr','\uD835\uDD4C':'Uopf','\uD835\uDD18':'Ufr','\uD835\uDCB0':'Uscr','\xFA':'uacute','\xDA':'Uacute','\xF9':'ugrave','\xD9':'Ugrave','\u016D':'ubreve','\u016C':'Ubreve','\xFB':'ucirc','\xDB':'Ucirc','\u016F':'uring','\u016E':'Uring','\xFC':'uuml','\xDC':'Uuml','\u0171':'udblac','\u0170':'Udblac','\u0169':'utilde','\u0168':'Utilde','\u0173':'uogon','\u0172':'Uogon','\u016B':'umacr','\u016A':'Umacr','\uD835\uDD33':'vfr','\uD835\uDD67':'vopf','\uD835\uDCCB':'vscr','\uD835\uDD19':'Vfr','\uD835\uDD4D':'Vopf','\uD835\uDCB1':'Vscr','\uD835\uDD68':'wopf','\uD835\uDCCC':'wscr','\uD835\uDD34':'wfr','\uD835\uDCB2':'Wscr','\uD835\uDD4E':'Wopf','\uD835\uDD1A':'Wfr','\u0175':'wcirc','\u0174':'Wcirc','\uD835\uDD35':'xfr','\uD835\uDCCD':'xscr','\uD835\uDD69':'xopf','\uD835\uDD4F':'Xopf','\uD835\uDD1B':'Xfr','\uD835\uDCB3':'Xscr','\uD835\uDD36':'yfr','\uD835\uDCCE':'yscr','\uD835\uDD6A':'yopf','\uD835\uDCB4':'Yscr','\uD835\uDD1C':'Yfr','\uD835\uDD50':'Yopf','\xFD':'yacute','\xDD':'Yacute','\u0177':'ycirc','\u0176':'Ycirc','\xFF':'yuml','\u0178':'Yuml','\uD835\uDCCF':'zscr','\uD835\uDD37':'zfr','\uD835\uDD6B':'zopf','\u2128':'Zfr','\u2124':'Zopf','\uD835\uDCB5':'Zscr','\u017A':'zacute','\u0179':'Zacute','\u017E':'zcaron','\u017D':'Zcaron','\u017C':'zdot','\u017B':'Zdot','\u01B5':'imped','\xFE':'thorn','\xDE':'THORN','\u0149':'napos','\u03B1':'alpha','\u0391':'Alpha','\u03B2':'beta','\u0392':'Beta','\u03B3':'gamma','\u0393':'Gamma','\u03B4':'delta','\u0394':'Delta','\u03B5':'epsi','\u03F5':'epsiv','\u0395':'Epsilon','\u03DD':'gammad','\u03DC':'Gammad','\u03B6':'zeta','\u0396':'Zeta','\u03B7':'eta','\u0397':'Eta','\u03B8':'theta','\u03D1':'thetav','\u0398':'Theta','\u03B9':'iota','\u0399':'Iota','\u03BA':'kappa','\u03F0':'kappav','\u039A':'Kappa','\u03BB':'lambda','\u039B':'Lambda','\u03BC':'mu','\xB5':'micro','\u039C':'Mu','\u03BD':'nu','\u039D':'Nu','\u03BE':'xi','\u039E':'Xi','\u03BF':'omicron','\u039F':'Omicron','\u03C0':'pi','\u03D6':'piv','\u03A0':'Pi','\u03C1':'rho','\u03F1':'rhov','\u03A1':'Rho','\u03C3':'sigma','\u03A3':'Sigma','\u03C2':'sigmaf','\u03C4':'tau','\u03A4':'Tau','\u03C5':'upsi','\u03A5':'Upsilon','\u03D2':'Upsi','\u03C6':'phi','\u03D5':'phiv','\u03A6':'Phi','\u03C7':'chi','\u03A7':'Chi','\u03C8':'psi','\u03A8':'Psi','\u03C9':'omega','\u03A9':'ohm','\u0430':'acy','\u0410':'Acy','\u0431':'bcy','\u0411':'Bcy','\u0432':'vcy','\u0412':'Vcy','\u0433':'gcy','\u0413':'Gcy','\u0453':'gjcy','\u0403':'GJcy','\u0434':'dcy','\u0414':'Dcy','\u0452':'djcy','\u0402':'DJcy','\u0435':'iecy','\u0415':'IEcy','\u0451':'iocy','\u0401':'IOcy','\u0454':'jukcy','\u0404':'Jukcy','\u0436':'zhcy','\u0416':'ZHcy','\u0437':'zcy','\u0417':'Zcy','\u0455':'dscy','\u0405':'DScy','\u0438':'icy','\u0418':'Icy','\u0456':'iukcy','\u0406':'Iukcy','\u0457':'yicy','\u0407':'YIcy','\u0439':'jcy','\u0419':'Jcy','\u0458':'jsercy','\u0408':'Jsercy','\u043A':'kcy','\u041A':'Kcy','\u045C':'kjcy','\u040C':'KJcy','\u043B':'lcy','\u041B':'Lcy','\u0459':'ljcy','\u0409':'LJcy','\u043C':'mcy','\u041C':'Mcy','\u043D':'ncy','\u041D':'Ncy','\u045A':'njcy','\u040A':'NJcy','\u043E':'ocy','\u041E':'Ocy','\u043F':'pcy','\u041F':'Pcy','\u0440':'rcy','\u0420':'Rcy','\u0441':'scy','\u0421':'Scy','\u0442':'tcy','\u0422':'Tcy','\u045B':'tshcy','\u040B':'TSHcy','\u0443':'ucy','\u0423':'Ucy','\u045E':'ubrcy','\u040E':'Ubrcy','\u0444':'fcy','\u0424':'Fcy','\u0445':'khcy','\u0425':'KHcy','\u0446':'tscy','\u0426':'TScy','\u0447':'chcy','\u0427':'CHcy','\u045F':'dzcy','\u040F':'DZcy','\u0448':'shcy','\u0428':'SHcy','\u0449':'shchcy','\u0429':'SHCHcy','\u044A':'hardcy','\u042A':'HARDcy','\u044B':'ycy','\u042B':'Ycy','\u044C':'softcy','\u042C':'SOFTcy','\u044D':'ecy','\u042D':'Ecy','\u044E':'yucy','\u042E':'YUcy','\u044F':'yacy','\u042F':'YAcy','\u2135':'aleph','\u2136':'beth','\u2137':'gimel','\u2138':'daleth'};

    	var regexEscape = /["&'<>`]/g;
    	var escapeMap = {
    		'"': '&quot;',
    		'&': '&amp;',
    		'\'': '&#x27;',
    		'<': '&lt;',
    		// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
    		// following is not strictly necessary unless it’s part of a tag or an
    		// unquoted attribute value. We’re only escaping it to support those
    		// situations, and for XML support.
    		'>': '&gt;',
    		// In Internet Explorer ≤ 8, the backtick character can be used
    		// to break out of (un)quoted attribute values or HTML comments.
    		// See http://html5sec.org/#102, http://html5sec.org/#108, and
    		// http://html5sec.org/#133.
    		'`': '&#x60;'
    	};

    	var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
    	var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    	var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
    	var decodeMap = {'aacute':'\xE1','Aacute':'\xC1','abreve':'\u0103','Abreve':'\u0102','ac':'\u223E','acd':'\u223F','acE':'\u223E\u0333','acirc':'\xE2','Acirc':'\xC2','acute':'\xB4','acy':'\u0430','Acy':'\u0410','aelig':'\xE6','AElig':'\xC6','af':'\u2061','afr':'\uD835\uDD1E','Afr':'\uD835\uDD04','agrave':'\xE0','Agrave':'\xC0','alefsym':'\u2135','aleph':'\u2135','alpha':'\u03B1','Alpha':'\u0391','amacr':'\u0101','Amacr':'\u0100','amalg':'\u2A3F','amp':'&','AMP':'&','and':'\u2227','And':'\u2A53','andand':'\u2A55','andd':'\u2A5C','andslope':'\u2A58','andv':'\u2A5A','ang':'\u2220','ange':'\u29A4','angle':'\u2220','angmsd':'\u2221','angmsdaa':'\u29A8','angmsdab':'\u29A9','angmsdac':'\u29AA','angmsdad':'\u29AB','angmsdae':'\u29AC','angmsdaf':'\u29AD','angmsdag':'\u29AE','angmsdah':'\u29AF','angrt':'\u221F','angrtvb':'\u22BE','angrtvbd':'\u299D','angsph':'\u2222','angst':'\xC5','angzarr':'\u237C','aogon':'\u0105','Aogon':'\u0104','aopf':'\uD835\uDD52','Aopf':'\uD835\uDD38','ap':'\u2248','apacir':'\u2A6F','ape':'\u224A','apE':'\u2A70','apid':'\u224B','apos':'\'','ApplyFunction':'\u2061','approx':'\u2248','approxeq':'\u224A','aring':'\xE5','Aring':'\xC5','ascr':'\uD835\uDCB6','Ascr':'\uD835\uDC9C','Assign':'\u2254','ast':'*','asymp':'\u2248','asympeq':'\u224D','atilde':'\xE3','Atilde':'\xC3','auml':'\xE4','Auml':'\xC4','awconint':'\u2233','awint':'\u2A11','backcong':'\u224C','backepsilon':'\u03F6','backprime':'\u2035','backsim':'\u223D','backsimeq':'\u22CD','Backslash':'\u2216','Barv':'\u2AE7','barvee':'\u22BD','barwed':'\u2305','Barwed':'\u2306','barwedge':'\u2305','bbrk':'\u23B5','bbrktbrk':'\u23B6','bcong':'\u224C','bcy':'\u0431','Bcy':'\u0411','bdquo':'\u201E','becaus':'\u2235','because':'\u2235','Because':'\u2235','bemptyv':'\u29B0','bepsi':'\u03F6','bernou':'\u212C','Bernoullis':'\u212C','beta':'\u03B2','Beta':'\u0392','beth':'\u2136','between':'\u226C','bfr':'\uD835\uDD1F','Bfr':'\uD835\uDD05','bigcap':'\u22C2','bigcirc':'\u25EF','bigcup':'\u22C3','bigodot':'\u2A00','bigoplus':'\u2A01','bigotimes':'\u2A02','bigsqcup':'\u2A06','bigstar':'\u2605','bigtriangledown':'\u25BD','bigtriangleup':'\u25B3','biguplus':'\u2A04','bigvee':'\u22C1','bigwedge':'\u22C0','bkarow':'\u290D','blacklozenge':'\u29EB','blacksquare':'\u25AA','blacktriangle':'\u25B4','blacktriangledown':'\u25BE','blacktriangleleft':'\u25C2','blacktriangleright':'\u25B8','blank':'\u2423','blk12':'\u2592','blk14':'\u2591','blk34':'\u2593','block':'\u2588','bne':'=\u20E5','bnequiv':'\u2261\u20E5','bnot':'\u2310','bNot':'\u2AED','bopf':'\uD835\uDD53','Bopf':'\uD835\uDD39','bot':'\u22A5','bottom':'\u22A5','bowtie':'\u22C8','boxbox':'\u29C9','boxdl':'\u2510','boxdL':'\u2555','boxDl':'\u2556','boxDL':'\u2557','boxdr':'\u250C','boxdR':'\u2552','boxDr':'\u2553','boxDR':'\u2554','boxh':'\u2500','boxH':'\u2550','boxhd':'\u252C','boxhD':'\u2565','boxHd':'\u2564','boxHD':'\u2566','boxhu':'\u2534','boxhU':'\u2568','boxHu':'\u2567','boxHU':'\u2569','boxminus':'\u229F','boxplus':'\u229E','boxtimes':'\u22A0','boxul':'\u2518','boxuL':'\u255B','boxUl':'\u255C','boxUL':'\u255D','boxur':'\u2514','boxuR':'\u2558','boxUr':'\u2559','boxUR':'\u255A','boxv':'\u2502','boxV':'\u2551','boxvh':'\u253C','boxvH':'\u256A','boxVh':'\u256B','boxVH':'\u256C','boxvl':'\u2524','boxvL':'\u2561','boxVl':'\u2562','boxVL':'\u2563','boxvr':'\u251C','boxvR':'\u255E','boxVr':'\u255F','boxVR':'\u2560','bprime':'\u2035','breve':'\u02D8','Breve':'\u02D8','brvbar':'\xA6','bscr':'\uD835\uDCB7','Bscr':'\u212C','bsemi':'\u204F','bsim':'\u223D','bsime':'\u22CD','bsol':'\\','bsolb':'\u29C5','bsolhsub':'\u27C8','bull':'\u2022','bullet':'\u2022','bump':'\u224E','bumpe':'\u224F','bumpE':'\u2AAE','bumpeq':'\u224F','Bumpeq':'\u224E','cacute':'\u0107','Cacute':'\u0106','cap':'\u2229','Cap':'\u22D2','capand':'\u2A44','capbrcup':'\u2A49','capcap':'\u2A4B','capcup':'\u2A47','capdot':'\u2A40','CapitalDifferentialD':'\u2145','caps':'\u2229\uFE00','caret':'\u2041','caron':'\u02C7','Cayleys':'\u212D','ccaps':'\u2A4D','ccaron':'\u010D','Ccaron':'\u010C','ccedil':'\xE7','Ccedil':'\xC7','ccirc':'\u0109','Ccirc':'\u0108','Cconint':'\u2230','ccups':'\u2A4C','ccupssm':'\u2A50','cdot':'\u010B','Cdot':'\u010A','cedil':'\xB8','Cedilla':'\xB8','cemptyv':'\u29B2','cent':'\xA2','centerdot':'\xB7','CenterDot':'\xB7','cfr':'\uD835\uDD20','Cfr':'\u212D','chcy':'\u0447','CHcy':'\u0427','check':'\u2713','checkmark':'\u2713','chi':'\u03C7','Chi':'\u03A7','cir':'\u25CB','circ':'\u02C6','circeq':'\u2257','circlearrowleft':'\u21BA','circlearrowright':'\u21BB','circledast':'\u229B','circledcirc':'\u229A','circleddash':'\u229D','CircleDot':'\u2299','circledR':'\xAE','circledS':'\u24C8','CircleMinus':'\u2296','CirclePlus':'\u2295','CircleTimes':'\u2297','cire':'\u2257','cirE':'\u29C3','cirfnint':'\u2A10','cirmid':'\u2AEF','cirscir':'\u29C2','ClockwiseContourIntegral':'\u2232','CloseCurlyDoubleQuote':'\u201D','CloseCurlyQuote':'\u2019','clubs':'\u2663','clubsuit':'\u2663','colon':':','Colon':'\u2237','colone':'\u2254','Colone':'\u2A74','coloneq':'\u2254','comma':',','commat':'@','comp':'\u2201','compfn':'\u2218','complement':'\u2201','complexes':'\u2102','cong':'\u2245','congdot':'\u2A6D','Congruent':'\u2261','conint':'\u222E','Conint':'\u222F','ContourIntegral':'\u222E','copf':'\uD835\uDD54','Copf':'\u2102','coprod':'\u2210','Coproduct':'\u2210','copy':'\xA9','COPY':'\xA9','copysr':'\u2117','CounterClockwiseContourIntegral':'\u2233','crarr':'\u21B5','cross':'\u2717','Cross':'\u2A2F','cscr':'\uD835\uDCB8','Cscr':'\uD835\uDC9E','csub':'\u2ACF','csube':'\u2AD1','csup':'\u2AD0','csupe':'\u2AD2','ctdot':'\u22EF','cudarrl':'\u2938','cudarrr':'\u2935','cuepr':'\u22DE','cuesc':'\u22DF','cularr':'\u21B6','cularrp':'\u293D','cup':'\u222A','Cup':'\u22D3','cupbrcap':'\u2A48','cupcap':'\u2A46','CupCap':'\u224D','cupcup':'\u2A4A','cupdot':'\u228D','cupor':'\u2A45','cups':'\u222A\uFE00','curarr':'\u21B7','curarrm':'\u293C','curlyeqprec':'\u22DE','curlyeqsucc':'\u22DF','curlyvee':'\u22CE','curlywedge':'\u22CF','curren':'\xA4','curvearrowleft':'\u21B6','curvearrowright':'\u21B7','cuvee':'\u22CE','cuwed':'\u22CF','cwconint':'\u2232','cwint':'\u2231','cylcty':'\u232D','dagger':'\u2020','Dagger':'\u2021','daleth':'\u2138','darr':'\u2193','dArr':'\u21D3','Darr':'\u21A1','dash':'\u2010','dashv':'\u22A3','Dashv':'\u2AE4','dbkarow':'\u290F','dblac':'\u02DD','dcaron':'\u010F','Dcaron':'\u010E','dcy':'\u0434','Dcy':'\u0414','dd':'\u2146','DD':'\u2145','ddagger':'\u2021','ddarr':'\u21CA','DDotrahd':'\u2911','ddotseq':'\u2A77','deg':'\xB0','Del':'\u2207','delta':'\u03B4','Delta':'\u0394','demptyv':'\u29B1','dfisht':'\u297F','dfr':'\uD835\uDD21','Dfr':'\uD835\uDD07','dHar':'\u2965','dharl':'\u21C3','dharr':'\u21C2','DiacriticalAcute':'\xB4','DiacriticalDot':'\u02D9','DiacriticalDoubleAcute':'\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\u02DC','diam':'\u22C4','diamond':'\u22C4','Diamond':'\u22C4','diamondsuit':'\u2666','diams':'\u2666','die':'\xA8','DifferentialD':'\u2146','digamma':'\u03DD','disin':'\u22F2','div':'\xF7','divide':'\xF7','divideontimes':'\u22C7','divonx':'\u22C7','djcy':'\u0452','DJcy':'\u0402','dlcorn':'\u231E','dlcrop':'\u230D','dollar':'$','dopf':'\uD835\uDD55','Dopf':'\uD835\uDD3B','dot':'\u02D9','Dot':'\xA8','DotDot':'\u20DC','doteq':'\u2250','doteqdot':'\u2251','DotEqual':'\u2250','dotminus':'\u2238','dotplus':'\u2214','dotsquare':'\u22A1','doublebarwedge':'\u2306','DoubleContourIntegral':'\u222F','DoubleDot':'\xA8','DoubleDownArrow':'\u21D3','DoubleLeftArrow':'\u21D0','DoubleLeftRightArrow':'\u21D4','DoubleLeftTee':'\u2AE4','DoubleLongLeftArrow':'\u27F8','DoubleLongLeftRightArrow':'\u27FA','DoubleLongRightArrow':'\u27F9','DoubleRightArrow':'\u21D2','DoubleRightTee':'\u22A8','DoubleUpArrow':'\u21D1','DoubleUpDownArrow':'\u21D5','DoubleVerticalBar':'\u2225','downarrow':'\u2193','Downarrow':'\u21D3','DownArrow':'\u2193','DownArrowBar':'\u2913','DownArrowUpArrow':'\u21F5','DownBreve':'\u0311','downdownarrows':'\u21CA','downharpoonleft':'\u21C3','downharpoonright':'\u21C2','DownLeftRightVector':'\u2950','DownLeftTeeVector':'\u295E','DownLeftVector':'\u21BD','DownLeftVectorBar':'\u2956','DownRightTeeVector':'\u295F','DownRightVector':'\u21C1','DownRightVectorBar':'\u2957','DownTee':'\u22A4','DownTeeArrow':'\u21A7','drbkarow':'\u2910','drcorn':'\u231F','drcrop':'\u230C','dscr':'\uD835\uDCB9','Dscr':'\uD835\uDC9F','dscy':'\u0455','DScy':'\u0405','dsol':'\u29F6','dstrok':'\u0111','Dstrok':'\u0110','dtdot':'\u22F1','dtri':'\u25BF','dtrif':'\u25BE','duarr':'\u21F5','duhar':'\u296F','dwangle':'\u29A6','dzcy':'\u045F','DZcy':'\u040F','dzigrarr':'\u27FF','eacute':'\xE9','Eacute':'\xC9','easter':'\u2A6E','ecaron':'\u011B','Ecaron':'\u011A','ecir':'\u2256','ecirc':'\xEA','Ecirc':'\xCA','ecolon':'\u2255','ecy':'\u044D','Ecy':'\u042D','eDDot':'\u2A77','edot':'\u0117','eDot':'\u2251','Edot':'\u0116','ee':'\u2147','efDot':'\u2252','efr':'\uD835\uDD22','Efr':'\uD835\uDD08','eg':'\u2A9A','egrave':'\xE8','Egrave':'\xC8','egs':'\u2A96','egsdot':'\u2A98','el':'\u2A99','Element':'\u2208','elinters':'\u23E7','ell':'\u2113','els':'\u2A95','elsdot':'\u2A97','emacr':'\u0113','Emacr':'\u0112','empty':'\u2205','emptyset':'\u2205','EmptySmallSquare':'\u25FB','emptyv':'\u2205','EmptyVerySmallSquare':'\u25AB','emsp':'\u2003','emsp13':'\u2004','emsp14':'\u2005','eng':'\u014B','ENG':'\u014A','ensp':'\u2002','eogon':'\u0119','Eogon':'\u0118','eopf':'\uD835\uDD56','Eopf':'\uD835\uDD3C','epar':'\u22D5','eparsl':'\u29E3','eplus':'\u2A71','epsi':'\u03B5','epsilon':'\u03B5','Epsilon':'\u0395','epsiv':'\u03F5','eqcirc':'\u2256','eqcolon':'\u2255','eqsim':'\u2242','eqslantgtr':'\u2A96','eqslantless':'\u2A95','Equal':'\u2A75','equals':'=','EqualTilde':'\u2242','equest':'\u225F','Equilibrium':'\u21CC','equiv':'\u2261','equivDD':'\u2A78','eqvparsl':'\u29E5','erarr':'\u2971','erDot':'\u2253','escr':'\u212F','Escr':'\u2130','esdot':'\u2250','esim':'\u2242','Esim':'\u2A73','eta':'\u03B7','Eta':'\u0397','eth':'\xF0','ETH':'\xD0','euml':'\xEB','Euml':'\xCB','euro':'\u20AC','excl':'!','exist':'\u2203','Exists':'\u2203','expectation':'\u2130','exponentiale':'\u2147','ExponentialE':'\u2147','fallingdotseq':'\u2252','fcy':'\u0444','Fcy':'\u0424','female':'\u2640','ffilig':'\uFB03','fflig':'\uFB00','ffllig':'\uFB04','ffr':'\uD835\uDD23','Ffr':'\uD835\uDD09','filig':'\uFB01','FilledSmallSquare':'\u25FC','FilledVerySmallSquare':'\u25AA','fjlig':'fj','flat':'\u266D','fllig':'\uFB02','fltns':'\u25B1','fnof':'\u0192','fopf':'\uD835\uDD57','Fopf':'\uD835\uDD3D','forall':'\u2200','ForAll':'\u2200','fork':'\u22D4','forkv':'\u2AD9','Fouriertrf':'\u2131','fpartint':'\u2A0D','frac12':'\xBD','frac13':'\u2153','frac14':'\xBC','frac15':'\u2155','frac16':'\u2159','frac18':'\u215B','frac23':'\u2154','frac25':'\u2156','frac34':'\xBE','frac35':'\u2157','frac38':'\u215C','frac45':'\u2158','frac56':'\u215A','frac58':'\u215D','frac78':'\u215E','frasl':'\u2044','frown':'\u2322','fscr':'\uD835\uDCBB','Fscr':'\u2131','gacute':'\u01F5','gamma':'\u03B3','Gamma':'\u0393','gammad':'\u03DD','Gammad':'\u03DC','gap':'\u2A86','gbreve':'\u011F','Gbreve':'\u011E','Gcedil':'\u0122','gcirc':'\u011D','Gcirc':'\u011C','gcy':'\u0433','Gcy':'\u0413','gdot':'\u0121','Gdot':'\u0120','ge':'\u2265','gE':'\u2267','gel':'\u22DB','gEl':'\u2A8C','geq':'\u2265','geqq':'\u2267','geqslant':'\u2A7E','ges':'\u2A7E','gescc':'\u2AA9','gesdot':'\u2A80','gesdoto':'\u2A82','gesdotol':'\u2A84','gesl':'\u22DB\uFE00','gesles':'\u2A94','gfr':'\uD835\uDD24','Gfr':'\uD835\uDD0A','gg':'\u226B','Gg':'\u22D9','ggg':'\u22D9','gimel':'\u2137','gjcy':'\u0453','GJcy':'\u0403','gl':'\u2277','gla':'\u2AA5','glE':'\u2A92','glj':'\u2AA4','gnap':'\u2A8A','gnapprox':'\u2A8A','gne':'\u2A88','gnE':'\u2269','gneq':'\u2A88','gneqq':'\u2269','gnsim':'\u22E7','gopf':'\uD835\uDD58','Gopf':'\uD835\uDD3E','grave':'`','GreaterEqual':'\u2265','GreaterEqualLess':'\u22DB','GreaterFullEqual':'\u2267','GreaterGreater':'\u2AA2','GreaterLess':'\u2277','GreaterSlantEqual':'\u2A7E','GreaterTilde':'\u2273','gscr':'\u210A','Gscr':'\uD835\uDCA2','gsim':'\u2273','gsime':'\u2A8E','gsiml':'\u2A90','gt':'>','Gt':'\u226B','GT':'>','gtcc':'\u2AA7','gtcir':'\u2A7A','gtdot':'\u22D7','gtlPar':'\u2995','gtquest':'\u2A7C','gtrapprox':'\u2A86','gtrarr':'\u2978','gtrdot':'\u22D7','gtreqless':'\u22DB','gtreqqless':'\u2A8C','gtrless':'\u2277','gtrsim':'\u2273','gvertneqq':'\u2269\uFE00','gvnE':'\u2269\uFE00','Hacek':'\u02C7','hairsp':'\u200A','half':'\xBD','hamilt':'\u210B','hardcy':'\u044A','HARDcy':'\u042A','harr':'\u2194','hArr':'\u21D4','harrcir':'\u2948','harrw':'\u21AD','Hat':'^','hbar':'\u210F','hcirc':'\u0125','Hcirc':'\u0124','hearts':'\u2665','heartsuit':'\u2665','hellip':'\u2026','hercon':'\u22B9','hfr':'\uD835\uDD25','Hfr':'\u210C','HilbertSpace':'\u210B','hksearow':'\u2925','hkswarow':'\u2926','hoarr':'\u21FF','homtht':'\u223B','hookleftarrow':'\u21A9','hookrightarrow':'\u21AA','hopf':'\uD835\uDD59','Hopf':'\u210D','horbar':'\u2015','HorizontalLine':'\u2500','hscr':'\uD835\uDCBD','Hscr':'\u210B','hslash':'\u210F','hstrok':'\u0127','Hstrok':'\u0126','HumpDownHump':'\u224E','HumpEqual':'\u224F','hybull':'\u2043','hyphen':'\u2010','iacute':'\xED','Iacute':'\xCD','ic':'\u2063','icirc':'\xEE','Icirc':'\xCE','icy':'\u0438','Icy':'\u0418','Idot':'\u0130','iecy':'\u0435','IEcy':'\u0415','iexcl':'\xA1','iff':'\u21D4','ifr':'\uD835\uDD26','Ifr':'\u2111','igrave':'\xEC','Igrave':'\xCC','ii':'\u2148','iiiint':'\u2A0C','iiint':'\u222D','iinfin':'\u29DC','iiota':'\u2129','ijlig':'\u0133','IJlig':'\u0132','Im':'\u2111','imacr':'\u012B','Imacr':'\u012A','image':'\u2111','ImaginaryI':'\u2148','imagline':'\u2110','imagpart':'\u2111','imath':'\u0131','imof':'\u22B7','imped':'\u01B5','Implies':'\u21D2','in':'\u2208','incare':'\u2105','infin':'\u221E','infintie':'\u29DD','inodot':'\u0131','int':'\u222B','Int':'\u222C','intcal':'\u22BA','integers':'\u2124','Integral':'\u222B','intercal':'\u22BA','Intersection':'\u22C2','intlarhk':'\u2A17','intprod':'\u2A3C','InvisibleComma':'\u2063','InvisibleTimes':'\u2062','iocy':'\u0451','IOcy':'\u0401','iogon':'\u012F','Iogon':'\u012E','iopf':'\uD835\uDD5A','Iopf':'\uD835\uDD40','iota':'\u03B9','Iota':'\u0399','iprod':'\u2A3C','iquest':'\xBF','iscr':'\uD835\uDCBE','Iscr':'\u2110','isin':'\u2208','isindot':'\u22F5','isinE':'\u22F9','isins':'\u22F4','isinsv':'\u22F3','isinv':'\u2208','it':'\u2062','itilde':'\u0129','Itilde':'\u0128','iukcy':'\u0456','Iukcy':'\u0406','iuml':'\xEF','Iuml':'\xCF','jcirc':'\u0135','Jcirc':'\u0134','jcy':'\u0439','Jcy':'\u0419','jfr':'\uD835\uDD27','Jfr':'\uD835\uDD0D','jmath':'\u0237','jopf':'\uD835\uDD5B','Jopf':'\uD835\uDD41','jscr':'\uD835\uDCBF','Jscr':'\uD835\uDCA5','jsercy':'\u0458','Jsercy':'\u0408','jukcy':'\u0454','Jukcy':'\u0404','kappa':'\u03BA','Kappa':'\u039A','kappav':'\u03F0','kcedil':'\u0137','Kcedil':'\u0136','kcy':'\u043A','Kcy':'\u041A','kfr':'\uD835\uDD28','Kfr':'\uD835\uDD0E','kgreen':'\u0138','khcy':'\u0445','KHcy':'\u0425','kjcy':'\u045C','KJcy':'\u040C','kopf':'\uD835\uDD5C','Kopf':'\uD835\uDD42','kscr':'\uD835\uDCC0','Kscr':'\uD835\uDCA6','lAarr':'\u21DA','lacute':'\u013A','Lacute':'\u0139','laemptyv':'\u29B4','lagran':'\u2112','lambda':'\u03BB','Lambda':'\u039B','lang':'\u27E8','Lang':'\u27EA','langd':'\u2991','langle':'\u27E8','lap':'\u2A85','Laplacetrf':'\u2112','laquo':'\xAB','larr':'\u2190','lArr':'\u21D0','Larr':'\u219E','larrb':'\u21E4','larrbfs':'\u291F','larrfs':'\u291D','larrhk':'\u21A9','larrlp':'\u21AB','larrpl':'\u2939','larrsim':'\u2973','larrtl':'\u21A2','lat':'\u2AAB','latail':'\u2919','lAtail':'\u291B','late':'\u2AAD','lates':'\u2AAD\uFE00','lbarr':'\u290C','lBarr':'\u290E','lbbrk':'\u2772','lbrace':'{','lbrack':'[','lbrke':'\u298B','lbrksld':'\u298F','lbrkslu':'\u298D','lcaron':'\u013E','Lcaron':'\u013D','lcedil':'\u013C','Lcedil':'\u013B','lceil':'\u2308','lcub':'{','lcy':'\u043B','Lcy':'\u041B','ldca':'\u2936','ldquo':'\u201C','ldquor':'\u201E','ldrdhar':'\u2967','ldrushar':'\u294B','ldsh':'\u21B2','le':'\u2264','lE':'\u2266','LeftAngleBracket':'\u27E8','leftarrow':'\u2190','Leftarrow':'\u21D0','LeftArrow':'\u2190','LeftArrowBar':'\u21E4','LeftArrowRightArrow':'\u21C6','leftarrowtail':'\u21A2','LeftCeiling':'\u2308','LeftDoubleBracket':'\u27E6','LeftDownTeeVector':'\u2961','LeftDownVector':'\u21C3','LeftDownVectorBar':'\u2959','LeftFloor':'\u230A','leftharpoondown':'\u21BD','leftharpoonup':'\u21BC','leftleftarrows':'\u21C7','leftrightarrow':'\u2194','Leftrightarrow':'\u21D4','LeftRightArrow':'\u2194','leftrightarrows':'\u21C6','leftrightharpoons':'\u21CB','leftrightsquigarrow':'\u21AD','LeftRightVector':'\u294E','LeftTee':'\u22A3','LeftTeeArrow':'\u21A4','LeftTeeVector':'\u295A','leftthreetimes':'\u22CB','LeftTriangle':'\u22B2','LeftTriangleBar':'\u29CF','LeftTriangleEqual':'\u22B4','LeftUpDownVector':'\u2951','LeftUpTeeVector':'\u2960','LeftUpVector':'\u21BF','LeftUpVectorBar':'\u2958','LeftVector':'\u21BC','LeftVectorBar':'\u2952','leg':'\u22DA','lEg':'\u2A8B','leq':'\u2264','leqq':'\u2266','leqslant':'\u2A7D','les':'\u2A7D','lescc':'\u2AA8','lesdot':'\u2A7F','lesdoto':'\u2A81','lesdotor':'\u2A83','lesg':'\u22DA\uFE00','lesges':'\u2A93','lessapprox':'\u2A85','lessdot':'\u22D6','lesseqgtr':'\u22DA','lesseqqgtr':'\u2A8B','LessEqualGreater':'\u22DA','LessFullEqual':'\u2266','LessGreater':'\u2276','lessgtr':'\u2276','LessLess':'\u2AA1','lesssim':'\u2272','LessSlantEqual':'\u2A7D','LessTilde':'\u2272','lfisht':'\u297C','lfloor':'\u230A','lfr':'\uD835\uDD29','Lfr':'\uD835\uDD0F','lg':'\u2276','lgE':'\u2A91','lHar':'\u2962','lhard':'\u21BD','lharu':'\u21BC','lharul':'\u296A','lhblk':'\u2584','ljcy':'\u0459','LJcy':'\u0409','ll':'\u226A','Ll':'\u22D8','llarr':'\u21C7','llcorner':'\u231E','Lleftarrow':'\u21DA','llhard':'\u296B','lltri':'\u25FA','lmidot':'\u0140','Lmidot':'\u013F','lmoust':'\u23B0','lmoustache':'\u23B0','lnap':'\u2A89','lnapprox':'\u2A89','lne':'\u2A87','lnE':'\u2268','lneq':'\u2A87','lneqq':'\u2268','lnsim':'\u22E6','loang':'\u27EC','loarr':'\u21FD','lobrk':'\u27E6','longleftarrow':'\u27F5','Longleftarrow':'\u27F8','LongLeftArrow':'\u27F5','longleftrightarrow':'\u27F7','Longleftrightarrow':'\u27FA','LongLeftRightArrow':'\u27F7','longmapsto':'\u27FC','longrightarrow':'\u27F6','Longrightarrow':'\u27F9','LongRightArrow':'\u27F6','looparrowleft':'\u21AB','looparrowright':'\u21AC','lopar':'\u2985','lopf':'\uD835\uDD5D','Lopf':'\uD835\uDD43','loplus':'\u2A2D','lotimes':'\u2A34','lowast':'\u2217','lowbar':'_','LowerLeftArrow':'\u2199','LowerRightArrow':'\u2198','loz':'\u25CA','lozenge':'\u25CA','lozf':'\u29EB','lpar':'(','lparlt':'\u2993','lrarr':'\u21C6','lrcorner':'\u231F','lrhar':'\u21CB','lrhard':'\u296D','lrm':'\u200E','lrtri':'\u22BF','lsaquo':'\u2039','lscr':'\uD835\uDCC1','Lscr':'\u2112','lsh':'\u21B0','Lsh':'\u21B0','lsim':'\u2272','lsime':'\u2A8D','lsimg':'\u2A8F','lsqb':'[','lsquo':'\u2018','lsquor':'\u201A','lstrok':'\u0142','Lstrok':'\u0141','lt':'<','Lt':'\u226A','LT':'<','ltcc':'\u2AA6','ltcir':'\u2A79','ltdot':'\u22D6','lthree':'\u22CB','ltimes':'\u22C9','ltlarr':'\u2976','ltquest':'\u2A7B','ltri':'\u25C3','ltrie':'\u22B4','ltrif':'\u25C2','ltrPar':'\u2996','lurdshar':'\u294A','luruhar':'\u2966','lvertneqq':'\u2268\uFE00','lvnE':'\u2268\uFE00','macr':'\xAF','male':'\u2642','malt':'\u2720','maltese':'\u2720','map':'\u21A6','Map':'\u2905','mapsto':'\u21A6','mapstodown':'\u21A7','mapstoleft':'\u21A4','mapstoup':'\u21A5','marker':'\u25AE','mcomma':'\u2A29','mcy':'\u043C','Mcy':'\u041C','mdash':'\u2014','mDDot':'\u223A','measuredangle':'\u2221','MediumSpace':'\u205F','Mellintrf':'\u2133','mfr':'\uD835\uDD2A','Mfr':'\uD835\uDD10','mho':'\u2127','micro':'\xB5','mid':'\u2223','midast':'*','midcir':'\u2AF0','middot':'\xB7','minus':'\u2212','minusb':'\u229F','minusd':'\u2238','minusdu':'\u2A2A','MinusPlus':'\u2213','mlcp':'\u2ADB','mldr':'\u2026','mnplus':'\u2213','models':'\u22A7','mopf':'\uD835\uDD5E','Mopf':'\uD835\uDD44','mp':'\u2213','mscr':'\uD835\uDCC2','Mscr':'\u2133','mstpos':'\u223E','mu':'\u03BC','Mu':'\u039C','multimap':'\u22B8','mumap':'\u22B8','nabla':'\u2207','nacute':'\u0144','Nacute':'\u0143','nang':'\u2220\u20D2','nap':'\u2249','napE':'\u2A70\u0338','napid':'\u224B\u0338','napos':'\u0149','napprox':'\u2249','natur':'\u266E','natural':'\u266E','naturals':'\u2115','nbsp':'\xA0','nbump':'\u224E\u0338','nbumpe':'\u224F\u0338','ncap':'\u2A43','ncaron':'\u0148','Ncaron':'\u0147','ncedil':'\u0146','Ncedil':'\u0145','ncong':'\u2247','ncongdot':'\u2A6D\u0338','ncup':'\u2A42','ncy':'\u043D','Ncy':'\u041D','ndash':'\u2013','ne':'\u2260','nearhk':'\u2924','nearr':'\u2197','neArr':'\u21D7','nearrow':'\u2197','nedot':'\u2250\u0338','NegativeMediumSpace':'\u200B','NegativeThickSpace':'\u200B','NegativeThinSpace':'\u200B','NegativeVeryThinSpace':'\u200B','nequiv':'\u2262','nesear':'\u2928','nesim':'\u2242\u0338','NestedGreaterGreater':'\u226B','NestedLessLess':'\u226A','NewLine':'\n','nexist':'\u2204','nexists':'\u2204','nfr':'\uD835\uDD2B','Nfr':'\uD835\uDD11','nge':'\u2271','ngE':'\u2267\u0338','ngeq':'\u2271','ngeqq':'\u2267\u0338','ngeqslant':'\u2A7E\u0338','nges':'\u2A7E\u0338','nGg':'\u22D9\u0338','ngsim':'\u2275','ngt':'\u226F','nGt':'\u226B\u20D2','ngtr':'\u226F','nGtv':'\u226B\u0338','nharr':'\u21AE','nhArr':'\u21CE','nhpar':'\u2AF2','ni':'\u220B','nis':'\u22FC','nisd':'\u22FA','niv':'\u220B','njcy':'\u045A','NJcy':'\u040A','nlarr':'\u219A','nlArr':'\u21CD','nldr':'\u2025','nle':'\u2270','nlE':'\u2266\u0338','nleftarrow':'\u219A','nLeftarrow':'\u21CD','nleftrightarrow':'\u21AE','nLeftrightarrow':'\u21CE','nleq':'\u2270','nleqq':'\u2266\u0338','nleqslant':'\u2A7D\u0338','nles':'\u2A7D\u0338','nless':'\u226E','nLl':'\u22D8\u0338','nlsim':'\u2274','nlt':'\u226E','nLt':'\u226A\u20D2','nltri':'\u22EA','nltrie':'\u22EC','nLtv':'\u226A\u0338','nmid':'\u2224','NoBreak':'\u2060','NonBreakingSpace':'\xA0','nopf':'\uD835\uDD5F','Nopf':'\u2115','not':'\xAC','Not':'\u2AEC','NotCongruent':'\u2262','NotCupCap':'\u226D','NotDoubleVerticalBar':'\u2226','NotElement':'\u2209','NotEqual':'\u2260','NotEqualTilde':'\u2242\u0338','NotExists':'\u2204','NotGreater':'\u226F','NotGreaterEqual':'\u2271','NotGreaterFullEqual':'\u2267\u0338','NotGreaterGreater':'\u226B\u0338','NotGreaterLess':'\u2279','NotGreaterSlantEqual':'\u2A7E\u0338','NotGreaterTilde':'\u2275','NotHumpDownHump':'\u224E\u0338','NotHumpEqual':'\u224F\u0338','notin':'\u2209','notindot':'\u22F5\u0338','notinE':'\u22F9\u0338','notinva':'\u2209','notinvb':'\u22F7','notinvc':'\u22F6','NotLeftTriangle':'\u22EA','NotLeftTriangleBar':'\u29CF\u0338','NotLeftTriangleEqual':'\u22EC','NotLess':'\u226E','NotLessEqual':'\u2270','NotLessGreater':'\u2278','NotLessLess':'\u226A\u0338','NotLessSlantEqual':'\u2A7D\u0338','NotLessTilde':'\u2274','NotNestedGreaterGreater':'\u2AA2\u0338','NotNestedLessLess':'\u2AA1\u0338','notni':'\u220C','notniva':'\u220C','notnivb':'\u22FE','notnivc':'\u22FD','NotPrecedes':'\u2280','NotPrecedesEqual':'\u2AAF\u0338','NotPrecedesSlantEqual':'\u22E0','NotReverseElement':'\u220C','NotRightTriangle':'\u22EB','NotRightTriangleBar':'\u29D0\u0338','NotRightTriangleEqual':'\u22ED','NotSquareSubset':'\u228F\u0338','NotSquareSubsetEqual':'\u22E2','NotSquareSuperset':'\u2290\u0338','NotSquareSupersetEqual':'\u22E3','NotSubset':'\u2282\u20D2','NotSubsetEqual':'\u2288','NotSucceeds':'\u2281','NotSucceedsEqual':'\u2AB0\u0338','NotSucceedsSlantEqual':'\u22E1','NotSucceedsTilde':'\u227F\u0338','NotSuperset':'\u2283\u20D2','NotSupersetEqual':'\u2289','NotTilde':'\u2241','NotTildeEqual':'\u2244','NotTildeFullEqual':'\u2247','NotTildeTilde':'\u2249','NotVerticalBar':'\u2224','npar':'\u2226','nparallel':'\u2226','nparsl':'\u2AFD\u20E5','npart':'\u2202\u0338','npolint':'\u2A14','npr':'\u2280','nprcue':'\u22E0','npre':'\u2AAF\u0338','nprec':'\u2280','npreceq':'\u2AAF\u0338','nrarr':'\u219B','nrArr':'\u21CF','nrarrc':'\u2933\u0338','nrarrw':'\u219D\u0338','nrightarrow':'\u219B','nRightarrow':'\u21CF','nrtri':'\u22EB','nrtrie':'\u22ED','nsc':'\u2281','nsccue':'\u22E1','nsce':'\u2AB0\u0338','nscr':'\uD835\uDCC3','Nscr':'\uD835\uDCA9','nshortmid':'\u2224','nshortparallel':'\u2226','nsim':'\u2241','nsime':'\u2244','nsimeq':'\u2244','nsmid':'\u2224','nspar':'\u2226','nsqsube':'\u22E2','nsqsupe':'\u22E3','nsub':'\u2284','nsube':'\u2288','nsubE':'\u2AC5\u0338','nsubset':'\u2282\u20D2','nsubseteq':'\u2288','nsubseteqq':'\u2AC5\u0338','nsucc':'\u2281','nsucceq':'\u2AB0\u0338','nsup':'\u2285','nsupe':'\u2289','nsupE':'\u2AC6\u0338','nsupset':'\u2283\u20D2','nsupseteq':'\u2289','nsupseteqq':'\u2AC6\u0338','ntgl':'\u2279','ntilde':'\xF1','Ntilde':'\xD1','ntlg':'\u2278','ntriangleleft':'\u22EA','ntrianglelefteq':'\u22EC','ntriangleright':'\u22EB','ntrianglerighteq':'\u22ED','nu':'\u03BD','Nu':'\u039D','num':'#','numero':'\u2116','numsp':'\u2007','nvap':'\u224D\u20D2','nvdash':'\u22AC','nvDash':'\u22AD','nVdash':'\u22AE','nVDash':'\u22AF','nvge':'\u2265\u20D2','nvgt':'>\u20D2','nvHarr':'\u2904','nvinfin':'\u29DE','nvlArr':'\u2902','nvle':'\u2264\u20D2','nvlt':'<\u20D2','nvltrie':'\u22B4\u20D2','nvrArr':'\u2903','nvrtrie':'\u22B5\u20D2','nvsim':'\u223C\u20D2','nwarhk':'\u2923','nwarr':'\u2196','nwArr':'\u21D6','nwarrow':'\u2196','nwnear':'\u2927','oacute':'\xF3','Oacute':'\xD3','oast':'\u229B','ocir':'\u229A','ocirc':'\xF4','Ocirc':'\xD4','ocy':'\u043E','Ocy':'\u041E','odash':'\u229D','odblac':'\u0151','Odblac':'\u0150','odiv':'\u2A38','odot':'\u2299','odsold':'\u29BC','oelig':'\u0153','OElig':'\u0152','ofcir':'\u29BF','ofr':'\uD835\uDD2C','Ofr':'\uD835\uDD12','ogon':'\u02DB','ograve':'\xF2','Ograve':'\xD2','ogt':'\u29C1','ohbar':'\u29B5','ohm':'\u03A9','oint':'\u222E','olarr':'\u21BA','olcir':'\u29BE','olcross':'\u29BB','oline':'\u203E','olt':'\u29C0','omacr':'\u014D','Omacr':'\u014C','omega':'\u03C9','Omega':'\u03A9','omicron':'\u03BF','Omicron':'\u039F','omid':'\u29B6','ominus':'\u2296','oopf':'\uD835\uDD60','Oopf':'\uD835\uDD46','opar':'\u29B7','OpenCurlyDoubleQuote':'\u201C','OpenCurlyQuote':'\u2018','operp':'\u29B9','oplus':'\u2295','or':'\u2228','Or':'\u2A54','orarr':'\u21BB','ord':'\u2A5D','order':'\u2134','orderof':'\u2134','ordf':'\xAA','ordm':'\xBA','origof':'\u22B6','oror':'\u2A56','orslope':'\u2A57','orv':'\u2A5B','oS':'\u24C8','oscr':'\u2134','Oscr':'\uD835\uDCAA','oslash':'\xF8','Oslash':'\xD8','osol':'\u2298','otilde':'\xF5','Otilde':'\xD5','otimes':'\u2297','Otimes':'\u2A37','otimesas':'\u2A36','ouml':'\xF6','Ouml':'\xD6','ovbar':'\u233D','OverBar':'\u203E','OverBrace':'\u23DE','OverBracket':'\u23B4','OverParenthesis':'\u23DC','par':'\u2225','para':'\xB6','parallel':'\u2225','parsim':'\u2AF3','parsl':'\u2AFD','part':'\u2202','PartialD':'\u2202','pcy':'\u043F','Pcy':'\u041F','percnt':'%','period':'.','permil':'\u2030','perp':'\u22A5','pertenk':'\u2031','pfr':'\uD835\uDD2D','Pfr':'\uD835\uDD13','phi':'\u03C6','Phi':'\u03A6','phiv':'\u03D5','phmmat':'\u2133','phone':'\u260E','pi':'\u03C0','Pi':'\u03A0','pitchfork':'\u22D4','piv':'\u03D6','planck':'\u210F','planckh':'\u210E','plankv':'\u210F','plus':'+','plusacir':'\u2A23','plusb':'\u229E','pluscir':'\u2A22','plusdo':'\u2214','plusdu':'\u2A25','pluse':'\u2A72','PlusMinus':'\xB1','plusmn':'\xB1','plussim':'\u2A26','plustwo':'\u2A27','pm':'\xB1','Poincareplane':'\u210C','pointint':'\u2A15','popf':'\uD835\uDD61','Popf':'\u2119','pound':'\xA3','pr':'\u227A','Pr':'\u2ABB','prap':'\u2AB7','prcue':'\u227C','pre':'\u2AAF','prE':'\u2AB3','prec':'\u227A','precapprox':'\u2AB7','preccurlyeq':'\u227C','Precedes':'\u227A','PrecedesEqual':'\u2AAF','PrecedesSlantEqual':'\u227C','PrecedesTilde':'\u227E','preceq':'\u2AAF','precnapprox':'\u2AB9','precneqq':'\u2AB5','precnsim':'\u22E8','precsim':'\u227E','prime':'\u2032','Prime':'\u2033','primes':'\u2119','prnap':'\u2AB9','prnE':'\u2AB5','prnsim':'\u22E8','prod':'\u220F','Product':'\u220F','profalar':'\u232E','profline':'\u2312','profsurf':'\u2313','prop':'\u221D','Proportion':'\u2237','Proportional':'\u221D','propto':'\u221D','prsim':'\u227E','prurel':'\u22B0','pscr':'\uD835\uDCC5','Pscr':'\uD835\uDCAB','psi':'\u03C8','Psi':'\u03A8','puncsp':'\u2008','qfr':'\uD835\uDD2E','Qfr':'\uD835\uDD14','qint':'\u2A0C','qopf':'\uD835\uDD62','Qopf':'\u211A','qprime':'\u2057','qscr':'\uD835\uDCC6','Qscr':'\uD835\uDCAC','quaternions':'\u210D','quatint':'\u2A16','quest':'?','questeq':'\u225F','quot':'"','QUOT':'"','rAarr':'\u21DB','race':'\u223D\u0331','racute':'\u0155','Racute':'\u0154','radic':'\u221A','raemptyv':'\u29B3','rang':'\u27E9','Rang':'\u27EB','rangd':'\u2992','range':'\u29A5','rangle':'\u27E9','raquo':'\xBB','rarr':'\u2192','rArr':'\u21D2','Rarr':'\u21A0','rarrap':'\u2975','rarrb':'\u21E5','rarrbfs':'\u2920','rarrc':'\u2933','rarrfs':'\u291E','rarrhk':'\u21AA','rarrlp':'\u21AC','rarrpl':'\u2945','rarrsim':'\u2974','rarrtl':'\u21A3','Rarrtl':'\u2916','rarrw':'\u219D','ratail':'\u291A','rAtail':'\u291C','ratio':'\u2236','rationals':'\u211A','rbarr':'\u290D','rBarr':'\u290F','RBarr':'\u2910','rbbrk':'\u2773','rbrace':'}','rbrack':']','rbrke':'\u298C','rbrksld':'\u298E','rbrkslu':'\u2990','rcaron':'\u0159','Rcaron':'\u0158','rcedil':'\u0157','Rcedil':'\u0156','rceil':'\u2309','rcub':'}','rcy':'\u0440','Rcy':'\u0420','rdca':'\u2937','rdldhar':'\u2969','rdquo':'\u201D','rdquor':'\u201D','rdsh':'\u21B3','Re':'\u211C','real':'\u211C','realine':'\u211B','realpart':'\u211C','reals':'\u211D','rect':'\u25AD','reg':'\xAE','REG':'\xAE','ReverseElement':'\u220B','ReverseEquilibrium':'\u21CB','ReverseUpEquilibrium':'\u296F','rfisht':'\u297D','rfloor':'\u230B','rfr':'\uD835\uDD2F','Rfr':'\u211C','rHar':'\u2964','rhard':'\u21C1','rharu':'\u21C0','rharul':'\u296C','rho':'\u03C1','Rho':'\u03A1','rhov':'\u03F1','RightAngleBracket':'\u27E9','rightarrow':'\u2192','Rightarrow':'\u21D2','RightArrow':'\u2192','RightArrowBar':'\u21E5','RightArrowLeftArrow':'\u21C4','rightarrowtail':'\u21A3','RightCeiling':'\u2309','RightDoubleBracket':'\u27E7','RightDownTeeVector':'\u295D','RightDownVector':'\u21C2','RightDownVectorBar':'\u2955','RightFloor':'\u230B','rightharpoondown':'\u21C1','rightharpoonup':'\u21C0','rightleftarrows':'\u21C4','rightleftharpoons':'\u21CC','rightrightarrows':'\u21C9','rightsquigarrow':'\u219D','RightTee':'\u22A2','RightTeeArrow':'\u21A6','RightTeeVector':'\u295B','rightthreetimes':'\u22CC','RightTriangle':'\u22B3','RightTriangleBar':'\u29D0','RightTriangleEqual':'\u22B5','RightUpDownVector':'\u294F','RightUpTeeVector':'\u295C','RightUpVector':'\u21BE','RightUpVectorBar':'\u2954','RightVector':'\u21C0','RightVectorBar':'\u2953','ring':'\u02DA','risingdotseq':'\u2253','rlarr':'\u21C4','rlhar':'\u21CC','rlm':'\u200F','rmoust':'\u23B1','rmoustache':'\u23B1','rnmid':'\u2AEE','roang':'\u27ED','roarr':'\u21FE','robrk':'\u27E7','ropar':'\u2986','ropf':'\uD835\uDD63','Ropf':'\u211D','roplus':'\u2A2E','rotimes':'\u2A35','RoundImplies':'\u2970','rpar':')','rpargt':'\u2994','rppolint':'\u2A12','rrarr':'\u21C9','Rrightarrow':'\u21DB','rsaquo':'\u203A','rscr':'\uD835\uDCC7','Rscr':'\u211B','rsh':'\u21B1','Rsh':'\u21B1','rsqb':']','rsquo':'\u2019','rsquor':'\u2019','rthree':'\u22CC','rtimes':'\u22CA','rtri':'\u25B9','rtrie':'\u22B5','rtrif':'\u25B8','rtriltri':'\u29CE','RuleDelayed':'\u29F4','ruluhar':'\u2968','rx':'\u211E','sacute':'\u015B','Sacute':'\u015A','sbquo':'\u201A','sc':'\u227B','Sc':'\u2ABC','scap':'\u2AB8','scaron':'\u0161','Scaron':'\u0160','sccue':'\u227D','sce':'\u2AB0','scE':'\u2AB4','scedil':'\u015F','Scedil':'\u015E','scirc':'\u015D','Scirc':'\u015C','scnap':'\u2ABA','scnE':'\u2AB6','scnsim':'\u22E9','scpolint':'\u2A13','scsim':'\u227F','scy':'\u0441','Scy':'\u0421','sdot':'\u22C5','sdotb':'\u22A1','sdote':'\u2A66','searhk':'\u2925','searr':'\u2198','seArr':'\u21D8','searrow':'\u2198','sect':'\xA7','semi':';','seswar':'\u2929','setminus':'\u2216','setmn':'\u2216','sext':'\u2736','sfr':'\uD835\uDD30','Sfr':'\uD835\uDD16','sfrown':'\u2322','sharp':'\u266F','shchcy':'\u0449','SHCHcy':'\u0429','shcy':'\u0448','SHcy':'\u0428','ShortDownArrow':'\u2193','ShortLeftArrow':'\u2190','shortmid':'\u2223','shortparallel':'\u2225','ShortRightArrow':'\u2192','ShortUpArrow':'\u2191','shy':'\xAD','sigma':'\u03C3','Sigma':'\u03A3','sigmaf':'\u03C2','sigmav':'\u03C2','sim':'\u223C','simdot':'\u2A6A','sime':'\u2243','simeq':'\u2243','simg':'\u2A9E','simgE':'\u2AA0','siml':'\u2A9D','simlE':'\u2A9F','simne':'\u2246','simplus':'\u2A24','simrarr':'\u2972','slarr':'\u2190','SmallCircle':'\u2218','smallsetminus':'\u2216','smashp':'\u2A33','smeparsl':'\u29E4','smid':'\u2223','smile':'\u2323','smt':'\u2AAA','smte':'\u2AAC','smtes':'\u2AAC\uFE00','softcy':'\u044C','SOFTcy':'\u042C','sol':'/','solb':'\u29C4','solbar':'\u233F','sopf':'\uD835\uDD64','Sopf':'\uD835\uDD4A','spades':'\u2660','spadesuit':'\u2660','spar':'\u2225','sqcap':'\u2293','sqcaps':'\u2293\uFE00','sqcup':'\u2294','sqcups':'\u2294\uFE00','Sqrt':'\u221A','sqsub':'\u228F','sqsube':'\u2291','sqsubset':'\u228F','sqsubseteq':'\u2291','sqsup':'\u2290','sqsupe':'\u2292','sqsupset':'\u2290','sqsupseteq':'\u2292','squ':'\u25A1','square':'\u25A1','Square':'\u25A1','SquareIntersection':'\u2293','SquareSubset':'\u228F','SquareSubsetEqual':'\u2291','SquareSuperset':'\u2290','SquareSupersetEqual':'\u2292','SquareUnion':'\u2294','squarf':'\u25AA','squf':'\u25AA','srarr':'\u2192','sscr':'\uD835\uDCC8','Sscr':'\uD835\uDCAE','ssetmn':'\u2216','ssmile':'\u2323','sstarf':'\u22C6','star':'\u2606','Star':'\u22C6','starf':'\u2605','straightepsilon':'\u03F5','straightphi':'\u03D5','strns':'\xAF','sub':'\u2282','Sub':'\u22D0','subdot':'\u2ABD','sube':'\u2286','subE':'\u2AC5','subedot':'\u2AC3','submult':'\u2AC1','subne':'\u228A','subnE':'\u2ACB','subplus':'\u2ABF','subrarr':'\u2979','subset':'\u2282','Subset':'\u22D0','subseteq':'\u2286','subseteqq':'\u2AC5','SubsetEqual':'\u2286','subsetneq':'\u228A','subsetneqq':'\u2ACB','subsim':'\u2AC7','subsub':'\u2AD5','subsup':'\u2AD3','succ':'\u227B','succapprox':'\u2AB8','succcurlyeq':'\u227D','Succeeds':'\u227B','SucceedsEqual':'\u2AB0','SucceedsSlantEqual':'\u227D','SucceedsTilde':'\u227F','succeq':'\u2AB0','succnapprox':'\u2ABA','succneqq':'\u2AB6','succnsim':'\u22E9','succsim':'\u227F','SuchThat':'\u220B','sum':'\u2211','Sum':'\u2211','sung':'\u266A','sup':'\u2283','Sup':'\u22D1','sup1':'\xB9','sup2':'\xB2','sup3':'\xB3','supdot':'\u2ABE','supdsub':'\u2AD8','supe':'\u2287','supE':'\u2AC6','supedot':'\u2AC4','Superset':'\u2283','SupersetEqual':'\u2287','suphsol':'\u27C9','suphsub':'\u2AD7','suplarr':'\u297B','supmult':'\u2AC2','supne':'\u228B','supnE':'\u2ACC','supplus':'\u2AC0','supset':'\u2283','Supset':'\u22D1','supseteq':'\u2287','supseteqq':'\u2AC6','supsetneq':'\u228B','supsetneqq':'\u2ACC','supsim':'\u2AC8','supsub':'\u2AD4','supsup':'\u2AD6','swarhk':'\u2926','swarr':'\u2199','swArr':'\u21D9','swarrow':'\u2199','swnwar':'\u292A','szlig':'\xDF','Tab':'\t','target':'\u2316','tau':'\u03C4','Tau':'\u03A4','tbrk':'\u23B4','tcaron':'\u0165','Tcaron':'\u0164','tcedil':'\u0163','Tcedil':'\u0162','tcy':'\u0442','Tcy':'\u0422','tdot':'\u20DB','telrec':'\u2315','tfr':'\uD835\uDD31','Tfr':'\uD835\uDD17','there4':'\u2234','therefore':'\u2234','Therefore':'\u2234','theta':'\u03B8','Theta':'\u0398','thetasym':'\u03D1','thetav':'\u03D1','thickapprox':'\u2248','thicksim':'\u223C','ThickSpace':'\u205F\u200A','thinsp':'\u2009','ThinSpace':'\u2009','thkap':'\u2248','thksim':'\u223C','thorn':'\xFE','THORN':'\xDE','tilde':'\u02DC','Tilde':'\u223C','TildeEqual':'\u2243','TildeFullEqual':'\u2245','TildeTilde':'\u2248','times':'\xD7','timesb':'\u22A0','timesbar':'\u2A31','timesd':'\u2A30','tint':'\u222D','toea':'\u2928','top':'\u22A4','topbot':'\u2336','topcir':'\u2AF1','topf':'\uD835\uDD65','Topf':'\uD835\uDD4B','topfork':'\u2ADA','tosa':'\u2929','tprime':'\u2034','trade':'\u2122','TRADE':'\u2122','triangle':'\u25B5','triangledown':'\u25BF','triangleleft':'\u25C3','trianglelefteq':'\u22B4','triangleq':'\u225C','triangleright':'\u25B9','trianglerighteq':'\u22B5','tridot':'\u25EC','trie':'\u225C','triminus':'\u2A3A','TripleDot':'\u20DB','triplus':'\u2A39','trisb':'\u29CD','tritime':'\u2A3B','trpezium':'\u23E2','tscr':'\uD835\uDCC9','Tscr':'\uD835\uDCAF','tscy':'\u0446','TScy':'\u0426','tshcy':'\u045B','TSHcy':'\u040B','tstrok':'\u0167','Tstrok':'\u0166','twixt':'\u226C','twoheadleftarrow':'\u219E','twoheadrightarrow':'\u21A0','uacute':'\xFA','Uacute':'\xDA','uarr':'\u2191','uArr':'\u21D1','Uarr':'\u219F','Uarrocir':'\u2949','ubrcy':'\u045E','Ubrcy':'\u040E','ubreve':'\u016D','Ubreve':'\u016C','ucirc':'\xFB','Ucirc':'\xDB','ucy':'\u0443','Ucy':'\u0423','udarr':'\u21C5','udblac':'\u0171','Udblac':'\u0170','udhar':'\u296E','ufisht':'\u297E','ufr':'\uD835\uDD32','Ufr':'\uD835\uDD18','ugrave':'\xF9','Ugrave':'\xD9','uHar':'\u2963','uharl':'\u21BF','uharr':'\u21BE','uhblk':'\u2580','ulcorn':'\u231C','ulcorner':'\u231C','ulcrop':'\u230F','ultri':'\u25F8','umacr':'\u016B','Umacr':'\u016A','uml':'\xA8','UnderBar':'_','UnderBrace':'\u23DF','UnderBracket':'\u23B5','UnderParenthesis':'\u23DD','Union':'\u22C3','UnionPlus':'\u228E','uogon':'\u0173','Uogon':'\u0172','uopf':'\uD835\uDD66','Uopf':'\uD835\uDD4C','uparrow':'\u2191','Uparrow':'\u21D1','UpArrow':'\u2191','UpArrowBar':'\u2912','UpArrowDownArrow':'\u21C5','updownarrow':'\u2195','Updownarrow':'\u21D5','UpDownArrow':'\u2195','UpEquilibrium':'\u296E','upharpoonleft':'\u21BF','upharpoonright':'\u21BE','uplus':'\u228E','UpperLeftArrow':'\u2196','UpperRightArrow':'\u2197','upsi':'\u03C5','Upsi':'\u03D2','upsih':'\u03D2','upsilon':'\u03C5','Upsilon':'\u03A5','UpTee':'\u22A5','UpTeeArrow':'\u21A5','upuparrows':'\u21C8','urcorn':'\u231D','urcorner':'\u231D','urcrop':'\u230E','uring':'\u016F','Uring':'\u016E','urtri':'\u25F9','uscr':'\uD835\uDCCA','Uscr':'\uD835\uDCB0','utdot':'\u22F0','utilde':'\u0169','Utilde':'\u0168','utri':'\u25B5','utrif':'\u25B4','uuarr':'\u21C8','uuml':'\xFC','Uuml':'\xDC','uwangle':'\u29A7','vangrt':'\u299C','varepsilon':'\u03F5','varkappa':'\u03F0','varnothing':'\u2205','varphi':'\u03D5','varpi':'\u03D6','varpropto':'\u221D','varr':'\u2195','vArr':'\u21D5','varrho':'\u03F1','varsigma':'\u03C2','varsubsetneq':'\u228A\uFE00','varsubsetneqq':'\u2ACB\uFE00','varsupsetneq':'\u228B\uFE00','varsupsetneqq':'\u2ACC\uFE00','vartheta':'\u03D1','vartriangleleft':'\u22B2','vartriangleright':'\u22B3','vBar':'\u2AE8','Vbar':'\u2AEB','vBarv':'\u2AE9','vcy':'\u0432','Vcy':'\u0412','vdash':'\u22A2','vDash':'\u22A8','Vdash':'\u22A9','VDash':'\u22AB','Vdashl':'\u2AE6','vee':'\u2228','Vee':'\u22C1','veebar':'\u22BB','veeeq':'\u225A','vellip':'\u22EE','verbar':'|','Verbar':'\u2016','vert':'|','Vert':'\u2016','VerticalBar':'\u2223','VerticalLine':'|','VerticalSeparator':'\u2758','VerticalTilde':'\u2240','VeryThinSpace':'\u200A','vfr':'\uD835\uDD33','Vfr':'\uD835\uDD19','vltri':'\u22B2','vnsub':'\u2282\u20D2','vnsup':'\u2283\u20D2','vopf':'\uD835\uDD67','Vopf':'\uD835\uDD4D','vprop':'\u221D','vrtri':'\u22B3','vscr':'\uD835\uDCCB','Vscr':'\uD835\uDCB1','vsubne':'\u228A\uFE00','vsubnE':'\u2ACB\uFE00','vsupne':'\u228B\uFE00','vsupnE':'\u2ACC\uFE00','Vvdash':'\u22AA','vzigzag':'\u299A','wcirc':'\u0175','Wcirc':'\u0174','wedbar':'\u2A5F','wedge':'\u2227','Wedge':'\u22C0','wedgeq':'\u2259','weierp':'\u2118','wfr':'\uD835\uDD34','Wfr':'\uD835\uDD1A','wopf':'\uD835\uDD68','Wopf':'\uD835\uDD4E','wp':'\u2118','wr':'\u2240','wreath':'\u2240','wscr':'\uD835\uDCCC','Wscr':'\uD835\uDCB2','xcap':'\u22C2','xcirc':'\u25EF','xcup':'\u22C3','xdtri':'\u25BD','xfr':'\uD835\uDD35','Xfr':'\uD835\uDD1B','xharr':'\u27F7','xhArr':'\u27FA','xi':'\u03BE','Xi':'\u039E','xlarr':'\u27F5','xlArr':'\u27F8','xmap':'\u27FC','xnis':'\u22FB','xodot':'\u2A00','xopf':'\uD835\uDD69','Xopf':'\uD835\uDD4F','xoplus':'\u2A01','xotime':'\u2A02','xrarr':'\u27F6','xrArr':'\u27F9','xscr':'\uD835\uDCCD','Xscr':'\uD835\uDCB3','xsqcup':'\u2A06','xuplus':'\u2A04','xutri':'\u25B3','xvee':'\u22C1','xwedge':'\u22C0','yacute':'\xFD','Yacute':'\xDD','yacy':'\u044F','YAcy':'\u042F','ycirc':'\u0177','Ycirc':'\u0176','ycy':'\u044B','Ycy':'\u042B','yen':'\xA5','yfr':'\uD835\uDD36','Yfr':'\uD835\uDD1C','yicy':'\u0457','YIcy':'\u0407','yopf':'\uD835\uDD6A','Yopf':'\uD835\uDD50','yscr':'\uD835\uDCCE','Yscr':'\uD835\uDCB4','yucy':'\u044E','YUcy':'\u042E','yuml':'\xFF','Yuml':'\u0178','zacute':'\u017A','Zacute':'\u0179','zcaron':'\u017E','Zcaron':'\u017D','zcy':'\u0437','Zcy':'\u0417','zdot':'\u017C','Zdot':'\u017B','zeetrf':'\u2128','ZeroWidthSpace':'\u200B','zeta':'\u03B6','Zeta':'\u0396','zfr':'\uD835\uDD37','Zfr':'\u2128','zhcy':'\u0436','ZHcy':'\u0416','zigrarr':'\u21DD','zopf':'\uD835\uDD6B','Zopf':'\u2124','zscr':'\uD835\uDCCF','Zscr':'\uD835\uDCB5','zwj':'\u200D','zwnj':'\u200C'};
    	var decodeMapLegacy = {'aacute':'\xE1','Aacute':'\xC1','acirc':'\xE2','Acirc':'\xC2','acute':'\xB4','aelig':'\xE6','AElig':'\xC6','agrave':'\xE0','Agrave':'\xC0','amp':'&','AMP':'&','aring':'\xE5','Aring':'\xC5','atilde':'\xE3','Atilde':'\xC3','auml':'\xE4','Auml':'\xC4','brvbar':'\xA6','ccedil':'\xE7','Ccedil':'\xC7','cedil':'\xB8','cent':'\xA2','copy':'\xA9','COPY':'\xA9','curren':'\xA4','deg':'\xB0','divide':'\xF7','eacute':'\xE9','Eacute':'\xC9','ecirc':'\xEA','Ecirc':'\xCA','egrave':'\xE8','Egrave':'\xC8','eth':'\xF0','ETH':'\xD0','euml':'\xEB','Euml':'\xCB','frac12':'\xBD','frac14':'\xBC','frac34':'\xBE','gt':'>','GT':'>','iacute':'\xED','Iacute':'\xCD','icirc':'\xEE','Icirc':'\xCE','iexcl':'\xA1','igrave':'\xEC','Igrave':'\xCC','iquest':'\xBF','iuml':'\xEF','Iuml':'\xCF','laquo':'\xAB','lt':'<','LT':'<','macr':'\xAF','micro':'\xB5','middot':'\xB7','nbsp':'\xA0','not':'\xAC','ntilde':'\xF1','Ntilde':'\xD1','oacute':'\xF3','Oacute':'\xD3','ocirc':'\xF4','Ocirc':'\xD4','ograve':'\xF2','Ograve':'\xD2','ordf':'\xAA','ordm':'\xBA','oslash':'\xF8','Oslash':'\xD8','otilde':'\xF5','Otilde':'\xD5','ouml':'\xF6','Ouml':'\xD6','para':'\xB6','plusmn':'\xB1','pound':'\xA3','quot':'"','QUOT':'"','raquo':'\xBB','reg':'\xAE','REG':'\xAE','sect':'\xA7','shy':'\xAD','sup1':'\xB9','sup2':'\xB2','sup3':'\xB3','szlig':'\xDF','thorn':'\xFE','THORN':'\xDE','times':'\xD7','uacute':'\xFA','Uacute':'\xDA','ucirc':'\xFB','Ucirc':'\xDB','ugrave':'\xF9','Ugrave':'\xD9','uml':'\xA8','uuml':'\xFC','Uuml':'\xDC','yacute':'\xFD','Yacute':'\xDD','yen':'\xA5','yuml':'\xFF'};
    	var decodeMapNumeric = {'0':'\uFFFD','128':'\u20AC','130':'\u201A','131':'\u0192','132':'\u201E','133':'\u2026','134':'\u2020','135':'\u2021','136':'\u02C6','137':'\u2030','138':'\u0160','139':'\u2039','140':'\u0152','142':'\u017D','145':'\u2018','146':'\u2019','147':'\u201C','148':'\u201D','149':'\u2022','150':'\u2013','151':'\u2014','152':'\u02DC','153':'\u2122','154':'\u0161','155':'\u203A','156':'\u0153','158':'\u017E','159':'\u0178'};
    	var invalidReferenceCodePoints = [1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65000,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];

    	/*--------------------------------------------------------------------------*/

    	var stringFromCharCode = String.fromCharCode;

    	var object = {};
    	var hasOwnProperty = object.hasOwnProperty;
    	var has = function(object, propertyName) {
    		return hasOwnProperty.call(object, propertyName);
    	};

    	var contains = function(array, value) {
    		var index = -1;
    		var length = array.length;
    		while (++index < length) {
    			if (array[index] == value) {
    				return true;
    			}
    		}
    		return false;
    	};

    	var merge = function(options, defaults) {
    		if (!options) {
    			return defaults;
    		}
    		var result = {};
    		var key;
    		for (key in defaults) {
    			// A `hasOwnProperty` check is not needed here, since only recognized
    			// option names are used anyway. Any others are ignored.
    			result[key] = has(options, key) ? options[key] : defaults[key];
    		}
    		return result;
    	};

    	// Modified version of `ucs2encode`; see https://mths.be/punycode.
    	var codePointToSymbol = function(codePoint, strict) {
    		var output = '';
    		if ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {
    			// See issue #4:
    			// “Otherwise, if the number is in the range 0xD800 to 0xDFFF or is
    			// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD
    			// REPLACEMENT CHARACTER.”
    			if (strict) {
    				parseError('character reference outside the permissible Unicode range');
    			}
    			return '\uFFFD';
    		}
    		if (has(decodeMapNumeric, codePoint)) {
    			if (strict) {
    				parseError('disallowed character reference');
    			}
    			return decodeMapNumeric[codePoint];
    		}
    		if (strict && contains(invalidReferenceCodePoints, codePoint)) {
    			parseError('disallowed character reference');
    		}
    		if (codePoint > 0xFFFF) {
    			codePoint -= 0x10000;
    			output += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
    			codePoint = 0xDC00 | codePoint & 0x3FF;
    		}
    		output += stringFromCharCode(codePoint);
    		return output;
    	};

    	var hexEscape = function(codePoint) {
    		return '&#x' + codePoint.toString(16).toUpperCase() + ';';
    	};

    	var decEscape = function(codePoint) {
    		return '&#' + codePoint + ';';
    	};

    	var parseError = function(message) {
    		throw Error('Parse error: ' + message);
    	};

    	/*--------------------------------------------------------------------------*/

    	var encode = function(string, options) {
    		options = merge(options, encode.options);
    		var strict = options.strict;
    		if (strict && regexInvalidRawCodePoint.test(string)) {
    			parseError('forbidden code point');
    		}
    		var encodeEverything = options.encodeEverything;
    		var useNamedReferences = options.useNamedReferences;
    		var allowUnsafeSymbols = options.allowUnsafeSymbols;
    		var escapeCodePoint = options.decimal ? decEscape : hexEscape;

    		var escapeBmpSymbol = function(symbol) {
    			return escapeCodePoint(symbol.charCodeAt(0));
    		};

    		if (encodeEverything) {
    			// Encode ASCII symbols.
    			string = string.replace(regexAsciiWhitelist, function(symbol) {
    				// Use named references if requested & possible.
    				if (useNamedReferences && has(encodeMap, symbol)) {
    					return '&' + encodeMap[symbol] + ';';
    				}
    				return escapeBmpSymbol(symbol);
    			});
    			// Shorten a few escapes that represent two symbols, of which at least one
    			// is within the ASCII range.
    			if (useNamedReferences) {
    				string = string
    					.replace(/&gt;\u20D2/g, '&nvgt;')
    					.replace(/&lt;\u20D2/g, '&nvlt;')
    					.replace(/&#x66;&#x6A;/g, '&fjlig;');
    			}
    			// Encode non-ASCII symbols.
    			if (useNamedReferences) {
    				// Encode non-ASCII symbols that can be replaced with a named reference.
    				string = string.replace(regexEncodeNonAscii, function(string) {
    					// Note: there is no need to check `has(encodeMap, string)` here.
    					return '&' + encodeMap[string] + ';';
    				});
    			}
    			// Note: any remaining non-ASCII symbols are handled outside of the `if`.
    		} else if (useNamedReferences) {
    			// Apply named character references.
    			// Encode `<>"'&` using named character references.
    			if (!allowUnsafeSymbols) {
    				string = string.replace(regexEscape, function(string) {
    					return '&' + encodeMap[string] + ';'; // no need to check `has()` here
    				});
    			}
    			// Shorten escapes that represent two symbols, of which at least one is
    			// `<>"'&`.
    			string = string
    				.replace(/&gt;\u20D2/g, '&nvgt;')
    				.replace(/&lt;\u20D2/g, '&nvlt;');
    			// Encode non-ASCII symbols that can be replaced with a named reference.
    			string = string.replace(regexEncodeNonAscii, function(string) {
    				// Note: there is no need to check `has(encodeMap, string)` here.
    				return '&' + encodeMap[string] + ';';
    			});
    		} else if (!allowUnsafeSymbols) {
    			// Encode `<>"'&` using hexadecimal escapes, now that they’re not handled
    			// using named character references.
    			string = string.replace(regexEscape, escapeBmpSymbol);
    		}
    		return string
    			// Encode astral symbols.
    			.replace(regexAstralSymbols, function($0) {
    				// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    				var high = $0.charCodeAt(0);
    				var low = $0.charCodeAt(1);
    				var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
    				return escapeCodePoint(codePoint);
    			})
    			// Encode any remaining BMP symbols that are not printable ASCII symbols
    			// using a hexadecimal escape.
    			.replace(regexBmpWhitelist, escapeBmpSymbol);
    	};
    	// Expose default options (so they can be overridden globally).
    	encode.options = {
    		'allowUnsafeSymbols': false,
    		'encodeEverything': false,
    		'strict': false,
    		'useNamedReferences': false,
    		'decimal' : false
    	};

    	var decode = function(html, options) {
    		options = merge(options, decode.options);
    		var strict = options.strict;
    		if (strict && regexInvalidEntity.test(html)) {
    			parseError('malformed character reference');
    		}
    		return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
    			var codePoint;
    			var semicolon;
    			var decDigits;
    			var hexDigits;
    			var reference;
    			var next;

    			if ($1) {
    				reference = $1;
    				// Note: there is no need to check `has(decodeMap, reference)`.
    				return decodeMap[reference];
    			}

    			if ($2) {
    				// Decode named character references without trailing `;`, e.g. `&amp`.
    				// This is only a parse error if it gets converted to `&`, or if it is
    				// followed by `=` in an attribute context.
    				reference = $2;
    				next = $3;
    				if (next && options.isAttributeValue) {
    					if (strict && next == '=') {
    						parseError('`&` did not start a character reference');
    					}
    					return $0;
    				} else {
    					if (strict) {
    						parseError(
    							'named character reference was not terminated by a semicolon'
    						);
    					}
    					// Note: there is no need to check `has(decodeMapLegacy, reference)`.
    					return decodeMapLegacy[reference] + (next || '');
    				}
    			}

    			if ($4) {
    				// Decode decimal escapes, e.g. `&#119558;`.
    				decDigits = $4;
    				semicolon = $5;
    				if (strict && !semicolon) {
    					parseError('character reference was not terminated by a semicolon');
    				}
    				codePoint = parseInt(decDigits, 10);
    				return codePointToSymbol(codePoint, strict);
    			}

    			if ($6) {
    				// Decode hexadecimal escapes, e.g. `&#x1D306;`.
    				hexDigits = $6;
    				semicolon = $7;
    				if (strict && !semicolon) {
    					parseError('character reference was not terminated by a semicolon');
    				}
    				codePoint = parseInt(hexDigits, 16);
    				return codePointToSymbol(codePoint, strict);
    			}

    			// If we’re still here, `if ($7)` is implied; it’s an ambiguous
    			// ampersand for sure. https://mths.be/notes/ambiguous-ampersands
    			if (strict) {
    				parseError(
    					'named character reference was not terminated by a semicolon'
    				);
    			}
    			return $0;
    		});
    	};
    	// Expose default options (so they can be overridden globally).
    	decode.options = {
    		'isAttributeValue': false,
    		'strict': false
    	};

    	var escape = function(string) {
    		return string.replace(regexEscape, function($0) {
    			// Note: there is no need to check `has(escapeMap, $0)` here.
    			return escapeMap[$0];
    		});
    	};

    	/*--------------------------------------------------------------------------*/

    	var he = {
    		'version': '1.2.0',
    		'encode': encode,
    		'decode': decode,
    		'escape': escape,
    		'unescape': decode
    	};

    	// Some AMD build optimizers, like r.js, check for specific condition patterns
    	// like the following:
    	if (freeExports && !freeExports.nodeType) {
    		if (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+
    			freeModule.exports = he;
    		} else { // in Narwhal or RingoJS v0.7.0-
    			for (var key in he) {
    				has(he, key) && (freeExports[key] = he[key]);
    			}
    		}
    	} else { // in Rhino or a web browser
    		root.he = he;
    	}

    }(commonjsGlobal));
    });

    var require$$0$3 = {
    	"0": 65533,
    	"128": 8364,
    	"130": 8218,
    	"131": 402,
    	"132": 8222,
    	"133": 8230,
    	"134": 8224,
    	"135": 8225,
    	"136": 710,
    	"137": 8240,
    	"138": 352,
    	"139": 8249,
    	"140": 338,
    	"142": 381,
    	"145": 8216,
    	"146": 8217,
    	"147": 8220,
    	"148": 8221,
    	"149": 8226,
    	"150": 8211,
    	"151": 8212,
    	"152": 732,
    	"153": 8482,
    	"154": 353,
    	"155": 8250,
    	"156": 339,
    	"158": 382,
    	"159": 376
    };

    var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    var decode_json_1 = __importDefault$1(require$$0$3);
    // Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
    var fromCodePoint = 
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.fromCodePoint ||
        function (codePoint) {
            var output = "";
            if (codePoint > 0xffff) {
                codePoint -= 0x10000;
                output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
                codePoint = 0xdc00 | (codePoint & 0x3ff);
            }
            output += String.fromCharCode(codePoint);
            return output;
        };
    function decodeCodePoint(codePoint) {
        if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
            return "\uFFFD";
        }
        if (codePoint in decode_json_1.default) {
            codePoint = decode_json_1.default[codePoint];
        }
        return fromCodePoint(codePoint);
    }
    var _default$2 = decodeCodePoint;

    var decode_codepoint = /*#__PURE__*/Object.defineProperty({
    	default: _default$2
    }, '__esModule', {value: true});

    var Aacute$1 = "Á";
    var aacute$1 = "á";
    var Abreve = "Ă";
    var abreve = "ă";
    var ac = "∾";
    var acd = "∿";
    var acE = "∾̳";
    var Acirc$1 = "Â";
    var acirc$1 = "â";
    var acute$1 = "´";
    var Acy = "А";
    var acy = "а";
    var AElig$1 = "Æ";
    var aelig$1 = "æ";
    var af = "⁡";
    var Afr = "𝔄";
    var afr = "𝔞";
    var Agrave$1 = "À";
    var agrave$1 = "à";
    var alefsym = "ℵ";
    var aleph = "ℵ";
    var Alpha = "Α";
    var alpha = "α";
    var Amacr = "Ā";
    var amacr = "ā";
    var amalg = "⨿";
    var amp$2 = "&";
    var AMP$1 = "&";
    var andand = "⩕";
    var And = "⩓";
    var and = "∧";
    var andd = "⩜";
    var andslope = "⩘";
    var andv = "⩚";
    var ang = "∠";
    var ange = "⦤";
    var angle = "∠";
    var angmsdaa = "⦨";
    var angmsdab = "⦩";
    var angmsdac = "⦪";
    var angmsdad = "⦫";
    var angmsdae = "⦬";
    var angmsdaf = "⦭";
    var angmsdag = "⦮";
    var angmsdah = "⦯";
    var angmsd = "∡";
    var angrt = "∟";
    var angrtvb = "⊾";
    var angrtvbd = "⦝";
    var angsph = "∢";
    var angst = "Å";
    var angzarr = "⍼";
    var Aogon = "Ą";
    var aogon = "ą";
    var Aopf = "𝔸";
    var aopf = "𝕒";
    var apacir = "⩯";
    var ap = "≈";
    var apE = "⩰";
    var ape = "≊";
    var apid = "≋";
    var apos$1 = "'";
    var ApplyFunction = "⁡";
    var approx = "≈";
    var approxeq = "≊";
    var Aring$1 = "Å";
    var aring$1 = "å";
    var Ascr = "𝒜";
    var ascr = "𝒶";
    var Assign = "≔";
    var ast = "*";
    var asymp = "≈";
    var asympeq = "≍";
    var Atilde$1 = "Ã";
    var atilde$1 = "ã";
    var Auml$1 = "Ä";
    var auml$1 = "ä";
    var awconint = "∳";
    var awint = "⨑";
    var backcong = "≌";
    var backepsilon = "϶";
    var backprime = "‵";
    var backsim = "∽";
    var backsimeq = "⋍";
    var Backslash = "∖";
    var Barv = "⫧";
    var barvee = "⊽";
    var barwed = "⌅";
    var Barwed = "⌆";
    var barwedge = "⌅";
    var bbrk = "⎵";
    var bbrktbrk = "⎶";
    var bcong = "≌";
    var Bcy = "Б";
    var bcy = "б";
    var bdquo = "„";
    var becaus = "∵";
    var because = "∵";
    var Because = "∵";
    var bemptyv = "⦰";
    var bepsi = "϶";
    var bernou = "ℬ";
    var Bernoullis = "ℬ";
    var Beta = "Β";
    var beta = "β";
    var beth = "ℶ";
    var between = "≬";
    var Bfr = "𝔅";
    var bfr = "𝔟";
    var bigcap = "⋂";
    var bigcirc = "◯";
    var bigcup = "⋃";
    var bigodot = "⨀";
    var bigoplus = "⨁";
    var bigotimes = "⨂";
    var bigsqcup = "⨆";
    var bigstar = "★";
    var bigtriangledown = "▽";
    var bigtriangleup = "△";
    var biguplus = "⨄";
    var bigvee = "⋁";
    var bigwedge = "⋀";
    var bkarow = "⤍";
    var blacklozenge = "⧫";
    var blacksquare = "▪";
    var blacktriangle = "▴";
    var blacktriangledown = "▾";
    var blacktriangleleft = "◂";
    var blacktriangleright = "▸";
    var blank = "␣";
    var blk12 = "▒";
    var blk14 = "░";
    var blk34 = "▓";
    var block$1 = "█";
    var bne = "=⃥";
    var bnequiv = "≡⃥";
    var bNot = "⫭";
    var bnot = "⌐";
    var Bopf = "𝔹";
    var bopf = "𝕓";
    var bot = "⊥";
    var bottom = "⊥";
    var bowtie = "⋈";
    var boxbox = "⧉";
    var boxdl = "┐";
    var boxdL = "╕";
    var boxDl = "╖";
    var boxDL = "╗";
    var boxdr = "┌";
    var boxdR = "╒";
    var boxDr = "╓";
    var boxDR = "╔";
    var boxh = "─";
    var boxH = "═";
    var boxhd = "┬";
    var boxHd = "╤";
    var boxhD = "╥";
    var boxHD = "╦";
    var boxhu = "┴";
    var boxHu = "╧";
    var boxhU = "╨";
    var boxHU = "╩";
    var boxminus = "⊟";
    var boxplus = "⊞";
    var boxtimes = "⊠";
    var boxul = "┘";
    var boxuL = "╛";
    var boxUl = "╜";
    var boxUL = "╝";
    var boxur = "└";
    var boxuR = "╘";
    var boxUr = "╙";
    var boxUR = "╚";
    var boxv = "│";
    var boxV = "║";
    var boxvh = "┼";
    var boxvH = "╪";
    var boxVh = "╫";
    var boxVH = "╬";
    var boxvl = "┤";
    var boxvL = "╡";
    var boxVl = "╢";
    var boxVL = "╣";
    var boxvr = "├";
    var boxvR = "╞";
    var boxVr = "╟";
    var boxVR = "╠";
    var bprime = "‵";
    var breve = "˘";
    var Breve = "˘";
    var brvbar$1 = "¦";
    var bscr = "𝒷";
    var Bscr = "ℬ";
    var bsemi = "⁏";
    var bsim = "∽";
    var bsime = "⋍";
    var bsolb = "⧅";
    var bsol = "\\";
    var bsolhsub = "⟈";
    var bull = "•";
    var bullet = "•";
    var bump = "≎";
    var bumpE = "⪮";
    var bumpe = "≏";
    var Bumpeq = "≎";
    var bumpeq = "≏";
    var Cacute = "Ć";
    var cacute = "ć";
    var capand = "⩄";
    var capbrcup = "⩉";
    var capcap = "⩋";
    var cap = "∩";
    var Cap = "⋒";
    var capcup = "⩇";
    var capdot = "⩀";
    var CapitalDifferentialD = "ⅅ";
    var caps = "∩︀";
    var caret$1 = "⁁";
    var caron = "ˇ";
    var Cayleys = "ℭ";
    var ccaps = "⩍";
    var Ccaron = "Č";
    var ccaron = "č";
    var Ccedil$1 = "Ç";
    var ccedil$1 = "ç";
    var Ccirc = "Ĉ";
    var ccirc = "ĉ";
    var Cconint = "∰";
    var ccups = "⩌";
    var ccupssm = "⩐";
    var Cdot = "Ċ";
    var cdot = "ċ";
    var cedil$1 = "¸";
    var Cedilla = "¸";
    var cemptyv = "⦲";
    var cent$1 = "¢";
    var centerdot = "·";
    var CenterDot = "·";
    var cfr = "𝔠";
    var Cfr = "ℭ";
    var CHcy = "Ч";
    var chcy = "ч";
    var check = "✓";
    var checkmark = "✓";
    var Chi = "Χ";
    var chi = "χ";
    var circ = "ˆ";
    var circeq = "≗";
    var circlearrowleft = "↺";
    var circlearrowright = "↻";
    var circledast = "⊛";
    var circledcirc = "⊚";
    var circleddash = "⊝";
    var CircleDot = "⊙";
    var circledR = "®";
    var circledS = "Ⓢ";
    var CircleMinus = "⊖";
    var CirclePlus = "⊕";
    var CircleTimes = "⊗";
    var cir = "○";
    var cirE = "⧃";
    var cire = "≗";
    var cirfnint = "⨐";
    var cirmid = "⫯";
    var cirscir = "⧂";
    var ClockwiseContourIntegral = "∲";
    var CloseCurlyDoubleQuote = "”";
    var CloseCurlyQuote = "’";
    var clubs = "♣";
    var clubsuit = "♣";
    var colon = ":";
    var Colon = "∷";
    var Colone = "⩴";
    var colone = "≔";
    var coloneq = "≔";
    var comma$1 = ",";
    var commat = "@";
    var comp = "∁";
    var compfn = "∘";
    var complement = "∁";
    var complexes = "ℂ";
    var cong = "≅";
    var congdot = "⩭";
    var Congruent = "≡";
    var conint = "∮";
    var Conint = "∯";
    var ContourIntegral = "∮";
    var copf = "𝕔";
    var Copf = "ℂ";
    var coprod = "∐";
    var Coproduct = "∐";
    var copy$1 = "©";
    var COPY$1 = "©";
    var copysr = "℗";
    var CounterClockwiseContourIntegral = "∳";
    var crarr = "↵";
    var cross = "✗";
    var Cross = "⨯";
    var Cscr = "𝒞";
    var cscr = "𝒸";
    var csub = "⫏";
    var csube = "⫑";
    var csup = "⫐";
    var csupe = "⫒";
    var ctdot = "⋯";
    var cudarrl = "⤸";
    var cudarrr = "⤵";
    var cuepr = "⋞";
    var cuesc = "⋟";
    var cularr = "↶";
    var cularrp = "⤽";
    var cupbrcap = "⩈";
    var cupcap = "⩆";
    var CupCap = "≍";
    var cup = "∪";
    var Cup = "⋓";
    var cupcup = "⩊";
    var cupdot = "⊍";
    var cupor = "⩅";
    var cups = "∪︀";
    var curarr = "↷";
    var curarrm = "⤼";
    var curlyeqprec = "⋞";
    var curlyeqsucc = "⋟";
    var curlyvee = "⋎";
    var curlywedge = "⋏";
    var curren$1 = "¤";
    var curvearrowleft = "↶";
    var curvearrowright = "↷";
    var cuvee = "⋎";
    var cuwed = "⋏";
    var cwconint = "∲";
    var cwint = "∱";
    var cylcty = "⌭";
    var dagger = "†";
    var Dagger = "‡";
    var daleth = "ℸ";
    var darr = "↓";
    var Darr = "↡";
    var dArr = "⇓";
    var dash = "‐";
    var Dashv = "⫤";
    var dashv = "⊣";
    var dbkarow = "⤏";
    var dblac = "˝";
    var Dcaron = "Ď";
    var dcaron = "ď";
    var Dcy = "Д";
    var dcy = "д";
    var ddagger = "‡";
    var ddarr = "⇊";
    var DD = "ⅅ";
    var dd = "ⅆ";
    var DDotrahd = "⤑";
    var ddotseq = "⩷";
    var deg$1 = "°";
    var Del$1 = "∇";
    var Delta = "Δ";
    var delta = "δ";
    var demptyv = "⦱";
    var dfisht = "⥿";
    var Dfr = "𝔇";
    var dfr = "𝔡";
    var dHar = "⥥";
    var dharl = "⇃";
    var dharr = "⇂";
    var DiacriticalAcute = "´";
    var DiacriticalDot = "˙";
    var DiacriticalDoubleAcute = "˝";
    var DiacriticalGrave = "`";
    var DiacriticalTilde = "˜";
    var diam = "⋄";
    var diamond = "⋄";
    var Diamond = "⋄";
    var diamondsuit = "♦";
    var diams = "♦";
    var die = "¨";
    var DifferentialD = "ⅆ";
    var digamma = "ϝ";
    var disin = "⋲";
    var div = "÷";
    var divide$1 = "÷";
    var divideontimes = "⋇";
    var divonx = "⋇";
    var DJcy = "Ђ";
    var djcy = "ђ";
    var dlcorn = "⌞";
    var dlcrop = "⌍";
    var dollar$1 = "$";
    var Dopf = "𝔻";
    var dopf = "𝕕";
    var Dot = "¨";
    var dot = "˙";
    var DotDot = "⃜";
    var doteq = "≐";
    var doteqdot = "≑";
    var DotEqual = "≐";
    var dotminus = "∸";
    var dotplus = "∔";
    var dotsquare = "⊡";
    var doublebarwedge = "⌆";
    var DoubleContourIntegral = "∯";
    var DoubleDot = "¨";
    var DoubleDownArrow = "⇓";
    var DoubleLeftArrow = "⇐";
    var DoubleLeftRightArrow = "⇔";
    var DoubleLeftTee = "⫤";
    var DoubleLongLeftArrow = "⟸";
    var DoubleLongLeftRightArrow = "⟺";
    var DoubleLongRightArrow = "⟹";
    var DoubleRightArrow = "⇒";
    var DoubleRightTee = "⊨";
    var DoubleUpArrow = "⇑";
    var DoubleUpDownArrow = "⇕";
    var DoubleVerticalBar = "∥";
    var DownArrowBar = "⤓";
    var downarrow = "↓";
    var DownArrow = "↓";
    var Downarrow = "⇓";
    var DownArrowUpArrow = "⇵";
    var DownBreve = "̑";
    var downdownarrows = "⇊";
    var downharpoonleft = "⇃";
    var downharpoonright = "⇂";
    var DownLeftRightVector = "⥐";
    var DownLeftTeeVector = "⥞";
    var DownLeftVectorBar = "⥖";
    var DownLeftVector = "↽";
    var DownRightTeeVector = "⥟";
    var DownRightVectorBar = "⥗";
    var DownRightVector = "⇁";
    var DownTeeArrow = "↧";
    var DownTee = "⊤";
    var drbkarow = "⤐";
    var drcorn = "⌟";
    var drcrop = "⌌";
    var Dscr = "𝒟";
    var dscr = "𝒹";
    var DScy = "Ѕ";
    var dscy = "ѕ";
    var dsol = "⧶";
    var Dstrok = "Đ";
    var dstrok = "đ";
    var dtdot = "⋱";
    var dtri = "▿";
    var dtrif = "▾";
    var duarr = "⇵";
    var duhar = "⥯";
    var dwangle = "⦦";
    var DZcy = "Џ";
    var dzcy = "џ";
    var dzigrarr = "⟿";
    var Eacute$1 = "É";
    var eacute$1 = "é";
    var easter = "⩮";
    var Ecaron = "Ě";
    var ecaron = "ě";
    var Ecirc$1 = "Ê";
    var ecirc$1 = "ê";
    var ecir = "≖";
    var ecolon = "≕";
    var Ecy = "Э";
    var ecy = "э";
    var eDDot = "⩷";
    var Edot = "Ė";
    var edot = "ė";
    var eDot = "≑";
    var ee = "ⅇ";
    var efDot = "≒";
    var Efr = "𝔈";
    var efr = "𝔢";
    var eg = "⪚";
    var Egrave$1 = "È";
    var egrave$1 = "è";
    var egs = "⪖";
    var egsdot = "⪘";
    var el = "⪙";
    var Element = "∈";
    var elinters = "⏧";
    var ell = "ℓ";
    var els = "⪕";
    var elsdot = "⪗";
    var Emacr = "Ē";
    var emacr = "ē";
    var empty = "∅";
    var emptyset = "∅";
    var EmptySmallSquare = "◻";
    var emptyv = "∅";
    var EmptyVerySmallSquare = "▫";
    var emsp13 = " ";
    var emsp14 = " ";
    var emsp = " ";
    var ENG = "Ŋ";
    var eng = "ŋ";
    var ensp = " ";
    var Eogon = "Ę";
    var eogon = "ę";
    var Eopf = "𝔼";
    var eopf = "𝕖";
    var epar = "⋕";
    var eparsl = "⧣";
    var eplus = "⩱";
    var epsi = "ε";
    var Epsilon = "Ε";
    var epsilon = "ε";
    var epsiv = "ϵ";
    var eqcirc = "≖";
    var eqcolon = "≕";
    var eqsim = "≂";
    var eqslantgtr = "⪖";
    var eqslantless = "⪕";
    var Equal = "⩵";
    var equals = "=";
    var EqualTilde = "≂";
    var equest = "≟";
    var Equilibrium = "⇌";
    var equiv = "≡";
    var equivDD = "⩸";
    var eqvparsl = "⧥";
    var erarr = "⥱";
    var erDot = "≓";
    var escr = "ℯ";
    var Escr = "ℰ";
    var esdot = "≐";
    var Esim = "⩳";
    var esim = "≂";
    var Eta = "Η";
    var eta = "η";
    var ETH$1 = "Ð";
    var eth$1 = "ð";
    var Euml$1 = "Ë";
    var euml$1 = "ë";
    var euro = "€";
    var excl = "!";
    var exist = "∃";
    var Exists = "∃";
    var expectation = "ℰ";
    var exponentiale = "ⅇ";
    var ExponentialE = "ⅇ";
    var fallingdotseq = "≒";
    var Fcy = "Ф";
    var fcy = "ф";
    var female = "♀";
    var ffilig = "ﬃ";
    var fflig = "ﬀ";
    var ffllig = "ﬄ";
    var Ffr = "𝔉";
    var ffr = "𝔣";
    var filig = "ﬁ";
    var FilledSmallSquare = "◼";
    var FilledVerySmallSquare = "▪";
    var fjlig = "fj";
    var flat = "♭";
    var fllig = "ﬂ";
    var fltns = "▱";
    var fnof = "ƒ";
    var Fopf = "𝔽";
    var fopf = "𝕗";
    var forall = "∀";
    var ForAll = "∀";
    var fork = "⋔";
    var forkv = "⫙";
    var Fouriertrf = "ℱ";
    var fpartint = "⨍";
    var frac12$1 = "½";
    var frac13 = "⅓";
    var frac14$1 = "¼";
    var frac15 = "⅕";
    var frac16 = "⅙";
    var frac18 = "⅛";
    var frac23 = "⅔";
    var frac25 = "⅖";
    var frac34$1 = "¾";
    var frac35 = "⅗";
    var frac38 = "⅜";
    var frac45 = "⅘";
    var frac56 = "⅚";
    var frac58 = "⅝";
    var frac78 = "⅞";
    var frasl = "⁄";
    var frown = "⌢";
    var fscr = "𝒻";
    var Fscr = "ℱ";
    var gacute = "ǵ";
    var Gamma = "Γ";
    var gamma = "γ";
    var Gammad = "Ϝ";
    var gammad = "ϝ";
    var gap = "⪆";
    var Gbreve = "Ğ";
    var gbreve = "ğ";
    var Gcedil = "Ģ";
    var Gcirc = "Ĝ";
    var gcirc = "ĝ";
    var Gcy = "Г";
    var gcy = "г";
    var Gdot = "Ġ";
    var gdot = "ġ";
    var ge = "≥";
    var gE = "≧";
    var gEl = "⪌";
    var gel = "⋛";
    var geq = "≥";
    var geqq = "≧";
    var geqslant = "⩾";
    var gescc = "⪩";
    var ges = "⩾";
    var gesdot = "⪀";
    var gesdoto = "⪂";
    var gesdotol = "⪄";
    var gesl = "⋛︀";
    var gesles = "⪔";
    var Gfr = "𝔊";
    var gfr = "𝔤";
    var gg = "≫";
    var Gg = "⋙";
    var ggg = "⋙";
    var gimel = "ℷ";
    var GJcy = "Ѓ";
    var gjcy = "ѓ";
    var gla = "⪥";
    var gl = "≷";
    var glE = "⪒";
    var glj = "⪤";
    var gnap = "⪊";
    var gnapprox = "⪊";
    var gne = "⪈";
    var gnE = "≩";
    var gneq = "⪈";
    var gneqq = "≩";
    var gnsim = "⋧";
    var Gopf = "𝔾";
    var gopf = "𝕘";
    var grave = "`";
    var GreaterEqual = "≥";
    var GreaterEqualLess = "⋛";
    var GreaterFullEqual = "≧";
    var GreaterGreater = "⪢";
    var GreaterLess = "≷";
    var GreaterSlantEqual = "⩾";
    var GreaterTilde = "≳";
    var Gscr = "𝒢";
    var gscr = "ℊ";
    var gsim = "≳";
    var gsime = "⪎";
    var gsiml = "⪐";
    var gtcc = "⪧";
    var gtcir = "⩺";
    var gt$3 = ">";
    var GT$1 = ">";
    var Gt = "≫";
    var gtdot = "⋗";
    var gtlPar = "⦕";
    var gtquest = "⩼";
    var gtrapprox = "⪆";
    var gtrarr = "⥸";
    var gtrdot = "⋗";
    var gtreqless = "⋛";
    var gtreqqless = "⪌";
    var gtrless = "≷";
    var gtrsim = "≳";
    var gvertneqq = "≩︀";
    var gvnE = "≩︀";
    var Hacek = "ˇ";
    var hairsp = " ";
    var half = "½";
    var hamilt = "ℋ";
    var HARDcy = "Ъ";
    var hardcy = "ъ";
    var harrcir = "⥈";
    var harr = "↔";
    var hArr = "⇔";
    var harrw = "↭";
    var Hat = "^";
    var hbar = "ℏ";
    var Hcirc = "Ĥ";
    var hcirc = "ĥ";
    var hearts = "♥";
    var heartsuit = "♥";
    var hellip = "…";
    var hercon = "⊹";
    var hfr = "𝔥";
    var Hfr = "ℌ";
    var HilbertSpace = "ℋ";
    var hksearow = "⤥";
    var hkswarow = "⤦";
    var hoarr = "⇿";
    var homtht = "∻";
    var hookleftarrow = "↩";
    var hookrightarrow = "↪";
    var hopf = "𝕙";
    var Hopf = "ℍ";
    var horbar = "―";
    var HorizontalLine = "─";
    var hscr = "𝒽";
    var Hscr = "ℋ";
    var hslash = "ℏ";
    var Hstrok = "Ħ";
    var hstrok = "ħ";
    var HumpDownHump = "≎";
    var HumpEqual = "≏";
    var hybull = "⁃";
    var hyphen = "‐";
    var Iacute$1 = "Í";
    var iacute$1 = "í";
    var ic = "⁣";
    var Icirc$1 = "Î";
    var icirc$1 = "î";
    var Icy = "И";
    var icy = "и";
    var Idot = "İ";
    var IEcy = "Е";
    var iecy = "е";
    var iexcl$1 = "¡";
    var iff = "⇔";
    var ifr = "𝔦";
    var Ifr = "ℑ";
    var Igrave$1 = "Ì";
    var igrave$1 = "ì";
    var ii = "ⅈ";
    var iiiint = "⨌";
    var iiint = "∭";
    var iinfin = "⧜";
    var iiota = "℩";
    var IJlig = "Ĳ";
    var ijlig = "ĳ";
    var Imacr = "Ī";
    var imacr = "ī";
    var image = "ℑ";
    var ImaginaryI = "ⅈ";
    var imagline = "ℐ";
    var imagpart = "ℑ";
    var imath = "ı";
    var Im = "ℑ";
    var imof = "⊷";
    var imped = "Ƶ";
    var Implies = "⇒";
    var incare = "℅";
    var infin = "∞";
    var infintie = "⧝";
    var inodot = "ı";
    var intcal = "⊺";
    var int = "∫";
    var Int = "∬";
    var integers = "ℤ";
    var Integral = "∫";
    var intercal = "⊺";
    var Intersection = "⋂";
    var intlarhk = "⨗";
    var intprod = "⨼";
    var InvisibleComma = "⁣";
    var InvisibleTimes = "⁢";
    var IOcy = "Ё";
    var iocy = "ё";
    var Iogon = "Į";
    var iogon = "į";
    var Iopf = "𝕀";
    var iopf = "𝕚";
    var Iota = "Ι";
    var iota = "ι";
    var iprod = "⨼";
    var iquest$1 = "¿";
    var iscr = "𝒾";
    var Iscr = "ℐ";
    var isin = "∈";
    var isindot = "⋵";
    var isinE = "⋹";
    var isins = "⋴";
    var isinsv = "⋳";
    var isinv = "∈";
    var it = "⁢";
    var Itilde = "Ĩ";
    var itilde = "ĩ";
    var Iukcy = "І";
    var iukcy = "і";
    var Iuml$1 = "Ï";
    var iuml$1 = "ï";
    var Jcirc = "Ĵ";
    var jcirc = "ĵ";
    var Jcy = "Й";
    var jcy = "й";
    var Jfr = "𝔍";
    var jfr = "𝔧";
    var jmath = "ȷ";
    var Jopf = "𝕁";
    var jopf = "𝕛";
    var Jscr = "𝒥";
    var jscr = "𝒿";
    var Jsercy = "Ј";
    var jsercy = "ј";
    var Jukcy = "Є";
    var jukcy = "є";
    var Kappa = "Κ";
    var kappa = "κ";
    var kappav = "ϰ";
    var Kcedil = "Ķ";
    var kcedil = "ķ";
    var Kcy = "К";
    var kcy = "к";
    var Kfr = "𝔎";
    var kfr = "𝔨";
    var kgreen = "ĸ";
    var KHcy = "Х";
    var khcy = "х";
    var KJcy = "Ќ";
    var kjcy = "ќ";
    var Kopf = "𝕂";
    var kopf = "𝕜";
    var Kscr = "𝒦";
    var kscr = "𝓀";
    var lAarr = "⇚";
    var Lacute = "Ĺ";
    var lacute = "ĺ";
    var laemptyv = "⦴";
    var lagran = "ℒ";
    var Lambda = "Λ";
    var lambda = "λ";
    var lang = "⟨";
    var Lang = "⟪";
    var langd = "⦑";
    var langle = "⟨";
    var lap = "⪅";
    var Laplacetrf = "ℒ";
    var laquo$1 = "«";
    var larrb = "⇤";
    var larrbfs = "⤟";
    var larr = "←";
    var Larr = "↞";
    var lArr = "⇐";
    var larrfs = "⤝";
    var larrhk = "↩";
    var larrlp = "↫";
    var larrpl = "⤹";
    var larrsim = "⥳";
    var larrtl = "↢";
    var latail = "⤙";
    var lAtail = "⤛";
    var lat = "⪫";
    var late = "⪭";
    var lates = "⪭︀";
    var lbarr = "⤌";
    var lBarr = "⤎";
    var lbbrk = "❲";
    var lbrace = "{";
    var lbrack = "[";
    var lbrke = "⦋";
    var lbrksld = "⦏";
    var lbrkslu = "⦍";
    var Lcaron = "Ľ";
    var lcaron = "ľ";
    var Lcedil = "Ļ";
    var lcedil = "ļ";
    var lceil = "⌈";
    var lcub = "{";
    var Lcy = "Л";
    var lcy = "л";
    var ldca = "⤶";
    var ldquo = "“";
    var ldquor = "„";
    var ldrdhar = "⥧";
    var ldrushar = "⥋";
    var ldsh = "↲";
    var le = "≤";
    var lE = "≦";
    var LeftAngleBracket = "⟨";
    var LeftArrowBar = "⇤";
    var leftarrow = "←";
    var LeftArrow = "←";
    var Leftarrow = "⇐";
    var LeftArrowRightArrow = "⇆";
    var leftarrowtail = "↢";
    var LeftCeiling = "⌈";
    var LeftDoubleBracket = "⟦";
    var LeftDownTeeVector = "⥡";
    var LeftDownVectorBar = "⥙";
    var LeftDownVector = "⇃";
    var LeftFloor = "⌊";
    var leftharpoondown = "↽";
    var leftharpoonup = "↼";
    var leftleftarrows = "⇇";
    var leftrightarrow = "↔";
    var LeftRightArrow = "↔";
    var Leftrightarrow = "⇔";
    var leftrightarrows = "⇆";
    var leftrightharpoons = "⇋";
    var leftrightsquigarrow = "↭";
    var LeftRightVector = "⥎";
    var LeftTeeArrow = "↤";
    var LeftTee = "⊣";
    var LeftTeeVector = "⥚";
    var leftthreetimes = "⋋";
    var LeftTriangleBar = "⧏";
    var LeftTriangle = "⊲";
    var LeftTriangleEqual = "⊴";
    var LeftUpDownVector = "⥑";
    var LeftUpTeeVector = "⥠";
    var LeftUpVectorBar = "⥘";
    var LeftUpVector = "↿";
    var LeftVectorBar = "⥒";
    var LeftVector = "↼";
    var lEg = "⪋";
    var leg = "⋚";
    var leq = "≤";
    var leqq = "≦";
    var leqslant = "⩽";
    var lescc = "⪨";
    var les = "⩽";
    var lesdot = "⩿";
    var lesdoto = "⪁";
    var lesdotor = "⪃";
    var lesg = "⋚︀";
    var lesges = "⪓";
    var lessapprox = "⪅";
    var lessdot = "⋖";
    var lesseqgtr = "⋚";
    var lesseqqgtr = "⪋";
    var LessEqualGreater = "⋚";
    var LessFullEqual = "≦";
    var LessGreater = "≶";
    var lessgtr = "≶";
    var LessLess = "⪡";
    var lesssim = "≲";
    var LessSlantEqual = "⩽";
    var LessTilde = "≲";
    var lfisht = "⥼";
    var lfloor = "⌊";
    var Lfr = "𝔏";
    var lfr = "𝔩";
    var lg = "≶";
    var lgE = "⪑";
    var lHar = "⥢";
    var lhard = "↽";
    var lharu = "↼";
    var lharul = "⥪";
    var lhblk = "▄";
    var LJcy = "Љ";
    var ljcy = "љ";
    var llarr = "⇇";
    var ll = "≪";
    var Ll = "⋘";
    var llcorner = "⌞";
    var Lleftarrow = "⇚";
    var llhard = "⥫";
    var lltri = "◺";
    var Lmidot = "Ŀ";
    var lmidot = "ŀ";
    var lmoustache = "⎰";
    var lmoust = "⎰";
    var lnap = "⪉";
    var lnapprox = "⪉";
    var lne = "⪇";
    var lnE = "≨";
    var lneq = "⪇";
    var lneqq = "≨";
    var lnsim = "⋦";
    var loang = "⟬";
    var loarr = "⇽";
    var lobrk = "⟦";
    var longleftarrow = "⟵";
    var LongLeftArrow = "⟵";
    var Longleftarrow = "⟸";
    var longleftrightarrow = "⟷";
    var LongLeftRightArrow = "⟷";
    var Longleftrightarrow = "⟺";
    var longmapsto = "⟼";
    var longrightarrow = "⟶";
    var LongRightArrow = "⟶";
    var Longrightarrow = "⟹";
    var looparrowleft = "↫";
    var looparrowright = "↬";
    var lopar = "⦅";
    var Lopf = "𝕃";
    var lopf = "𝕝";
    var loplus = "⨭";
    var lotimes = "⨴";
    var lowast = "∗";
    var lowbar = "_";
    var LowerLeftArrow = "↙";
    var LowerRightArrow = "↘";
    var loz = "◊";
    var lozenge = "◊";
    var lozf = "⧫";
    var lpar = "(";
    var lparlt = "⦓";
    var lrarr = "⇆";
    var lrcorner = "⌟";
    var lrhar = "⇋";
    var lrhard = "⥭";
    var lrm = "‎";
    var lrtri = "⊿";
    var lsaquo = "‹";
    var lscr = "𝓁";
    var Lscr = "ℒ";
    var lsh = "↰";
    var Lsh = "↰";
    var lsim = "≲";
    var lsime = "⪍";
    var lsimg = "⪏";
    var lsqb = "[";
    var lsquo = "‘";
    var lsquor = "‚";
    var Lstrok = "Ł";
    var lstrok = "ł";
    var ltcc = "⪦";
    var ltcir = "⩹";
    var lt$2 = "<";
    var LT$1 = "<";
    var Lt = "≪";
    var ltdot = "⋖";
    var lthree = "⋋";
    var ltimes = "⋉";
    var ltlarr = "⥶";
    var ltquest = "⩻";
    var ltri = "◃";
    var ltrie = "⊴";
    var ltrif = "◂";
    var ltrPar = "⦖";
    var lurdshar = "⥊";
    var luruhar = "⥦";
    var lvertneqq = "≨︀";
    var lvnE = "≨︀";
    var macr$1 = "¯";
    var male = "♂";
    var malt = "✠";
    var maltese = "✠";
    var map = "↦";
    var mapsto = "↦";
    var mapstodown = "↧";
    var mapstoleft = "↤";
    var mapstoup = "↥";
    var marker = "▮";
    var mcomma = "⨩";
    var Mcy = "М";
    var mcy = "м";
    var mdash = "—";
    var mDDot = "∺";
    var measuredangle = "∡";
    var MediumSpace = " ";
    var Mellintrf = "ℳ";
    var Mfr = "𝔐";
    var mfr = "𝔪";
    var mho = "℧";
    var micro$1 = "µ";
    var midast = "*";
    var midcir = "⫰";
    var mid = "∣";
    var middot$1 = "·";
    var minusb = "⊟";
    var minus = "−";
    var minusd = "∸";
    var minusdu = "⨪";
    var MinusPlus = "∓";
    var mlcp = "⫛";
    var mldr = "…";
    var mnplus = "∓";
    var models = "⊧";
    var Mopf = "𝕄";
    var mopf = "𝕞";
    var mp = "∓";
    var mscr = "𝓂";
    var Mscr = "ℳ";
    var mstpos = "∾";
    var Mu = "Μ";
    var mu = "μ";
    var multimap = "⊸";
    var mumap = "⊸";
    var nabla = "∇";
    var Nacute = "Ń";
    var nacute = "ń";
    var nang = "∠⃒";
    var nap = "≉";
    var napE = "⩰̸";
    var napid = "≋̸";
    var napos = "ŉ";
    var napprox = "≉";
    var natural = "♮";
    var naturals = "ℕ";
    var natur = "♮";
    var nbsp$1 = " ";
    var nbump = "≎̸";
    var nbumpe = "≏̸";
    var ncap = "⩃";
    var Ncaron = "Ň";
    var ncaron = "ň";
    var Ncedil = "Ņ";
    var ncedil = "ņ";
    var ncong = "≇";
    var ncongdot = "⩭̸";
    var ncup = "⩂";
    var Ncy = "Н";
    var ncy = "н";
    var ndash = "–";
    var nearhk = "⤤";
    var nearr = "↗";
    var neArr = "⇗";
    var nearrow = "↗";
    var ne = "≠";
    var nedot = "≐̸";
    var NegativeMediumSpace = "​";
    var NegativeThickSpace = "​";
    var NegativeThinSpace = "​";
    var NegativeVeryThinSpace = "​";
    var nequiv = "≢";
    var nesear = "⤨";
    var nesim = "≂̸";
    var NestedGreaterGreater = "≫";
    var NestedLessLess = "≪";
    var NewLine = "\n";
    var nexist = "∄";
    var nexists = "∄";
    var Nfr = "𝔑";
    var nfr = "𝔫";
    var ngE = "≧̸";
    var nge = "≱";
    var ngeq = "≱";
    var ngeqq = "≧̸";
    var ngeqslant = "⩾̸";
    var nges = "⩾̸";
    var nGg = "⋙̸";
    var ngsim = "≵";
    var nGt = "≫⃒";
    var ngt = "≯";
    var ngtr = "≯";
    var nGtv = "≫̸";
    var nharr = "↮";
    var nhArr = "⇎";
    var nhpar = "⫲";
    var ni = "∋";
    var nis = "⋼";
    var nisd = "⋺";
    var niv = "∋";
    var NJcy = "Њ";
    var njcy = "њ";
    var nlarr = "↚";
    var nlArr = "⇍";
    var nldr = "‥";
    var nlE = "≦̸";
    var nle = "≰";
    var nleftarrow = "↚";
    var nLeftarrow = "⇍";
    var nleftrightarrow = "↮";
    var nLeftrightarrow = "⇎";
    var nleq = "≰";
    var nleqq = "≦̸";
    var nleqslant = "⩽̸";
    var nles = "⩽̸";
    var nless = "≮";
    var nLl = "⋘̸";
    var nlsim = "≴";
    var nLt = "≪⃒";
    var nlt = "≮";
    var nltri = "⋪";
    var nltrie = "⋬";
    var nLtv = "≪̸";
    var nmid = "∤";
    var NoBreak = "⁠";
    var NonBreakingSpace = " ";
    var nopf = "𝕟";
    var Nopf = "ℕ";
    var Not = "⫬";
    var not$1 = "¬";
    var NotCongruent = "≢";
    var NotCupCap = "≭";
    var NotDoubleVerticalBar = "∦";
    var NotElement = "∉";
    var NotEqual = "≠";
    var NotEqualTilde = "≂̸";
    var NotExists = "∄";
    var NotGreater = "≯";
    var NotGreaterEqual = "≱";
    var NotGreaterFullEqual = "≧̸";
    var NotGreaterGreater = "≫̸";
    var NotGreaterLess = "≹";
    var NotGreaterSlantEqual = "⩾̸";
    var NotGreaterTilde = "≵";
    var NotHumpDownHump = "≎̸";
    var NotHumpEqual = "≏̸";
    var notin = "∉";
    var notindot = "⋵̸";
    var notinE = "⋹̸";
    var notinva = "∉";
    var notinvb = "⋷";
    var notinvc = "⋶";
    var NotLeftTriangleBar = "⧏̸";
    var NotLeftTriangle = "⋪";
    var NotLeftTriangleEqual = "⋬";
    var NotLess = "≮";
    var NotLessEqual = "≰";
    var NotLessGreater = "≸";
    var NotLessLess = "≪̸";
    var NotLessSlantEqual = "⩽̸";
    var NotLessTilde = "≴";
    var NotNestedGreaterGreater = "⪢̸";
    var NotNestedLessLess = "⪡̸";
    var notni = "∌";
    var notniva = "∌";
    var notnivb = "⋾";
    var notnivc = "⋽";
    var NotPrecedes = "⊀";
    var NotPrecedesEqual = "⪯̸";
    var NotPrecedesSlantEqual = "⋠";
    var NotReverseElement = "∌";
    var NotRightTriangleBar = "⧐̸";
    var NotRightTriangle = "⋫";
    var NotRightTriangleEqual = "⋭";
    var NotSquareSubset = "⊏̸";
    var NotSquareSubsetEqual = "⋢";
    var NotSquareSuperset = "⊐̸";
    var NotSquareSupersetEqual = "⋣";
    var NotSubset = "⊂⃒";
    var NotSubsetEqual = "⊈";
    var NotSucceeds = "⊁";
    var NotSucceedsEqual = "⪰̸";
    var NotSucceedsSlantEqual = "⋡";
    var NotSucceedsTilde = "≿̸";
    var NotSuperset = "⊃⃒";
    var NotSupersetEqual = "⊉";
    var NotTilde = "≁";
    var NotTildeEqual = "≄";
    var NotTildeFullEqual = "≇";
    var NotTildeTilde = "≉";
    var NotVerticalBar = "∤";
    var nparallel = "∦";
    var npar = "∦";
    var nparsl = "⫽⃥";
    var npart = "∂̸";
    var npolint = "⨔";
    var npr = "⊀";
    var nprcue = "⋠";
    var nprec = "⊀";
    var npreceq = "⪯̸";
    var npre = "⪯̸";
    var nrarrc = "⤳̸";
    var nrarr = "↛";
    var nrArr = "⇏";
    var nrarrw = "↝̸";
    var nrightarrow = "↛";
    var nRightarrow = "⇏";
    var nrtri = "⋫";
    var nrtrie = "⋭";
    var nsc = "⊁";
    var nsccue = "⋡";
    var nsce = "⪰̸";
    var Nscr = "𝒩";
    var nscr = "𝓃";
    var nshortmid = "∤";
    var nshortparallel = "∦";
    var nsim = "≁";
    var nsime = "≄";
    var nsimeq = "≄";
    var nsmid = "∤";
    var nspar = "∦";
    var nsqsube = "⋢";
    var nsqsupe = "⋣";
    var nsub = "⊄";
    var nsubE = "⫅̸";
    var nsube = "⊈";
    var nsubset = "⊂⃒";
    var nsubseteq = "⊈";
    var nsubseteqq = "⫅̸";
    var nsucc = "⊁";
    var nsucceq = "⪰̸";
    var nsup = "⊅";
    var nsupE = "⫆̸";
    var nsupe = "⊉";
    var nsupset = "⊃⃒";
    var nsupseteq = "⊉";
    var nsupseteqq = "⫆̸";
    var ntgl = "≹";
    var Ntilde$1 = "Ñ";
    var ntilde$1 = "ñ";
    var ntlg = "≸";
    var ntriangleleft = "⋪";
    var ntrianglelefteq = "⋬";
    var ntriangleright = "⋫";
    var ntrianglerighteq = "⋭";
    var Nu = "Ν";
    var nu = "ν";
    var num = "#";
    var numero = "№";
    var numsp = " ";
    var nvap = "≍⃒";
    var nvdash = "⊬";
    var nvDash = "⊭";
    var nVdash = "⊮";
    var nVDash = "⊯";
    var nvge = "≥⃒";
    var nvgt = ">⃒";
    var nvHarr = "⤄";
    var nvinfin = "⧞";
    var nvlArr = "⤂";
    var nvle = "≤⃒";
    var nvlt = "<⃒";
    var nvltrie = "⊴⃒";
    var nvrArr = "⤃";
    var nvrtrie = "⊵⃒";
    var nvsim = "∼⃒";
    var nwarhk = "⤣";
    var nwarr = "↖";
    var nwArr = "⇖";
    var nwarrow = "↖";
    var nwnear = "⤧";
    var Oacute$1 = "Ó";
    var oacute$1 = "ó";
    var oast = "⊛";
    var Ocirc$1 = "Ô";
    var ocirc$1 = "ô";
    var ocir = "⊚";
    var Ocy = "О";
    var ocy = "о";
    var odash = "⊝";
    var Odblac = "Ő";
    var odblac = "ő";
    var odiv = "⨸";
    var odot = "⊙";
    var odsold = "⦼";
    var OElig = "Œ";
    var oelig = "œ";
    var ofcir = "⦿";
    var Ofr = "𝔒";
    var ofr = "𝔬";
    var ogon = "˛";
    var Ograve$1 = "Ò";
    var ograve$1 = "ò";
    var ogt = "⧁";
    var ohbar = "⦵";
    var ohm = "Ω";
    var oint = "∮";
    var olarr = "↺";
    var olcir = "⦾";
    var olcross = "⦻";
    var oline = "‾";
    var olt = "⧀";
    var Omacr = "Ō";
    var omacr = "ō";
    var Omega = "Ω";
    var omega = "ω";
    var Omicron = "Ο";
    var omicron = "ο";
    var omid = "⦶";
    var ominus = "⊖";
    var Oopf = "𝕆";
    var oopf = "𝕠";
    var opar = "⦷";
    var OpenCurlyDoubleQuote = "“";
    var OpenCurlyQuote = "‘";
    var operp = "⦹";
    var oplus = "⊕";
    var orarr = "↻";
    var Or = "⩔";
    var or = "∨";
    var ord = "⩝";
    var order = "ℴ";
    var orderof = "ℴ";
    var ordf$1 = "ª";
    var ordm$1 = "º";
    var origof = "⊶";
    var oror = "⩖";
    var orslope = "⩗";
    var orv = "⩛";
    var oS = "Ⓢ";
    var Oscr = "𝒪";
    var oscr = "ℴ";
    var Oslash$1 = "Ø";
    var oslash$1 = "ø";
    var osol = "⊘";
    var Otilde$1 = "Õ";
    var otilde$1 = "õ";
    var otimesas = "⨶";
    var Otimes = "⨷";
    var otimes = "⊗";
    var Ouml$1 = "Ö";
    var ouml$1 = "ö";
    var ovbar = "⌽";
    var OverBar = "‾";
    var OverBrace = "⏞";
    var OverBracket = "⎴";
    var OverParenthesis = "⏜";
    var para$1 = "¶";
    var parallel = "∥";
    var par = "∥";
    var parsim = "⫳";
    var parsl = "⫽";
    var part = "∂";
    var PartialD = "∂";
    var Pcy = "П";
    var pcy = "п";
    var percnt = "%";
    var period = ".";
    var permil = "‰";
    var perp = "⊥";
    var pertenk = "‱";
    var Pfr = "𝔓";
    var pfr = "𝔭";
    var Phi = "Φ";
    var phi = "φ";
    var phiv = "ϕ";
    var phmmat = "ℳ";
    var phone = "☎";
    var Pi = "Π";
    var pi = "π";
    var pitchfork = "⋔";
    var piv = "ϖ";
    var planck = "ℏ";
    var planckh = "ℎ";
    var plankv = "ℏ";
    var plusacir = "⨣";
    var plusb = "⊞";
    var pluscir = "⨢";
    var plus$1 = "+";
    var plusdo = "∔";
    var plusdu = "⨥";
    var pluse = "⩲";
    var PlusMinus = "±";
    var plusmn$1 = "±";
    var plussim = "⨦";
    var plustwo = "⨧";
    var pm = "±";
    var Poincareplane = "ℌ";
    var pointint = "⨕";
    var popf = "𝕡";
    var Popf = "ℙ";
    var pound$1 = "£";
    var prap = "⪷";
    var Pr = "⪻";
    var pr = "≺";
    var prcue = "≼";
    var precapprox = "⪷";
    var prec = "≺";
    var preccurlyeq = "≼";
    var Precedes = "≺";
    var PrecedesEqual = "⪯";
    var PrecedesSlantEqual = "≼";
    var PrecedesTilde = "≾";
    var preceq = "⪯";
    var precnapprox = "⪹";
    var precneqq = "⪵";
    var precnsim = "⋨";
    var pre = "⪯";
    var prE = "⪳";
    var precsim = "≾";
    var prime = "′";
    var Prime = "″";
    var primes = "ℙ";
    var prnap = "⪹";
    var prnE = "⪵";
    var prnsim = "⋨";
    var prod = "∏";
    var Product = "∏";
    var profalar = "⌮";
    var profline = "⌒";
    var profsurf = "⌓";
    var prop = "∝";
    var Proportional = "∝";
    var Proportion = "∷";
    var propto = "∝";
    var prsim = "≾";
    var prurel = "⊰";
    var Pscr = "𝒫";
    var pscr = "𝓅";
    var Psi = "Ψ";
    var psi = "ψ";
    var puncsp = " ";
    var Qfr = "𝔔";
    var qfr = "𝔮";
    var qint = "⨌";
    var qopf = "𝕢";
    var Qopf = "ℚ";
    var qprime = "⁗";
    var Qscr = "𝒬";
    var qscr = "𝓆";
    var quaternions = "ℍ";
    var quatint = "⨖";
    var quest = "?";
    var questeq = "≟";
    var quot$2 = "\"";
    var QUOT$1 = "\"";
    var rAarr = "⇛";
    var race = "∽̱";
    var Racute = "Ŕ";
    var racute = "ŕ";
    var radic = "√";
    var raemptyv = "⦳";
    var rang = "⟩";
    var Rang = "⟫";
    var rangd = "⦒";
    var range = "⦥";
    var rangle = "⟩";
    var raquo$1 = "»";
    var rarrap = "⥵";
    var rarrb = "⇥";
    var rarrbfs = "⤠";
    var rarrc = "⤳";
    var rarr = "→";
    var Rarr = "↠";
    var rArr = "⇒";
    var rarrfs = "⤞";
    var rarrhk = "↪";
    var rarrlp = "↬";
    var rarrpl = "⥅";
    var rarrsim = "⥴";
    var Rarrtl = "⤖";
    var rarrtl = "↣";
    var rarrw = "↝";
    var ratail = "⤚";
    var rAtail = "⤜";
    var ratio = "∶";
    var rationals = "ℚ";
    var rbarr = "⤍";
    var rBarr = "⤏";
    var RBarr = "⤐";
    var rbbrk = "❳";
    var rbrace = "}";
    var rbrack = "]";
    var rbrke = "⦌";
    var rbrksld = "⦎";
    var rbrkslu = "⦐";
    var Rcaron = "Ř";
    var rcaron = "ř";
    var Rcedil = "Ŗ";
    var rcedil = "ŗ";
    var rceil = "⌉";
    var rcub = "}";
    var Rcy = "Р";
    var rcy = "р";
    var rdca = "⤷";
    var rdldhar = "⥩";
    var rdquo = "”";
    var rdquor = "”";
    var rdsh = "↳";
    var real = "ℜ";
    var realine = "ℛ";
    var realpart = "ℜ";
    var reals = "ℝ";
    var Re = "ℜ";
    var rect = "▭";
    var reg$1 = "®";
    var REG$1 = "®";
    var ReverseElement = "∋";
    var ReverseEquilibrium = "⇋";
    var ReverseUpEquilibrium = "⥯";
    var rfisht = "⥽";
    var rfloor = "⌋";
    var rfr = "𝔯";
    var Rfr = "ℜ";
    var rHar = "⥤";
    var rhard = "⇁";
    var rharu = "⇀";
    var rharul = "⥬";
    var Rho = "Ρ";
    var rho = "ρ";
    var rhov = "ϱ";
    var RightAngleBracket = "⟩";
    var RightArrowBar = "⇥";
    var rightarrow = "→";
    var RightArrow = "→";
    var Rightarrow = "⇒";
    var RightArrowLeftArrow = "⇄";
    var rightarrowtail = "↣";
    var RightCeiling = "⌉";
    var RightDoubleBracket = "⟧";
    var RightDownTeeVector = "⥝";
    var RightDownVectorBar = "⥕";
    var RightDownVector = "⇂";
    var RightFloor = "⌋";
    var rightharpoondown = "⇁";
    var rightharpoonup = "⇀";
    var rightleftarrows = "⇄";
    var rightleftharpoons = "⇌";
    var rightrightarrows = "⇉";
    var rightsquigarrow = "↝";
    var RightTeeArrow = "↦";
    var RightTee = "⊢";
    var RightTeeVector = "⥛";
    var rightthreetimes = "⋌";
    var RightTriangleBar = "⧐";
    var RightTriangle = "⊳";
    var RightTriangleEqual = "⊵";
    var RightUpDownVector = "⥏";
    var RightUpTeeVector = "⥜";
    var RightUpVectorBar = "⥔";
    var RightUpVector = "↾";
    var RightVectorBar = "⥓";
    var RightVector = "⇀";
    var ring = "˚";
    var risingdotseq = "≓";
    var rlarr = "⇄";
    var rlhar = "⇌";
    var rlm = "‏";
    var rmoustache = "⎱";
    var rmoust = "⎱";
    var rnmid = "⫮";
    var roang = "⟭";
    var roarr = "⇾";
    var robrk = "⟧";
    var ropar = "⦆";
    var ropf = "𝕣";
    var Ropf = "ℝ";
    var roplus = "⨮";
    var rotimes = "⨵";
    var RoundImplies = "⥰";
    var rpar = ")";
    var rpargt = "⦔";
    var rppolint = "⨒";
    var rrarr = "⇉";
    var Rrightarrow = "⇛";
    var rsaquo = "›";
    var rscr = "𝓇";
    var Rscr = "ℛ";
    var rsh = "↱";
    var Rsh = "↱";
    var rsqb = "]";
    var rsquo = "’";
    var rsquor = "’";
    var rthree = "⋌";
    var rtimes = "⋊";
    var rtri = "▹";
    var rtrie = "⊵";
    var rtrif = "▸";
    var rtriltri = "⧎";
    var RuleDelayed = "⧴";
    var ruluhar = "⥨";
    var rx = "℞";
    var Sacute = "Ś";
    var sacute = "ś";
    var sbquo = "‚";
    var scap = "⪸";
    var Scaron = "Š";
    var scaron = "š";
    var Sc = "⪼";
    var sc = "≻";
    var sccue = "≽";
    var sce = "⪰";
    var scE = "⪴";
    var Scedil = "Ş";
    var scedil = "ş";
    var Scirc = "Ŝ";
    var scirc = "ŝ";
    var scnap = "⪺";
    var scnE = "⪶";
    var scnsim = "⋩";
    var scpolint = "⨓";
    var scsim = "≿";
    var Scy = "С";
    var scy = "с";
    var sdotb = "⊡";
    var sdot = "⋅";
    var sdote = "⩦";
    var searhk = "⤥";
    var searr = "↘";
    var seArr = "⇘";
    var searrow = "↘";
    var sect$1 = "§";
    var semi = ";";
    var seswar = "⤩";
    var setminus = "∖";
    var setmn = "∖";
    var sext = "✶";
    var Sfr = "𝔖";
    var sfr = "𝔰";
    var sfrown = "⌢";
    var sharp = "♯";
    var SHCHcy = "Щ";
    var shchcy = "щ";
    var SHcy = "Ш";
    var shcy = "ш";
    var ShortDownArrow = "↓";
    var ShortLeftArrow = "←";
    var shortmid = "∣";
    var shortparallel = "∥";
    var ShortRightArrow = "→";
    var ShortUpArrow = "↑";
    var shy$1 = "­";
    var Sigma = "Σ";
    var sigma = "σ";
    var sigmaf = "ς";
    var sigmav = "ς";
    var sim = "∼";
    var simdot = "⩪";
    var sime = "≃";
    var simeq = "≃";
    var simg = "⪞";
    var simgE = "⪠";
    var siml = "⪝";
    var simlE = "⪟";
    var simne = "≆";
    var simplus = "⨤";
    var simrarr = "⥲";
    var slarr = "←";
    var SmallCircle = "∘";
    var smallsetminus = "∖";
    var smashp = "⨳";
    var smeparsl = "⧤";
    var smid = "∣";
    var smile = "⌣";
    var smt = "⪪";
    var smte = "⪬";
    var smtes = "⪬︀";
    var SOFTcy = "Ь";
    var softcy = "ь";
    var solbar = "⌿";
    var solb = "⧄";
    var sol = "/";
    var Sopf = "𝕊";
    var sopf = "𝕤";
    var spades = "♠";
    var spadesuit = "♠";
    var spar = "∥";
    var sqcap = "⊓";
    var sqcaps = "⊓︀";
    var sqcup = "⊔";
    var sqcups = "⊔︀";
    var Sqrt = "√";
    var sqsub = "⊏";
    var sqsube = "⊑";
    var sqsubset = "⊏";
    var sqsubseteq = "⊑";
    var sqsup = "⊐";
    var sqsupe = "⊒";
    var sqsupset = "⊐";
    var sqsupseteq = "⊒";
    var square = "□";
    var Square = "□";
    var SquareIntersection = "⊓";
    var SquareSubset = "⊏";
    var SquareSubsetEqual = "⊑";
    var SquareSuperset = "⊐";
    var SquareSupersetEqual = "⊒";
    var SquareUnion = "⊔";
    var squarf = "▪";
    var squ = "□";
    var squf = "▪";
    var srarr = "→";
    var Sscr = "𝒮";
    var sscr = "𝓈";
    var ssetmn = "∖";
    var ssmile = "⌣";
    var sstarf = "⋆";
    var Star = "⋆";
    var star = "☆";
    var starf = "★";
    var straightepsilon = "ϵ";
    var straightphi = "ϕ";
    var strns = "¯";
    var sub = "⊂";
    var Sub = "⋐";
    var subdot = "⪽";
    var subE = "⫅";
    var sube = "⊆";
    var subedot = "⫃";
    var submult = "⫁";
    var subnE = "⫋";
    var subne = "⊊";
    var subplus = "⪿";
    var subrarr = "⥹";
    var subset = "⊂";
    var Subset = "⋐";
    var subseteq = "⊆";
    var subseteqq = "⫅";
    var SubsetEqual = "⊆";
    var subsetneq = "⊊";
    var subsetneqq = "⫋";
    var subsim = "⫇";
    var subsub = "⫕";
    var subsup = "⫓";
    var succapprox = "⪸";
    var succ = "≻";
    var succcurlyeq = "≽";
    var Succeeds = "≻";
    var SucceedsEqual = "⪰";
    var SucceedsSlantEqual = "≽";
    var SucceedsTilde = "≿";
    var succeq = "⪰";
    var succnapprox = "⪺";
    var succneqq = "⪶";
    var succnsim = "⋩";
    var succsim = "≿";
    var SuchThat = "∋";
    var sum = "∑";
    var Sum = "∑";
    var sung = "♪";
    var sup1$1 = "¹";
    var sup2$1 = "²";
    var sup3$1 = "³";
    var sup = "⊃";
    var Sup = "⋑";
    var supdot = "⪾";
    var supdsub = "⫘";
    var supE = "⫆";
    var supe = "⊇";
    var supedot = "⫄";
    var Superset = "⊃";
    var SupersetEqual = "⊇";
    var suphsol = "⟉";
    var suphsub = "⫗";
    var suplarr = "⥻";
    var supmult = "⫂";
    var supnE = "⫌";
    var supne = "⊋";
    var supplus = "⫀";
    var supset = "⊃";
    var Supset = "⋑";
    var supseteq = "⊇";
    var supseteqq = "⫆";
    var supsetneq = "⊋";
    var supsetneqq = "⫌";
    var supsim = "⫈";
    var supsub = "⫔";
    var supsup = "⫖";
    var swarhk = "⤦";
    var swarr = "↙";
    var swArr = "⇙";
    var swarrow = "↙";
    var swnwar = "⤪";
    var szlig$1 = "ß";
    var Tab = "\t";
    var target = "⌖";
    var Tau = "Τ";
    var tau = "τ";
    var tbrk = "⎴";
    var Tcaron = "Ť";
    var tcaron = "ť";
    var Tcedil = "Ţ";
    var tcedil = "ţ";
    var Tcy = "Т";
    var tcy = "т";
    var tdot = "⃛";
    var telrec = "⌕";
    var Tfr = "𝔗";
    var tfr = "𝔱";
    var there4 = "∴";
    var therefore = "∴";
    var Therefore = "∴";
    var Theta = "Θ";
    var theta = "θ";
    var thetasym = "ϑ";
    var thetav = "ϑ";
    var thickapprox = "≈";
    var thicksim = "∼";
    var ThickSpace = "  ";
    var ThinSpace = " ";
    var thinsp = " ";
    var thkap = "≈";
    var thksim = "∼";
    var THORN$1 = "Þ";
    var thorn$1 = "þ";
    var tilde$1 = "˜";
    var Tilde = "∼";
    var TildeEqual = "≃";
    var TildeFullEqual = "≅";
    var TildeTilde = "≈";
    var timesbar = "⨱";
    var timesb = "⊠";
    var times$1 = "×";
    var timesd = "⨰";
    var tint = "∭";
    var toea = "⤨";
    var topbot = "⌶";
    var topcir = "⫱";
    var top = "⊤";
    var Topf = "𝕋";
    var topf = "𝕥";
    var topfork = "⫚";
    var tosa = "⤩";
    var tprime = "‴";
    var trade = "™";
    var TRADE = "™";
    var triangle = "▵";
    var triangledown = "▿";
    var triangleleft = "◃";
    var trianglelefteq = "⊴";
    var triangleq = "≜";
    var triangleright = "▹";
    var trianglerighteq = "⊵";
    var tridot = "◬";
    var trie = "≜";
    var triminus = "⨺";
    var TripleDot = "⃛";
    var triplus = "⨹";
    var trisb = "⧍";
    var tritime = "⨻";
    var trpezium = "⏢";
    var Tscr = "𝒯";
    var tscr = "𝓉";
    var TScy = "Ц";
    var tscy = "ц";
    var TSHcy = "Ћ";
    var tshcy = "ћ";
    var Tstrok = "Ŧ";
    var tstrok = "ŧ";
    var twixt = "≬";
    var twoheadleftarrow = "↞";
    var twoheadrightarrow = "↠";
    var Uacute$1 = "Ú";
    var uacute$1 = "ú";
    var uarr = "↑";
    var Uarr = "↟";
    var uArr = "⇑";
    var Uarrocir = "⥉";
    var Ubrcy = "Ў";
    var ubrcy = "ў";
    var Ubreve = "Ŭ";
    var ubreve = "ŭ";
    var Ucirc$1 = "Û";
    var ucirc$1 = "û";
    var Ucy = "У";
    var ucy = "у";
    var udarr = "⇅";
    var Udblac = "Ű";
    var udblac = "ű";
    var udhar = "⥮";
    var ufisht = "⥾";
    var Ufr = "𝔘";
    var ufr = "𝔲";
    var Ugrave$1 = "Ù";
    var ugrave$1 = "ù";
    var uHar = "⥣";
    var uharl = "↿";
    var uharr = "↾";
    var uhblk = "▀";
    var ulcorn = "⌜";
    var ulcorner = "⌜";
    var ulcrop = "⌏";
    var ultri = "◸";
    var Umacr = "Ū";
    var umacr = "ū";
    var uml$1 = "¨";
    var UnderBar = "_";
    var UnderBrace = "⏟";
    var UnderBracket = "⎵";
    var UnderParenthesis = "⏝";
    var Union = "⋃";
    var UnionPlus = "⊎";
    var Uogon = "Ų";
    var uogon = "ų";
    var Uopf = "𝕌";
    var uopf = "𝕦";
    var UpArrowBar = "⤒";
    var uparrow = "↑";
    var UpArrow = "↑";
    var Uparrow = "⇑";
    var UpArrowDownArrow = "⇅";
    var updownarrow = "↕";
    var UpDownArrow = "↕";
    var Updownarrow = "⇕";
    var UpEquilibrium = "⥮";
    var upharpoonleft = "↿";
    var upharpoonright = "↾";
    var uplus = "⊎";
    var UpperLeftArrow = "↖";
    var UpperRightArrow = "↗";
    var upsi = "υ";
    var Upsi = "ϒ";
    var upsih = "ϒ";
    var Upsilon = "Υ";
    var upsilon = "υ";
    var UpTeeArrow = "↥";
    var UpTee = "⊥";
    var upuparrows = "⇈";
    var urcorn = "⌝";
    var urcorner = "⌝";
    var urcrop = "⌎";
    var Uring = "Ů";
    var uring = "ů";
    var urtri = "◹";
    var Uscr = "𝒰";
    var uscr = "𝓊";
    var utdot = "⋰";
    var Utilde = "Ũ";
    var utilde = "ũ";
    var utri = "▵";
    var utrif = "▴";
    var uuarr = "⇈";
    var Uuml$1 = "Ü";
    var uuml$1 = "ü";
    var uwangle = "⦧";
    var vangrt = "⦜";
    var varepsilon = "ϵ";
    var varkappa = "ϰ";
    var varnothing = "∅";
    var varphi = "ϕ";
    var varpi = "ϖ";
    var varpropto = "∝";
    var varr = "↕";
    var vArr = "⇕";
    var varrho = "ϱ";
    var varsigma = "ς";
    var varsubsetneq = "⊊︀";
    var varsubsetneqq = "⫋︀";
    var varsupsetneq = "⊋︀";
    var varsupsetneqq = "⫌︀";
    var vartheta = "ϑ";
    var vartriangleleft = "⊲";
    var vartriangleright = "⊳";
    var vBar = "⫨";
    var Vbar = "⫫";
    var vBarv = "⫩";
    var Vcy = "В";
    var vcy = "в";
    var vdash = "⊢";
    var vDash = "⊨";
    var Vdash = "⊩";
    var VDash = "⊫";
    var Vdashl = "⫦";
    var veebar = "⊻";
    var vee = "∨";
    var Vee = "⋁";
    var veeeq = "≚";
    var vellip = "⋮";
    var verbar = "|";
    var Verbar = "‖";
    var vert = "|";
    var Vert = "‖";
    var VerticalBar = "∣";
    var VerticalLine = "|";
    var VerticalSeparator = "❘";
    var VerticalTilde = "≀";
    var VeryThinSpace = " ";
    var Vfr = "𝔙";
    var vfr = "𝔳";
    var vltri = "⊲";
    var vnsub = "⊂⃒";
    var vnsup = "⊃⃒";
    var Vopf = "𝕍";
    var vopf = "𝕧";
    var vprop = "∝";
    var vrtri = "⊳";
    var Vscr = "𝒱";
    var vscr = "𝓋";
    var vsubnE = "⫋︀";
    var vsubne = "⊊︀";
    var vsupnE = "⫌︀";
    var vsupne = "⊋︀";
    var Vvdash = "⊪";
    var vzigzag = "⦚";
    var Wcirc = "Ŵ";
    var wcirc = "ŵ";
    var wedbar = "⩟";
    var wedge = "∧";
    var Wedge = "⋀";
    var wedgeq = "≙";
    var weierp = "℘";
    var Wfr = "𝔚";
    var wfr = "𝔴";
    var Wopf = "𝕎";
    var wopf = "𝕨";
    var wp = "℘";
    var wr = "≀";
    var wreath = "≀";
    var Wscr = "𝒲";
    var wscr = "𝓌";
    var xcap = "⋂";
    var xcirc = "◯";
    var xcup = "⋃";
    var xdtri = "▽";
    var Xfr = "𝔛";
    var xfr = "𝔵";
    var xharr = "⟷";
    var xhArr = "⟺";
    var Xi = "Ξ";
    var xi = "ξ";
    var xlarr = "⟵";
    var xlArr = "⟸";
    var xmap = "⟼";
    var xnis = "⋻";
    var xodot = "⨀";
    var Xopf = "𝕏";
    var xopf = "𝕩";
    var xoplus = "⨁";
    var xotime = "⨂";
    var xrarr = "⟶";
    var xrArr = "⟹";
    var Xscr = "𝒳";
    var xscr = "𝓍";
    var xsqcup = "⨆";
    var xuplus = "⨄";
    var xutri = "△";
    var xvee = "⋁";
    var xwedge = "⋀";
    var Yacute$1 = "Ý";
    var yacute$1 = "ý";
    var YAcy = "Я";
    var yacy = "я";
    var Ycirc = "Ŷ";
    var ycirc = "ŷ";
    var Ycy = "Ы";
    var ycy = "ы";
    var yen$1 = "¥";
    var Yfr = "𝔜";
    var yfr = "𝔶";
    var YIcy = "Ї";
    var yicy = "ї";
    var Yopf = "𝕐";
    var yopf = "𝕪";
    var Yscr = "𝒴";
    var yscr = "𝓎";
    var YUcy = "Ю";
    var yucy = "ю";
    var yuml$1 = "ÿ";
    var Yuml = "Ÿ";
    var Zacute = "Ź";
    var zacute = "ź";
    var Zcaron = "Ž";
    var zcaron = "ž";
    var Zcy = "З";
    var zcy = "з";
    var Zdot = "Ż";
    var zdot = "ż";
    var zeetrf = "ℨ";
    var ZeroWidthSpace = "​";
    var Zeta = "Ζ";
    var zeta = "ζ";
    var zfr = "𝔷";
    var Zfr = "ℨ";
    var ZHcy = "Ж";
    var zhcy = "ж";
    var zigrarr = "⇝";
    var zopf = "𝕫";
    var Zopf = "ℤ";
    var Zscr = "𝒵";
    var zscr = "𝓏";
    var zwj = "‍";
    var zwnj = "‌";
    var require$$1$3 = {
    	Aacute: Aacute$1,
    	aacute: aacute$1,
    	Abreve: Abreve,
    	abreve: abreve,
    	ac: ac,
    	acd: acd,
    	acE: acE,
    	Acirc: Acirc$1,
    	acirc: acirc$1,
    	acute: acute$1,
    	Acy: Acy,
    	acy: acy,
    	AElig: AElig$1,
    	aelig: aelig$1,
    	af: af,
    	Afr: Afr,
    	afr: afr,
    	Agrave: Agrave$1,
    	agrave: agrave$1,
    	alefsym: alefsym,
    	aleph: aleph,
    	Alpha: Alpha,
    	alpha: alpha,
    	Amacr: Amacr,
    	amacr: amacr,
    	amalg: amalg,
    	amp: amp$2,
    	AMP: AMP$1,
    	andand: andand,
    	And: And,
    	and: and,
    	andd: andd,
    	andslope: andslope,
    	andv: andv,
    	ang: ang,
    	ange: ange,
    	angle: angle,
    	angmsdaa: angmsdaa,
    	angmsdab: angmsdab,
    	angmsdac: angmsdac,
    	angmsdad: angmsdad,
    	angmsdae: angmsdae,
    	angmsdaf: angmsdaf,
    	angmsdag: angmsdag,
    	angmsdah: angmsdah,
    	angmsd: angmsd,
    	angrt: angrt,
    	angrtvb: angrtvb,
    	angrtvbd: angrtvbd,
    	angsph: angsph,
    	angst: angst,
    	angzarr: angzarr,
    	Aogon: Aogon,
    	aogon: aogon,
    	Aopf: Aopf,
    	aopf: aopf,
    	apacir: apacir,
    	ap: ap,
    	apE: apE,
    	ape: ape,
    	apid: apid,
    	apos: apos$1,
    	ApplyFunction: ApplyFunction,
    	approx: approx,
    	approxeq: approxeq,
    	Aring: Aring$1,
    	aring: aring$1,
    	Ascr: Ascr,
    	ascr: ascr,
    	Assign: Assign,
    	ast: ast,
    	asymp: asymp,
    	asympeq: asympeq,
    	Atilde: Atilde$1,
    	atilde: atilde$1,
    	Auml: Auml$1,
    	auml: auml$1,
    	awconint: awconint,
    	awint: awint,
    	backcong: backcong,
    	backepsilon: backepsilon,
    	backprime: backprime,
    	backsim: backsim,
    	backsimeq: backsimeq,
    	Backslash: Backslash,
    	Barv: Barv,
    	barvee: barvee,
    	barwed: barwed,
    	Barwed: Barwed,
    	barwedge: barwedge,
    	bbrk: bbrk,
    	bbrktbrk: bbrktbrk,
    	bcong: bcong,
    	Bcy: Bcy,
    	bcy: bcy,
    	bdquo: bdquo,
    	becaus: becaus,
    	because: because,
    	Because: Because,
    	bemptyv: bemptyv,
    	bepsi: bepsi,
    	bernou: bernou,
    	Bernoullis: Bernoullis,
    	Beta: Beta,
    	beta: beta,
    	beth: beth,
    	between: between,
    	Bfr: Bfr,
    	bfr: bfr,
    	bigcap: bigcap,
    	bigcirc: bigcirc,
    	bigcup: bigcup,
    	bigodot: bigodot,
    	bigoplus: bigoplus,
    	bigotimes: bigotimes,
    	bigsqcup: bigsqcup,
    	bigstar: bigstar,
    	bigtriangledown: bigtriangledown,
    	bigtriangleup: bigtriangleup,
    	biguplus: biguplus,
    	bigvee: bigvee,
    	bigwedge: bigwedge,
    	bkarow: bkarow,
    	blacklozenge: blacklozenge,
    	blacksquare: blacksquare,
    	blacktriangle: blacktriangle,
    	blacktriangledown: blacktriangledown,
    	blacktriangleleft: blacktriangleleft,
    	blacktriangleright: blacktriangleright,
    	blank: blank,
    	blk12: blk12,
    	blk14: blk14,
    	blk34: blk34,
    	block: block$1,
    	bne: bne,
    	bnequiv: bnequiv,
    	bNot: bNot,
    	bnot: bnot,
    	Bopf: Bopf,
    	bopf: bopf,
    	bot: bot,
    	bottom: bottom,
    	bowtie: bowtie,
    	boxbox: boxbox,
    	boxdl: boxdl,
    	boxdL: boxdL,
    	boxDl: boxDl,
    	boxDL: boxDL,
    	boxdr: boxdr,
    	boxdR: boxdR,
    	boxDr: boxDr,
    	boxDR: boxDR,
    	boxh: boxh,
    	boxH: boxH,
    	boxhd: boxhd,
    	boxHd: boxHd,
    	boxhD: boxhD,
    	boxHD: boxHD,
    	boxhu: boxhu,
    	boxHu: boxHu,
    	boxhU: boxhU,
    	boxHU: boxHU,
    	boxminus: boxminus,
    	boxplus: boxplus,
    	boxtimes: boxtimes,
    	boxul: boxul,
    	boxuL: boxuL,
    	boxUl: boxUl,
    	boxUL: boxUL,
    	boxur: boxur,
    	boxuR: boxuR,
    	boxUr: boxUr,
    	boxUR: boxUR,
    	boxv: boxv,
    	boxV: boxV,
    	boxvh: boxvh,
    	boxvH: boxvH,
    	boxVh: boxVh,
    	boxVH: boxVH,
    	boxvl: boxvl,
    	boxvL: boxvL,
    	boxVl: boxVl,
    	boxVL: boxVL,
    	boxvr: boxvr,
    	boxvR: boxvR,
    	boxVr: boxVr,
    	boxVR: boxVR,
    	bprime: bprime,
    	breve: breve,
    	Breve: Breve,
    	brvbar: brvbar$1,
    	bscr: bscr,
    	Bscr: Bscr,
    	bsemi: bsemi,
    	bsim: bsim,
    	bsime: bsime,
    	bsolb: bsolb,
    	bsol: bsol,
    	bsolhsub: bsolhsub,
    	bull: bull,
    	bullet: bullet,
    	bump: bump,
    	bumpE: bumpE,
    	bumpe: bumpe,
    	Bumpeq: Bumpeq,
    	bumpeq: bumpeq,
    	Cacute: Cacute,
    	cacute: cacute,
    	capand: capand,
    	capbrcup: capbrcup,
    	capcap: capcap,
    	cap: cap,
    	Cap: Cap,
    	capcup: capcup,
    	capdot: capdot,
    	CapitalDifferentialD: CapitalDifferentialD,
    	caps: caps,
    	caret: caret$1,
    	caron: caron,
    	Cayleys: Cayleys,
    	ccaps: ccaps,
    	Ccaron: Ccaron,
    	ccaron: ccaron,
    	Ccedil: Ccedil$1,
    	ccedil: ccedil$1,
    	Ccirc: Ccirc,
    	ccirc: ccirc,
    	Cconint: Cconint,
    	ccups: ccups,
    	ccupssm: ccupssm,
    	Cdot: Cdot,
    	cdot: cdot,
    	cedil: cedil$1,
    	Cedilla: Cedilla,
    	cemptyv: cemptyv,
    	cent: cent$1,
    	centerdot: centerdot,
    	CenterDot: CenterDot,
    	cfr: cfr,
    	Cfr: Cfr,
    	CHcy: CHcy,
    	chcy: chcy,
    	check: check,
    	checkmark: checkmark,
    	Chi: Chi,
    	chi: chi,
    	circ: circ,
    	circeq: circeq,
    	circlearrowleft: circlearrowleft,
    	circlearrowright: circlearrowright,
    	circledast: circledast,
    	circledcirc: circledcirc,
    	circleddash: circleddash,
    	CircleDot: CircleDot,
    	circledR: circledR,
    	circledS: circledS,
    	CircleMinus: CircleMinus,
    	CirclePlus: CirclePlus,
    	CircleTimes: CircleTimes,
    	cir: cir,
    	cirE: cirE,
    	cire: cire,
    	cirfnint: cirfnint,
    	cirmid: cirmid,
    	cirscir: cirscir,
    	ClockwiseContourIntegral: ClockwiseContourIntegral,
    	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
    	CloseCurlyQuote: CloseCurlyQuote,
    	clubs: clubs,
    	clubsuit: clubsuit,
    	colon: colon,
    	Colon: Colon,
    	Colone: Colone,
    	colone: colone,
    	coloneq: coloneq,
    	comma: comma$1,
    	commat: commat,
    	comp: comp,
    	compfn: compfn,
    	complement: complement,
    	complexes: complexes,
    	cong: cong,
    	congdot: congdot,
    	Congruent: Congruent,
    	conint: conint,
    	Conint: Conint,
    	ContourIntegral: ContourIntegral,
    	copf: copf,
    	Copf: Copf,
    	coprod: coprod,
    	Coproduct: Coproduct,
    	copy: copy$1,
    	COPY: COPY$1,
    	copysr: copysr,
    	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
    	crarr: crarr,
    	cross: cross,
    	Cross: Cross,
    	Cscr: Cscr,
    	cscr: cscr,
    	csub: csub,
    	csube: csube,
    	csup: csup,
    	csupe: csupe,
    	ctdot: ctdot,
    	cudarrl: cudarrl,
    	cudarrr: cudarrr,
    	cuepr: cuepr,
    	cuesc: cuesc,
    	cularr: cularr,
    	cularrp: cularrp,
    	cupbrcap: cupbrcap,
    	cupcap: cupcap,
    	CupCap: CupCap,
    	cup: cup,
    	Cup: Cup,
    	cupcup: cupcup,
    	cupdot: cupdot,
    	cupor: cupor,
    	cups: cups,
    	curarr: curarr,
    	curarrm: curarrm,
    	curlyeqprec: curlyeqprec,
    	curlyeqsucc: curlyeqsucc,
    	curlyvee: curlyvee,
    	curlywedge: curlywedge,
    	curren: curren$1,
    	curvearrowleft: curvearrowleft,
    	curvearrowright: curvearrowright,
    	cuvee: cuvee,
    	cuwed: cuwed,
    	cwconint: cwconint,
    	cwint: cwint,
    	cylcty: cylcty,
    	dagger: dagger,
    	Dagger: Dagger,
    	daleth: daleth,
    	darr: darr,
    	Darr: Darr,
    	dArr: dArr,
    	dash: dash,
    	Dashv: Dashv,
    	dashv: dashv,
    	dbkarow: dbkarow,
    	dblac: dblac,
    	Dcaron: Dcaron,
    	dcaron: dcaron,
    	Dcy: Dcy,
    	dcy: dcy,
    	ddagger: ddagger,
    	ddarr: ddarr,
    	DD: DD,
    	dd: dd,
    	DDotrahd: DDotrahd,
    	ddotseq: ddotseq,
    	deg: deg$1,
    	Del: Del$1,
    	Delta: Delta,
    	delta: delta,
    	demptyv: demptyv,
    	dfisht: dfisht,
    	Dfr: Dfr,
    	dfr: dfr,
    	dHar: dHar,
    	dharl: dharl,
    	dharr: dharr,
    	DiacriticalAcute: DiacriticalAcute,
    	DiacriticalDot: DiacriticalDot,
    	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
    	DiacriticalGrave: DiacriticalGrave,
    	DiacriticalTilde: DiacriticalTilde,
    	diam: diam,
    	diamond: diamond,
    	Diamond: Diamond,
    	diamondsuit: diamondsuit,
    	diams: diams,
    	die: die,
    	DifferentialD: DifferentialD,
    	digamma: digamma,
    	disin: disin,
    	div: div,
    	divide: divide$1,
    	divideontimes: divideontimes,
    	divonx: divonx,
    	DJcy: DJcy,
    	djcy: djcy,
    	dlcorn: dlcorn,
    	dlcrop: dlcrop,
    	dollar: dollar$1,
    	Dopf: Dopf,
    	dopf: dopf,
    	Dot: Dot,
    	dot: dot,
    	DotDot: DotDot,
    	doteq: doteq,
    	doteqdot: doteqdot,
    	DotEqual: DotEqual,
    	dotminus: dotminus,
    	dotplus: dotplus,
    	dotsquare: dotsquare,
    	doublebarwedge: doublebarwedge,
    	DoubleContourIntegral: DoubleContourIntegral,
    	DoubleDot: DoubleDot,
    	DoubleDownArrow: DoubleDownArrow,
    	DoubleLeftArrow: DoubleLeftArrow,
    	DoubleLeftRightArrow: DoubleLeftRightArrow,
    	DoubleLeftTee: DoubleLeftTee,
    	DoubleLongLeftArrow: DoubleLongLeftArrow,
    	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
    	DoubleLongRightArrow: DoubleLongRightArrow,
    	DoubleRightArrow: DoubleRightArrow,
    	DoubleRightTee: DoubleRightTee,
    	DoubleUpArrow: DoubleUpArrow,
    	DoubleUpDownArrow: DoubleUpDownArrow,
    	DoubleVerticalBar: DoubleVerticalBar,
    	DownArrowBar: DownArrowBar,
    	downarrow: downarrow,
    	DownArrow: DownArrow,
    	Downarrow: Downarrow,
    	DownArrowUpArrow: DownArrowUpArrow,
    	DownBreve: DownBreve,
    	downdownarrows: downdownarrows,
    	downharpoonleft: downharpoonleft,
    	downharpoonright: downharpoonright,
    	DownLeftRightVector: DownLeftRightVector,
    	DownLeftTeeVector: DownLeftTeeVector,
    	DownLeftVectorBar: DownLeftVectorBar,
    	DownLeftVector: DownLeftVector,
    	DownRightTeeVector: DownRightTeeVector,
    	DownRightVectorBar: DownRightVectorBar,
    	DownRightVector: DownRightVector,
    	DownTeeArrow: DownTeeArrow,
    	DownTee: DownTee,
    	drbkarow: drbkarow,
    	drcorn: drcorn,
    	drcrop: drcrop,
    	Dscr: Dscr,
    	dscr: dscr,
    	DScy: DScy,
    	dscy: dscy,
    	dsol: dsol,
    	Dstrok: Dstrok,
    	dstrok: dstrok,
    	dtdot: dtdot,
    	dtri: dtri,
    	dtrif: dtrif,
    	duarr: duarr,
    	duhar: duhar,
    	dwangle: dwangle,
    	DZcy: DZcy,
    	dzcy: dzcy,
    	dzigrarr: dzigrarr,
    	Eacute: Eacute$1,
    	eacute: eacute$1,
    	easter: easter,
    	Ecaron: Ecaron,
    	ecaron: ecaron,
    	Ecirc: Ecirc$1,
    	ecirc: ecirc$1,
    	ecir: ecir,
    	ecolon: ecolon,
    	Ecy: Ecy,
    	ecy: ecy,
    	eDDot: eDDot,
    	Edot: Edot,
    	edot: edot,
    	eDot: eDot,
    	ee: ee,
    	efDot: efDot,
    	Efr: Efr,
    	efr: efr,
    	eg: eg,
    	Egrave: Egrave$1,
    	egrave: egrave$1,
    	egs: egs,
    	egsdot: egsdot,
    	el: el,
    	Element: Element,
    	elinters: elinters,
    	ell: ell,
    	els: els,
    	elsdot: elsdot,
    	Emacr: Emacr,
    	emacr: emacr,
    	empty: empty,
    	emptyset: emptyset,
    	EmptySmallSquare: EmptySmallSquare,
    	emptyv: emptyv,
    	EmptyVerySmallSquare: EmptyVerySmallSquare,
    	emsp13: emsp13,
    	emsp14: emsp14,
    	emsp: emsp,
    	ENG: ENG,
    	eng: eng,
    	ensp: ensp,
    	Eogon: Eogon,
    	eogon: eogon,
    	Eopf: Eopf,
    	eopf: eopf,
    	epar: epar,
    	eparsl: eparsl,
    	eplus: eplus,
    	epsi: epsi,
    	Epsilon: Epsilon,
    	epsilon: epsilon,
    	epsiv: epsiv,
    	eqcirc: eqcirc,
    	eqcolon: eqcolon,
    	eqsim: eqsim,
    	eqslantgtr: eqslantgtr,
    	eqslantless: eqslantless,
    	Equal: Equal,
    	equals: equals,
    	EqualTilde: EqualTilde,
    	equest: equest,
    	Equilibrium: Equilibrium,
    	equiv: equiv,
    	equivDD: equivDD,
    	eqvparsl: eqvparsl,
    	erarr: erarr,
    	erDot: erDot,
    	escr: escr,
    	Escr: Escr,
    	esdot: esdot,
    	Esim: Esim,
    	esim: esim,
    	Eta: Eta,
    	eta: eta,
    	ETH: ETH$1,
    	eth: eth$1,
    	Euml: Euml$1,
    	euml: euml$1,
    	euro: euro,
    	excl: excl,
    	exist: exist,
    	Exists: Exists,
    	expectation: expectation,
    	exponentiale: exponentiale,
    	ExponentialE: ExponentialE,
    	fallingdotseq: fallingdotseq,
    	Fcy: Fcy,
    	fcy: fcy,
    	female: female,
    	ffilig: ffilig,
    	fflig: fflig,
    	ffllig: ffllig,
    	Ffr: Ffr,
    	ffr: ffr,
    	filig: filig,
    	FilledSmallSquare: FilledSmallSquare,
    	FilledVerySmallSquare: FilledVerySmallSquare,
    	fjlig: fjlig,
    	flat: flat,
    	fllig: fllig,
    	fltns: fltns,
    	fnof: fnof,
    	Fopf: Fopf,
    	fopf: fopf,
    	forall: forall,
    	ForAll: ForAll,
    	fork: fork,
    	forkv: forkv,
    	Fouriertrf: Fouriertrf,
    	fpartint: fpartint,
    	frac12: frac12$1,
    	frac13: frac13,
    	frac14: frac14$1,
    	frac15: frac15,
    	frac16: frac16,
    	frac18: frac18,
    	frac23: frac23,
    	frac25: frac25,
    	frac34: frac34$1,
    	frac35: frac35,
    	frac38: frac38,
    	frac45: frac45,
    	frac56: frac56,
    	frac58: frac58,
    	frac78: frac78,
    	frasl: frasl,
    	frown: frown,
    	fscr: fscr,
    	Fscr: Fscr,
    	gacute: gacute,
    	Gamma: Gamma,
    	gamma: gamma,
    	Gammad: Gammad,
    	gammad: gammad,
    	gap: gap,
    	Gbreve: Gbreve,
    	gbreve: gbreve,
    	Gcedil: Gcedil,
    	Gcirc: Gcirc,
    	gcirc: gcirc,
    	Gcy: Gcy,
    	gcy: gcy,
    	Gdot: Gdot,
    	gdot: gdot,
    	ge: ge,
    	gE: gE,
    	gEl: gEl,
    	gel: gel,
    	geq: geq,
    	geqq: geqq,
    	geqslant: geqslant,
    	gescc: gescc,
    	ges: ges,
    	gesdot: gesdot,
    	gesdoto: gesdoto,
    	gesdotol: gesdotol,
    	gesl: gesl,
    	gesles: gesles,
    	Gfr: Gfr,
    	gfr: gfr,
    	gg: gg,
    	Gg: Gg,
    	ggg: ggg,
    	gimel: gimel,
    	GJcy: GJcy,
    	gjcy: gjcy,
    	gla: gla,
    	gl: gl,
    	glE: glE,
    	glj: glj,
    	gnap: gnap,
    	gnapprox: gnapprox,
    	gne: gne,
    	gnE: gnE,
    	gneq: gneq,
    	gneqq: gneqq,
    	gnsim: gnsim,
    	Gopf: Gopf,
    	gopf: gopf,
    	grave: grave,
    	GreaterEqual: GreaterEqual,
    	GreaterEqualLess: GreaterEqualLess,
    	GreaterFullEqual: GreaterFullEqual,
    	GreaterGreater: GreaterGreater,
    	GreaterLess: GreaterLess,
    	GreaterSlantEqual: GreaterSlantEqual,
    	GreaterTilde: GreaterTilde,
    	Gscr: Gscr,
    	gscr: gscr,
    	gsim: gsim,
    	gsime: gsime,
    	gsiml: gsiml,
    	gtcc: gtcc,
    	gtcir: gtcir,
    	gt: gt$3,
    	GT: GT$1,
    	Gt: Gt,
    	gtdot: gtdot,
    	gtlPar: gtlPar,
    	gtquest: gtquest,
    	gtrapprox: gtrapprox,
    	gtrarr: gtrarr,
    	gtrdot: gtrdot,
    	gtreqless: gtreqless,
    	gtreqqless: gtreqqless,
    	gtrless: gtrless,
    	gtrsim: gtrsim,
    	gvertneqq: gvertneqq,
    	gvnE: gvnE,
    	Hacek: Hacek,
    	hairsp: hairsp,
    	half: half,
    	hamilt: hamilt,
    	HARDcy: HARDcy,
    	hardcy: hardcy,
    	harrcir: harrcir,
    	harr: harr,
    	hArr: hArr,
    	harrw: harrw,
    	Hat: Hat,
    	hbar: hbar,
    	Hcirc: Hcirc,
    	hcirc: hcirc,
    	hearts: hearts,
    	heartsuit: heartsuit,
    	hellip: hellip,
    	hercon: hercon,
    	hfr: hfr,
    	Hfr: Hfr,
    	HilbertSpace: HilbertSpace,
    	hksearow: hksearow,
    	hkswarow: hkswarow,
    	hoarr: hoarr,
    	homtht: homtht,
    	hookleftarrow: hookleftarrow,
    	hookrightarrow: hookrightarrow,
    	hopf: hopf,
    	Hopf: Hopf,
    	horbar: horbar,
    	HorizontalLine: HorizontalLine,
    	hscr: hscr,
    	Hscr: Hscr,
    	hslash: hslash,
    	Hstrok: Hstrok,
    	hstrok: hstrok,
    	HumpDownHump: HumpDownHump,
    	HumpEqual: HumpEqual,
    	hybull: hybull,
    	hyphen: hyphen,
    	Iacute: Iacute$1,
    	iacute: iacute$1,
    	ic: ic,
    	Icirc: Icirc$1,
    	icirc: icirc$1,
    	Icy: Icy,
    	icy: icy,
    	Idot: Idot,
    	IEcy: IEcy,
    	iecy: iecy,
    	iexcl: iexcl$1,
    	iff: iff,
    	ifr: ifr,
    	Ifr: Ifr,
    	Igrave: Igrave$1,
    	igrave: igrave$1,
    	ii: ii,
    	iiiint: iiiint,
    	iiint: iiint,
    	iinfin: iinfin,
    	iiota: iiota,
    	IJlig: IJlig,
    	ijlig: ijlig,
    	Imacr: Imacr,
    	imacr: imacr,
    	image: image,
    	ImaginaryI: ImaginaryI,
    	imagline: imagline,
    	imagpart: imagpart,
    	imath: imath,
    	Im: Im,
    	imof: imof,
    	imped: imped,
    	Implies: Implies,
    	incare: incare,
    	"in": "∈",
    	infin: infin,
    	infintie: infintie,
    	inodot: inodot,
    	intcal: intcal,
    	int: int,
    	Int: Int,
    	integers: integers,
    	Integral: Integral,
    	intercal: intercal,
    	Intersection: Intersection,
    	intlarhk: intlarhk,
    	intprod: intprod,
    	InvisibleComma: InvisibleComma,
    	InvisibleTimes: InvisibleTimes,
    	IOcy: IOcy,
    	iocy: iocy,
    	Iogon: Iogon,
    	iogon: iogon,
    	Iopf: Iopf,
    	iopf: iopf,
    	Iota: Iota,
    	iota: iota,
    	iprod: iprod,
    	iquest: iquest$1,
    	iscr: iscr,
    	Iscr: Iscr,
    	isin: isin,
    	isindot: isindot,
    	isinE: isinE,
    	isins: isins,
    	isinsv: isinsv,
    	isinv: isinv,
    	it: it,
    	Itilde: Itilde,
    	itilde: itilde,
    	Iukcy: Iukcy,
    	iukcy: iukcy,
    	Iuml: Iuml$1,
    	iuml: iuml$1,
    	Jcirc: Jcirc,
    	jcirc: jcirc,
    	Jcy: Jcy,
    	jcy: jcy,
    	Jfr: Jfr,
    	jfr: jfr,
    	jmath: jmath,
    	Jopf: Jopf,
    	jopf: jopf,
    	Jscr: Jscr,
    	jscr: jscr,
    	Jsercy: Jsercy,
    	jsercy: jsercy,
    	Jukcy: Jukcy,
    	jukcy: jukcy,
    	Kappa: Kappa,
    	kappa: kappa,
    	kappav: kappav,
    	Kcedil: Kcedil,
    	kcedil: kcedil,
    	Kcy: Kcy,
    	kcy: kcy,
    	Kfr: Kfr,
    	kfr: kfr,
    	kgreen: kgreen,
    	KHcy: KHcy,
    	khcy: khcy,
    	KJcy: KJcy,
    	kjcy: kjcy,
    	Kopf: Kopf,
    	kopf: kopf,
    	Kscr: Kscr,
    	kscr: kscr,
    	lAarr: lAarr,
    	Lacute: Lacute,
    	lacute: lacute,
    	laemptyv: laemptyv,
    	lagran: lagran,
    	Lambda: Lambda,
    	lambda: lambda,
    	lang: lang,
    	Lang: Lang,
    	langd: langd,
    	langle: langle,
    	lap: lap,
    	Laplacetrf: Laplacetrf,
    	laquo: laquo$1,
    	larrb: larrb,
    	larrbfs: larrbfs,
    	larr: larr,
    	Larr: Larr,
    	lArr: lArr,
    	larrfs: larrfs,
    	larrhk: larrhk,
    	larrlp: larrlp,
    	larrpl: larrpl,
    	larrsim: larrsim,
    	larrtl: larrtl,
    	latail: latail,
    	lAtail: lAtail,
    	lat: lat,
    	late: late,
    	lates: lates,
    	lbarr: lbarr,
    	lBarr: lBarr,
    	lbbrk: lbbrk,
    	lbrace: lbrace,
    	lbrack: lbrack,
    	lbrke: lbrke,
    	lbrksld: lbrksld,
    	lbrkslu: lbrkslu,
    	Lcaron: Lcaron,
    	lcaron: lcaron,
    	Lcedil: Lcedil,
    	lcedil: lcedil,
    	lceil: lceil,
    	lcub: lcub,
    	Lcy: Lcy,
    	lcy: lcy,
    	ldca: ldca,
    	ldquo: ldquo,
    	ldquor: ldquor,
    	ldrdhar: ldrdhar,
    	ldrushar: ldrushar,
    	ldsh: ldsh,
    	le: le,
    	lE: lE,
    	LeftAngleBracket: LeftAngleBracket,
    	LeftArrowBar: LeftArrowBar,
    	leftarrow: leftarrow,
    	LeftArrow: LeftArrow,
    	Leftarrow: Leftarrow,
    	LeftArrowRightArrow: LeftArrowRightArrow,
    	leftarrowtail: leftarrowtail,
    	LeftCeiling: LeftCeiling,
    	LeftDoubleBracket: LeftDoubleBracket,
    	LeftDownTeeVector: LeftDownTeeVector,
    	LeftDownVectorBar: LeftDownVectorBar,
    	LeftDownVector: LeftDownVector,
    	LeftFloor: LeftFloor,
    	leftharpoondown: leftharpoondown,
    	leftharpoonup: leftharpoonup,
    	leftleftarrows: leftleftarrows,
    	leftrightarrow: leftrightarrow,
    	LeftRightArrow: LeftRightArrow,
    	Leftrightarrow: Leftrightarrow,
    	leftrightarrows: leftrightarrows,
    	leftrightharpoons: leftrightharpoons,
    	leftrightsquigarrow: leftrightsquigarrow,
    	LeftRightVector: LeftRightVector,
    	LeftTeeArrow: LeftTeeArrow,
    	LeftTee: LeftTee,
    	LeftTeeVector: LeftTeeVector,
    	leftthreetimes: leftthreetimes,
    	LeftTriangleBar: LeftTriangleBar,
    	LeftTriangle: LeftTriangle,
    	LeftTriangleEqual: LeftTriangleEqual,
    	LeftUpDownVector: LeftUpDownVector,
    	LeftUpTeeVector: LeftUpTeeVector,
    	LeftUpVectorBar: LeftUpVectorBar,
    	LeftUpVector: LeftUpVector,
    	LeftVectorBar: LeftVectorBar,
    	LeftVector: LeftVector,
    	lEg: lEg,
    	leg: leg,
    	leq: leq,
    	leqq: leqq,
    	leqslant: leqslant,
    	lescc: lescc,
    	les: les,
    	lesdot: lesdot,
    	lesdoto: lesdoto,
    	lesdotor: lesdotor,
    	lesg: lesg,
    	lesges: lesges,
    	lessapprox: lessapprox,
    	lessdot: lessdot,
    	lesseqgtr: lesseqgtr,
    	lesseqqgtr: lesseqqgtr,
    	LessEqualGreater: LessEqualGreater,
    	LessFullEqual: LessFullEqual,
    	LessGreater: LessGreater,
    	lessgtr: lessgtr,
    	LessLess: LessLess,
    	lesssim: lesssim,
    	LessSlantEqual: LessSlantEqual,
    	LessTilde: LessTilde,
    	lfisht: lfisht,
    	lfloor: lfloor,
    	Lfr: Lfr,
    	lfr: lfr,
    	lg: lg,
    	lgE: lgE,
    	lHar: lHar,
    	lhard: lhard,
    	lharu: lharu,
    	lharul: lharul,
    	lhblk: lhblk,
    	LJcy: LJcy,
    	ljcy: ljcy,
    	llarr: llarr,
    	ll: ll,
    	Ll: Ll,
    	llcorner: llcorner,
    	Lleftarrow: Lleftarrow,
    	llhard: llhard,
    	lltri: lltri,
    	Lmidot: Lmidot,
    	lmidot: lmidot,
    	lmoustache: lmoustache,
    	lmoust: lmoust,
    	lnap: lnap,
    	lnapprox: lnapprox,
    	lne: lne,
    	lnE: lnE,
    	lneq: lneq,
    	lneqq: lneqq,
    	lnsim: lnsim,
    	loang: loang,
    	loarr: loarr,
    	lobrk: lobrk,
    	longleftarrow: longleftarrow,
    	LongLeftArrow: LongLeftArrow,
    	Longleftarrow: Longleftarrow,
    	longleftrightarrow: longleftrightarrow,
    	LongLeftRightArrow: LongLeftRightArrow,
    	Longleftrightarrow: Longleftrightarrow,
    	longmapsto: longmapsto,
    	longrightarrow: longrightarrow,
    	LongRightArrow: LongRightArrow,
    	Longrightarrow: Longrightarrow,
    	looparrowleft: looparrowleft,
    	looparrowright: looparrowright,
    	lopar: lopar,
    	Lopf: Lopf,
    	lopf: lopf,
    	loplus: loplus,
    	lotimes: lotimes,
    	lowast: lowast,
    	lowbar: lowbar,
    	LowerLeftArrow: LowerLeftArrow,
    	LowerRightArrow: LowerRightArrow,
    	loz: loz,
    	lozenge: lozenge,
    	lozf: lozf,
    	lpar: lpar,
    	lparlt: lparlt,
    	lrarr: lrarr,
    	lrcorner: lrcorner,
    	lrhar: lrhar,
    	lrhard: lrhard,
    	lrm: lrm,
    	lrtri: lrtri,
    	lsaquo: lsaquo,
    	lscr: lscr,
    	Lscr: Lscr,
    	lsh: lsh,
    	Lsh: Lsh,
    	lsim: lsim,
    	lsime: lsime,
    	lsimg: lsimg,
    	lsqb: lsqb,
    	lsquo: lsquo,
    	lsquor: lsquor,
    	Lstrok: Lstrok,
    	lstrok: lstrok,
    	ltcc: ltcc,
    	ltcir: ltcir,
    	lt: lt$2,
    	LT: LT$1,
    	Lt: Lt,
    	ltdot: ltdot,
    	lthree: lthree,
    	ltimes: ltimes,
    	ltlarr: ltlarr,
    	ltquest: ltquest,
    	ltri: ltri,
    	ltrie: ltrie,
    	ltrif: ltrif,
    	ltrPar: ltrPar,
    	lurdshar: lurdshar,
    	luruhar: luruhar,
    	lvertneqq: lvertneqq,
    	lvnE: lvnE,
    	macr: macr$1,
    	male: male,
    	malt: malt,
    	maltese: maltese,
    	"Map": "⤅",
    	map: map,
    	mapsto: mapsto,
    	mapstodown: mapstodown,
    	mapstoleft: mapstoleft,
    	mapstoup: mapstoup,
    	marker: marker,
    	mcomma: mcomma,
    	Mcy: Mcy,
    	mcy: mcy,
    	mdash: mdash,
    	mDDot: mDDot,
    	measuredangle: measuredangle,
    	MediumSpace: MediumSpace,
    	Mellintrf: Mellintrf,
    	Mfr: Mfr,
    	mfr: mfr,
    	mho: mho,
    	micro: micro$1,
    	midast: midast,
    	midcir: midcir,
    	mid: mid,
    	middot: middot$1,
    	minusb: minusb,
    	minus: minus,
    	minusd: minusd,
    	minusdu: minusdu,
    	MinusPlus: MinusPlus,
    	mlcp: mlcp,
    	mldr: mldr,
    	mnplus: mnplus,
    	models: models,
    	Mopf: Mopf,
    	mopf: mopf,
    	mp: mp,
    	mscr: mscr,
    	Mscr: Mscr,
    	mstpos: mstpos,
    	Mu: Mu,
    	mu: mu,
    	multimap: multimap,
    	mumap: mumap,
    	nabla: nabla,
    	Nacute: Nacute,
    	nacute: nacute,
    	nang: nang,
    	nap: nap,
    	napE: napE,
    	napid: napid,
    	napos: napos,
    	napprox: napprox,
    	natural: natural,
    	naturals: naturals,
    	natur: natur,
    	nbsp: nbsp$1,
    	nbump: nbump,
    	nbumpe: nbumpe,
    	ncap: ncap,
    	Ncaron: Ncaron,
    	ncaron: ncaron,
    	Ncedil: Ncedil,
    	ncedil: ncedil,
    	ncong: ncong,
    	ncongdot: ncongdot,
    	ncup: ncup,
    	Ncy: Ncy,
    	ncy: ncy,
    	ndash: ndash,
    	nearhk: nearhk,
    	nearr: nearr,
    	neArr: neArr,
    	nearrow: nearrow,
    	ne: ne,
    	nedot: nedot,
    	NegativeMediumSpace: NegativeMediumSpace,
    	NegativeThickSpace: NegativeThickSpace,
    	NegativeThinSpace: NegativeThinSpace,
    	NegativeVeryThinSpace: NegativeVeryThinSpace,
    	nequiv: nequiv,
    	nesear: nesear,
    	nesim: nesim,
    	NestedGreaterGreater: NestedGreaterGreater,
    	NestedLessLess: NestedLessLess,
    	NewLine: NewLine,
    	nexist: nexist,
    	nexists: nexists,
    	Nfr: Nfr,
    	nfr: nfr,
    	ngE: ngE,
    	nge: nge,
    	ngeq: ngeq,
    	ngeqq: ngeqq,
    	ngeqslant: ngeqslant,
    	nges: nges,
    	nGg: nGg,
    	ngsim: ngsim,
    	nGt: nGt,
    	ngt: ngt,
    	ngtr: ngtr,
    	nGtv: nGtv,
    	nharr: nharr,
    	nhArr: nhArr,
    	nhpar: nhpar,
    	ni: ni,
    	nis: nis,
    	nisd: nisd,
    	niv: niv,
    	NJcy: NJcy,
    	njcy: njcy,
    	nlarr: nlarr,
    	nlArr: nlArr,
    	nldr: nldr,
    	nlE: nlE,
    	nle: nle,
    	nleftarrow: nleftarrow,
    	nLeftarrow: nLeftarrow,
    	nleftrightarrow: nleftrightarrow,
    	nLeftrightarrow: nLeftrightarrow,
    	nleq: nleq,
    	nleqq: nleqq,
    	nleqslant: nleqslant,
    	nles: nles,
    	nless: nless,
    	nLl: nLl,
    	nlsim: nlsim,
    	nLt: nLt,
    	nlt: nlt,
    	nltri: nltri,
    	nltrie: nltrie,
    	nLtv: nLtv,
    	nmid: nmid,
    	NoBreak: NoBreak,
    	NonBreakingSpace: NonBreakingSpace,
    	nopf: nopf,
    	Nopf: Nopf,
    	Not: Not,
    	not: not$1,
    	NotCongruent: NotCongruent,
    	NotCupCap: NotCupCap,
    	NotDoubleVerticalBar: NotDoubleVerticalBar,
    	NotElement: NotElement,
    	NotEqual: NotEqual,
    	NotEqualTilde: NotEqualTilde,
    	NotExists: NotExists,
    	NotGreater: NotGreater,
    	NotGreaterEqual: NotGreaterEqual,
    	NotGreaterFullEqual: NotGreaterFullEqual,
    	NotGreaterGreater: NotGreaterGreater,
    	NotGreaterLess: NotGreaterLess,
    	NotGreaterSlantEqual: NotGreaterSlantEqual,
    	NotGreaterTilde: NotGreaterTilde,
    	NotHumpDownHump: NotHumpDownHump,
    	NotHumpEqual: NotHumpEqual,
    	notin: notin,
    	notindot: notindot,
    	notinE: notinE,
    	notinva: notinva,
    	notinvb: notinvb,
    	notinvc: notinvc,
    	NotLeftTriangleBar: NotLeftTriangleBar,
    	NotLeftTriangle: NotLeftTriangle,
    	NotLeftTriangleEqual: NotLeftTriangleEqual,
    	NotLess: NotLess,
    	NotLessEqual: NotLessEqual,
    	NotLessGreater: NotLessGreater,
    	NotLessLess: NotLessLess,
    	NotLessSlantEqual: NotLessSlantEqual,
    	NotLessTilde: NotLessTilde,
    	NotNestedGreaterGreater: NotNestedGreaterGreater,
    	NotNestedLessLess: NotNestedLessLess,
    	notni: notni,
    	notniva: notniva,
    	notnivb: notnivb,
    	notnivc: notnivc,
    	NotPrecedes: NotPrecedes,
    	NotPrecedesEqual: NotPrecedesEqual,
    	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
    	NotReverseElement: NotReverseElement,
    	NotRightTriangleBar: NotRightTriangleBar,
    	NotRightTriangle: NotRightTriangle,
    	NotRightTriangleEqual: NotRightTriangleEqual,
    	NotSquareSubset: NotSquareSubset,
    	NotSquareSubsetEqual: NotSquareSubsetEqual,
    	NotSquareSuperset: NotSquareSuperset,
    	NotSquareSupersetEqual: NotSquareSupersetEqual,
    	NotSubset: NotSubset,
    	NotSubsetEqual: NotSubsetEqual,
    	NotSucceeds: NotSucceeds,
    	NotSucceedsEqual: NotSucceedsEqual,
    	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
    	NotSucceedsTilde: NotSucceedsTilde,
    	NotSuperset: NotSuperset,
    	NotSupersetEqual: NotSupersetEqual,
    	NotTilde: NotTilde,
    	NotTildeEqual: NotTildeEqual,
    	NotTildeFullEqual: NotTildeFullEqual,
    	NotTildeTilde: NotTildeTilde,
    	NotVerticalBar: NotVerticalBar,
    	nparallel: nparallel,
    	npar: npar,
    	nparsl: nparsl,
    	npart: npart,
    	npolint: npolint,
    	npr: npr,
    	nprcue: nprcue,
    	nprec: nprec,
    	npreceq: npreceq,
    	npre: npre,
    	nrarrc: nrarrc,
    	nrarr: nrarr,
    	nrArr: nrArr,
    	nrarrw: nrarrw,
    	nrightarrow: nrightarrow,
    	nRightarrow: nRightarrow,
    	nrtri: nrtri,
    	nrtrie: nrtrie,
    	nsc: nsc,
    	nsccue: nsccue,
    	nsce: nsce,
    	Nscr: Nscr,
    	nscr: nscr,
    	nshortmid: nshortmid,
    	nshortparallel: nshortparallel,
    	nsim: nsim,
    	nsime: nsime,
    	nsimeq: nsimeq,
    	nsmid: nsmid,
    	nspar: nspar,
    	nsqsube: nsqsube,
    	nsqsupe: nsqsupe,
    	nsub: nsub,
    	nsubE: nsubE,
    	nsube: nsube,
    	nsubset: nsubset,
    	nsubseteq: nsubseteq,
    	nsubseteqq: nsubseteqq,
    	nsucc: nsucc,
    	nsucceq: nsucceq,
    	nsup: nsup,
    	nsupE: nsupE,
    	nsupe: nsupe,
    	nsupset: nsupset,
    	nsupseteq: nsupseteq,
    	nsupseteqq: nsupseteqq,
    	ntgl: ntgl,
    	Ntilde: Ntilde$1,
    	ntilde: ntilde$1,
    	ntlg: ntlg,
    	ntriangleleft: ntriangleleft,
    	ntrianglelefteq: ntrianglelefteq,
    	ntriangleright: ntriangleright,
    	ntrianglerighteq: ntrianglerighteq,
    	Nu: Nu,
    	nu: nu,
    	num: num,
    	numero: numero,
    	numsp: numsp,
    	nvap: nvap,
    	nvdash: nvdash,
    	nvDash: nvDash,
    	nVdash: nVdash,
    	nVDash: nVDash,
    	nvge: nvge,
    	nvgt: nvgt,
    	nvHarr: nvHarr,
    	nvinfin: nvinfin,
    	nvlArr: nvlArr,
    	nvle: nvle,
    	nvlt: nvlt,
    	nvltrie: nvltrie,
    	nvrArr: nvrArr,
    	nvrtrie: nvrtrie,
    	nvsim: nvsim,
    	nwarhk: nwarhk,
    	nwarr: nwarr,
    	nwArr: nwArr,
    	nwarrow: nwarrow,
    	nwnear: nwnear,
    	Oacute: Oacute$1,
    	oacute: oacute$1,
    	oast: oast,
    	Ocirc: Ocirc$1,
    	ocirc: ocirc$1,
    	ocir: ocir,
    	Ocy: Ocy,
    	ocy: ocy,
    	odash: odash,
    	Odblac: Odblac,
    	odblac: odblac,
    	odiv: odiv,
    	odot: odot,
    	odsold: odsold,
    	OElig: OElig,
    	oelig: oelig,
    	ofcir: ofcir,
    	Ofr: Ofr,
    	ofr: ofr,
    	ogon: ogon,
    	Ograve: Ograve$1,
    	ograve: ograve$1,
    	ogt: ogt,
    	ohbar: ohbar,
    	ohm: ohm,
    	oint: oint,
    	olarr: olarr,
    	olcir: olcir,
    	olcross: olcross,
    	oline: oline,
    	olt: olt,
    	Omacr: Omacr,
    	omacr: omacr,
    	Omega: Omega,
    	omega: omega,
    	Omicron: Omicron,
    	omicron: omicron,
    	omid: omid,
    	ominus: ominus,
    	Oopf: Oopf,
    	oopf: oopf,
    	opar: opar,
    	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
    	OpenCurlyQuote: OpenCurlyQuote,
    	operp: operp,
    	oplus: oplus,
    	orarr: orarr,
    	Or: Or,
    	or: or,
    	ord: ord,
    	order: order,
    	orderof: orderof,
    	ordf: ordf$1,
    	ordm: ordm$1,
    	origof: origof,
    	oror: oror,
    	orslope: orslope,
    	orv: orv,
    	oS: oS,
    	Oscr: Oscr,
    	oscr: oscr,
    	Oslash: Oslash$1,
    	oslash: oslash$1,
    	osol: osol,
    	Otilde: Otilde$1,
    	otilde: otilde$1,
    	otimesas: otimesas,
    	Otimes: Otimes,
    	otimes: otimes,
    	Ouml: Ouml$1,
    	ouml: ouml$1,
    	ovbar: ovbar,
    	OverBar: OverBar,
    	OverBrace: OverBrace,
    	OverBracket: OverBracket,
    	OverParenthesis: OverParenthesis,
    	para: para$1,
    	parallel: parallel,
    	par: par,
    	parsim: parsim,
    	parsl: parsl,
    	part: part,
    	PartialD: PartialD,
    	Pcy: Pcy,
    	pcy: pcy,
    	percnt: percnt,
    	period: period,
    	permil: permil,
    	perp: perp,
    	pertenk: pertenk,
    	Pfr: Pfr,
    	pfr: pfr,
    	Phi: Phi,
    	phi: phi,
    	phiv: phiv,
    	phmmat: phmmat,
    	phone: phone,
    	Pi: Pi,
    	pi: pi,
    	pitchfork: pitchfork,
    	piv: piv,
    	planck: planck,
    	planckh: planckh,
    	plankv: plankv,
    	plusacir: plusacir,
    	plusb: plusb,
    	pluscir: pluscir,
    	plus: plus$1,
    	plusdo: plusdo,
    	plusdu: plusdu,
    	pluse: pluse,
    	PlusMinus: PlusMinus,
    	plusmn: plusmn$1,
    	plussim: plussim,
    	plustwo: plustwo,
    	pm: pm,
    	Poincareplane: Poincareplane,
    	pointint: pointint,
    	popf: popf,
    	Popf: Popf,
    	pound: pound$1,
    	prap: prap,
    	Pr: Pr,
    	pr: pr,
    	prcue: prcue,
    	precapprox: precapprox,
    	prec: prec,
    	preccurlyeq: preccurlyeq,
    	Precedes: Precedes,
    	PrecedesEqual: PrecedesEqual,
    	PrecedesSlantEqual: PrecedesSlantEqual,
    	PrecedesTilde: PrecedesTilde,
    	preceq: preceq,
    	precnapprox: precnapprox,
    	precneqq: precneqq,
    	precnsim: precnsim,
    	pre: pre,
    	prE: prE,
    	precsim: precsim,
    	prime: prime,
    	Prime: Prime,
    	primes: primes,
    	prnap: prnap,
    	prnE: prnE,
    	prnsim: prnsim,
    	prod: prod,
    	Product: Product,
    	profalar: profalar,
    	profline: profline,
    	profsurf: profsurf,
    	prop: prop,
    	Proportional: Proportional,
    	Proportion: Proportion,
    	propto: propto,
    	prsim: prsim,
    	prurel: prurel,
    	Pscr: Pscr,
    	pscr: pscr,
    	Psi: Psi,
    	psi: psi,
    	puncsp: puncsp,
    	Qfr: Qfr,
    	qfr: qfr,
    	qint: qint,
    	qopf: qopf,
    	Qopf: Qopf,
    	qprime: qprime,
    	Qscr: Qscr,
    	qscr: qscr,
    	quaternions: quaternions,
    	quatint: quatint,
    	quest: quest,
    	questeq: questeq,
    	quot: quot$2,
    	QUOT: QUOT$1,
    	rAarr: rAarr,
    	race: race,
    	Racute: Racute,
    	racute: racute,
    	radic: radic,
    	raemptyv: raemptyv,
    	rang: rang,
    	Rang: Rang,
    	rangd: rangd,
    	range: range,
    	rangle: rangle,
    	raquo: raquo$1,
    	rarrap: rarrap,
    	rarrb: rarrb,
    	rarrbfs: rarrbfs,
    	rarrc: rarrc,
    	rarr: rarr,
    	Rarr: Rarr,
    	rArr: rArr,
    	rarrfs: rarrfs,
    	rarrhk: rarrhk,
    	rarrlp: rarrlp,
    	rarrpl: rarrpl,
    	rarrsim: rarrsim,
    	Rarrtl: Rarrtl,
    	rarrtl: rarrtl,
    	rarrw: rarrw,
    	ratail: ratail,
    	rAtail: rAtail,
    	ratio: ratio,
    	rationals: rationals,
    	rbarr: rbarr,
    	rBarr: rBarr,
    	RBarr: RBarr,
    	rbbrk: rbbrk,
    	rbrace: rbrace,
    	rbrack: rbrack,
    	rbrke: rbrke,
    	rbrksld: rbrksld,
    	rbrkslu: rbrkslu,
    	Rcaron: Rcaron,
    	rcaron: rcaron,
    	Rcedil: Rcedil,
    	rcedil: rcedil,
    	rceil: rceil,
    	rcub: rcub,
    	Rcy: Rcy,
    	rcy: rcy,
    	rdca: rdca,
    	rdldhar: rdldhar,
    	rdquo: rdquo,
    	rdquor: rdquor,
    	rdsh: rdsh,
    	real: real,
    	realine: realine,
    	realpart: realpart,
    	reals: reals,
    	Re: Re,
    	rect: rect,
    	reg: reg$1,
    	REG: REG$1,
    	ReverseElement: ReverseElement,
    	ReverseEquilibrium: ReverseEquilibrium,
    	ReverseUpEquilibrium: ReverseUpEquilibrium,
    	rfisht: rfisht,
    	rfloor: rfloor,
    	rfr: rfr,
    	Rfr: Rfr,
    	rHar: rHar,
    	rhard: rhard,
    	rharu: rharu,
    	rharul: rharul,
    	Rho: Rho,
    	rho: rho,
    	rhov: rhov,
    	RightAngleBracket: RightAngleBracket,
    	RightArrowBar: RightArrowBar,
    	rightarrow: rightarrow,
    	RightArrow: RightArrow,
    	Rightarrow: Rightarrow,
    	RightArrowLeftArrow: RightArrowLeftArrow,
    	rightarrowtail: rightarrowtail,
    	RightCeiling: RightCeiling,
    	RightDoubleBracket: RightDoubleBracket,
    	RightDownTeeVector: RightDownTeeVector,
    	RightDownVectorBar: RightDownVectorBar,
    	RightDownVector: RightDownVector,
    	RightFloor: RightFloor,
    	rightharpoondown: rightharpoondown,
    	rightharpoonup: rightharpoonup,
    	rightleftarrows: rightleftarrows,
    	rightleftharpoons: rightleftharpoons,
    	rightrightarrows: rightrightarrows,
    	rightsquigarrow: rightsquigarrow,
    	RightTeeArrow: RightTeeArrow,
    	RightTee: RightTee,
    	RightTeeVector: RightTeeVector,
    	rightthreetimes: rightthreetimes,
    	RightTriangleBar: RightTriangleBar,
    	RightTriangle: RightTriangle,
    	RightTriangleEqual: RightTriangleEqual,
    	RightUpDownVector: RightUpDownVector,
    	RightUpTeeVector: RightUpTeeVector,
    	RightUpVectorBar: RightUpVectorBar,
    	RightUpVector: RightUpVector,
    	RightVectorBar: RightVectorBar,
    	RightVector: RightVector,
    	ring: ring,
    	risingdotseq: risingdotseq,
    	rlarr: rlarr,
    	rlhar: rlhar,
    	rlm: rlm,
    	rmoustache: rmoustache,
    	rmoust: rmoust,
    	rnmid: rnmid,
    	roang: roang,
    	roarr: roarr,
    	robrk: robrk,
    	ropar: ropar,
    	ropf: ropf,
    	Ropf: Ropf,
    	roplus: roplus,
    	rotimes: rotimes,
    	RoundImplies: RoundImplies,
    	rpar: rpar,
    	rpargt: rpargt,
    	rppolint: rppolint,
    	rrarr: rrarr,
    	Rrightarrow: Rrightarrow,
    	rsaquo: rsaquo,
    	rscr: rscr,
    	Rscr: Rscr,
    	rsh: rsh,
    	Rsh: Rsh,
    	rsqb: rsqb,
    	rsquo: rsquo,
    	rsquor: rsquor,
    	rthree: rthree,
    	rtimes: rtimes,
    	rtri: rtri,
    	rtrie: rtrie,
    	rtrif: rtrif,
    	rtriltri: rtriltri,
    	RuleDelayed: RuleDelayed,
    	ruluhar: ruluhar,
    	rx: rx,
    	Sacute: Sacute,
    	sacute: sacute,
    	sbquo: sbquo,
    	scap: scap,
    	Scaron: Scaron,
    	scaron: scaron,
    	Sc: Sc,
    	sc: sc,
    	sccue: sccue,
    	sce: sce,
    	scE: scE,
    	Scedil: Scedil,
    	scedil: scedil,
    	Scirc: Scirc,
    	scirc: scirc,
    	scnap: scnap,
    	scnE: scnE,
    	scnsim: scnsim,
    	scpolint: scpolint,
    	scsim: scsim,
    	Scy: Scy,
    	scy: scy,
    	sdotb: sdotb,
    	sdot: sdot,
    	sdote: sdote,
    	searhk: searhk,
    	searr: searr,
    	seArr: seArr,
    	searrow: searrow,
    	sect: sect$1,
    	semi: semi,
    	seswar: seswar,
    	setminus: setminus,
    	setmn: setmn,
    	sext: sext,
    	Sfr: Sfr,
    	sfr: sfr,
    	sfrown: sfrown,
    	sharp: sharp,
    	SHCHcy: SHCHcy,
    	shchcy: shchcy,
    	SHcy: SHcy,
    	shcy: shcy,
    	ShortDownArrow: ShortDownArrow,
    	ShortLeftArrow: ShortLeftArrow,
    	shortmid: shortmid,
    	shortparallel: shortparallel,
    	ShortRightArrow: ShortRightArrow,
    	ShortUpArrow: ShortUpArrow,
    	shy: shy$1,
    	Sigma: Sigma,
    	sigma: sigma,
    	sigmaf: sigmaf,
    	sigmav: sigmav,
    	sim: sim,
    	simdot: simdot,
    	sime: sime,
    	simeq: simeq,
    	simg: simg,
    	simgE: simgE,
    	siml: siml,
    	simlE: simlE,
    	simne: simne,
    	simplus: simplus,
    	simrarr: simrarr,
    	slarr: slarr,
    	SmallCircle: SmallCircle,
    	smallsetminus: smallsetminus,
    	smashp: smashp,
    	smeparsl: smeparsl,
    	smid: smid,
    	smile: smile,
    	smt: smt,
    	smte: smte,
    	smtes: smtes,
    	SOFTcy: SOFTcy,
    	softcy: softcy,
    	solbar: solbar,
    	solb: solb,
    	sol: sol,
    	Sopf: Sopf,
    	sopf: sopf,
    	spades: spades,
    	spadesuit: spadesuit,
    	spar: spar,
    	sqcap: sqcap,
    	sqcaps: sqcaps,
    	sqcup: sqcup,
    	sqcups: sqcups,
    	Sqrt: Sqrt,
    	sqsub: sqsub,
    	sqsube: sqsube,
    	sqsubset: sqsubset,
    	sqsubseteq: sqsubseteq,
    	sqsup: sqsup,
    	sqsupe: sqsupe,
    	sqsupset: sqsupset,
    	sqsupseteq: sqsupseteq,
    	square: square,
    	Square: Square,
    	SquareIntersection: SquareIntersection,
    	SquareSubset: SquareSubset,
    	SquareSubsetEqual: SquareSubsetEqual,
    	SquareSuperset: SquareSuperset,
    	SquareSupersetEqual: SquareSupersetEqual,
    	SquareUnion: SquareUnion,
    	squarf: squarf,
    	squ: squ,
    	squf: squf,
    	srarr: srarr,
    	Sscr: Sscr,
    	sscr: sscr,
    	ssetmn: ssetmn,
    	ssmile: ssmile,
    	sstarf: sstarf,
    	Star: Star,
    	star: star,
    	starf: starf,
    	straightepsilon: straightepsilon,
    	straightphi: straightphi,
    	strns: strns,
    	sub: sub,
    	Sub: Sub,
    	subdot: subdot,
    	subE: subE,
    	sube: sube,
    	subedot: subedot,
    	submult: submult,
    	subnE: subnE,
    	subne: subne,
    	subplus: subplus,
    	subrarr: subrarr,
    	subset: subset,
    	Subset: Subset,
    	subseteq: subseteq,
    	subseteqq: subseteqq,
    	SubsetEqual: SubsetEqual,
    	subsetneq: subsetneq,
    	subsetneqq: subsetneqq,
    	subsim: subsim,
    	subsub: subsub,
    	subsup: subsup,
    	succapprox: succapprox,
    	succ: succ,
    	succcurlyeq: succcurlyeq,
    	Succeeds: Succeeds,
    	SucceedsEqual: SucceedsEqual,
    	SucceedsSlantEqual: SucceedsSlantEqual,
    	SucceedsTilde: SucceedsTilde,
    	succeq: succeq,
    	succnapprox: succnapprox,
    	succneqq: succneqq,
    	succnsim: succnsim,
    	succsim: succsim,
    	SuchThat: SuchThat,
    	sum: sum,
    	Sum: Sum,
    	sung: sung,
    	sup1: sup1$1,
    	sup2: sup2$1,
    	sup3: sup3$1,
    	sup: sup,
    	Sup: Sup,
    	supdot: supdot,
    	supdsub: supdsub,
    	supE: supE,
    	supe: supe,
    	supedot: supedot,
    	Superset: Superset,
    	SupersetEqual: SupersetEqual,
    	suphsol: suphsol,
    	suphsub: suphsub,
    	suplarr: suplarr,
    	supmult: supmult,
    	supnE: supnE,
    	supne: supne,
    	supplus: supplus,
    	supset: supset,
    	Supset: Supset,
    	supseteq: supseteq,
    	supseteqq: supseteqq,
    	supsetneq: supsetneq,
    	supsetneqq: supsetneqq,
    	supsim: supsim,
    	supsub: supsub,
    	supsup: supsup,
    	swarhk: swarhk,
    	swarr: swarr,
    	swArr: swArr,
    	swarrow: swarrow,
    	swnwar: swnwar,
    	szlig: szlig$1,
    	Tab: Tab,
    	target: target,
    	Tau: Tau,
    	tau: tau,
    	tbrk: tbrk,
    	Tcaron: Tcaron,
    	tcaron: tcaron,
    	Tcedil: Tcedil,
    	tcedil: tcedil,
    	Tcy: Tcy,
    	tcy: tcy,
    	tdot: tdot,
    	telrec: telrec,
    	Tfr: Tfr,
    	tfr: tfr,
    	there4: there4,
    	therefore: therefore,
    	Therefore: Therefore,
    	Theta: Theta,
    	theta: theta,
    	thetasym: thetasym,
    	thetav: thetav,
    	thickapprox: thickapprox,
    	thicksim: thicksim,
    	ThickSpace: ThickSpace,
    	ThinSpace: ThinSpace,
    	thinsp: thinsp,
    	thkap: thkap,
    	thksim: thksim,
    	THORN: THORN$1,
    	thorn: thorn$1,
    	tilde: tilde$1,
    	Tilde: Tilde,
    	TildeEqual: TildeEqual,
    	TildeFullEqual: TildeFullEqual,
    	TildeTilde: TildeTilde,
    	timesbar: timesbar,
    	timesb: timesb,
    	times: times$1,
    	timesd: timesd,
    	tint: tint,
    	toea: toea,
    	topbot: topbot,
    	topcir: topcir,
    	top: top,
    	Topf: Topf,
    	topf: topf,
    	topfork: topfork,
    	tosa: tosa,
    	tprime: tprime,
    	trade: trade,
    	TRADE: TRADE,
    	triangle: triangle,
    	triangledown: triangledown,
    	triangleleft: triangleleft,
    	trianglelefteq: trianglelefteq,
    	triangleq: triangleq,
    	triangleright: triangleright,
    	trianglerighteq: trianglerighteq,
    	tridot: tridot,
    	trie: trie,
    	triminus: triminus,
    	TripleDot: TripleDot,
    	triplus: triplus,
    	trisb: trisb,
    	tritime: tritime,
    	trpezium: trpezium,
    	Tscr: Tscr,
    	tscr: tscr,
    	TScy: TScy,
    	tscy: tscy,
    	TSHcy: TSHcy,
    	tshcy: tshcy,
    	Tstrok: Tstrok,
    	tstrok: tstrok,
    	twixt: twixt,
    	twoheadleftarrow: twoheadleftarrow,
    	twoheadrightarrow: twoheadrightarrow,
    	Uacute: Uacute$1,
    	uacute: uacute$1,
    	uarr: uarr,
    	Uarr: Uarr,
    	uArr: uArr,
    	Uarrocir: Uarrocir,
    	Ubrcy: Ubrcy,
    	ubrcy: ubrcy,
    	Ubreve: Ubreve,
    	ubreve: ubreve,
    	Ucirc: Ucirc$1,
    	ucirc: ucirc$1,
    	Ucy: Ucy,
    	ucy: ucy,
    	udarr: udarr,
    	Udblac: Udblac,
    	udblac: udblac,
    	udhar: udhar,
    	ufisht: ufisht,
    	Ufr: Ufr,
    	ufr: ufr,
    	Ugrave: Ugrave$1,
    	ugrave: ugrave$1,
    	uHar: uHar,
    	uharl: uharl,
    	uharr: uharr,
    	uhblk: uhblk,
    	ulcorn: ulcorn,
    	ulcorner: ulcorner,
    	ulcrop: ulcrop,
    	ultri: ultri,
    	Umacr: Umacr,
    	umacr: umacr,
    	uml: uml$1,
    	UnderBar: UnderBar,
    	UnderBrace: UnderBrace,
    	UnderBracket: UnderBracket,
    	UnderParenthesis: UnderParenthesis,
    	Union: Union,
    	UnionPlus: UnionPlus,
    	Uogon: Uogon,
    	uogon: uogon,
    	Uopf: Uopf,
    	uopf: uopf,
    	UpArrowBar: UpArrowBar,
    	uparrow: uparrow,
    	UpArrow: UpArrow,
    	Uparrow: Uparrow,
    	UpArrowDownArrow: UpArrowDownArrow,
    	updownarrow: updownarrow,
    	UpDownArrow: UpDownArrow,
    	Updownarrow: Updownarrow,
    	UpEquilibrium: UpEquilibrium,
    	upharpoonleft: upharpoonleft,
    	upharpoonright: upharpoonright,
    	uplus: uplus,
    	UpperLeftArrow: UpperLeftArrow,
    	UpperRightArrow: UpperRightArrow,
    	upsi: upsi,
    	Upsi: Upsi,
    	upsih: upsih,
    	Upsilon: Upsilon,
    	upsilon: upsilon,
    	UpTeeArrow: UpTeeArrow,
    	UpTee: UpTee,
    	upuparrows: upuparrows,
    	urcorn: urcorn,
    	urcorner: urcorner,
    	urcrop: urcrop,
    	Uring: Uring,
    	uring: uring,
    	urtri: urtri,
    	Uscr: Uscr,
    	uscr: uscr,
    	utdot: utdot,
    	Utilde: Utilde,
    	utilde: utilde,
    	utri: utri,
    	utrif: utrif,
    	uuarr: uuarr,
    	Uuml: Uuml$1,
    	uuml: uuml$1,
    	uwangle: uwangle,
    	vangrt: vangrt,
    	varepsilon: varepsilon,
    	varkappa: varkappa,
    	varnothing: varnothing,
    	varphi: varphi,
    	varpi: varpi,
    	varpropto: varpropto,
    	varr: varr,
    	vArr: vArr,
    	varrho: varrho,
    	varsigma: varsigma,
    	varsubsetneq: varsubsetneq,
    	varsubsetneqq: varsubsetneqq,
    	varsupsetneq: varsupsetneq,
    	varsupsetneqq: varsupsetneqq,
    	vartheta: vartheta,
    	vartriangleleft: vartriangleleft,
    	vartriangleright: vartriangleright,
    	vBar: vBar,
    	Vbar: Vbar,
    	vBarv: vBarv,
    	Vcy: Vcy,
    	vcy: vcy,
    	vdash: vdash,
    	vDash: vDash,
    	Vdash: Vdash,
    	VDash: VDash,
    	Vdashl: Vdashl,
    	veebar: veebar,
    	vee: vee,
    	Vee: Vee,
    	veeeq: veeeq,
    	vellip: vellip,
    	verbar: verbar,
    	Verbar: Verbar,
    	vert: vert,
    	Vert: Vert,
    	VerticalBar: VerticalBar,
    	VerticalLine: VerticalLine,
    	VerticalSeparator: VerticalSeparator,
    	VerticalTilde: VerticalTilde,
    	VeryThinSpace: VeryThinSpace,
    	Vfr: Vfr,
    	vfr: vfr,
    	vltri: vltri,
    	vnsub: vnsub,
    	vnsup: vnsup,
    	Vopf: Vopf,
    	vopf: vopf,
    	vprop: vprop,
    	vrtri: vrtri,
    	Vscr: Vscr,
    	vscr: vscr,
    	vsubnE: vsubnE,
    	vsubne: vsubne,
    	vsupnE: vsupnE,
    	vsupne: vsupne,
    	Vvdash: Vvdash,
    	vzigzag: vzigzag,
    	Wcirc: Wcirc,
    	wcirc: wcirc,
    	wedbar: wedbar,
    	wedge: wedge,
    	Wedge: Wedge,
    	wedgeq: wedgeq,
    	weierp: weierp,
    	Wfr: Wfr,
    	wfr: wfr,
    	Wopf: Wopf,
    	wopf: wopf,
    	wp: wp,
    	wr: wr,
    	wreath: wreath,
    	Wscr: Wscr,
    	wscr: wscr,
    	xcap: xcap,
    	xcirc: xcirc,
    	xcup: xcup,
    	xdtri: xdtri,
    	Xfr: Xfr,
    	xfr: xfr,
    	xharr: xharr,
    	xhArr: xhArr,
    	Xi: Xi,
    	xi: xi,
    	xlarr: xlarr,
    	xlArr: xlArr,
    	xmap: xmap,
    	xnis: xnis,
    	xodot: xodot,
    	Xopf: Xopf,
    	xopf: xopf,
    	xoplus: xoplus,
    	xotime: xotime,
    	xrarr: xrarr,
    	xrArr: xrArr,
    	Xscr: Xscr,
    	xscr: xscr,
    	xsqcup: xsqcup,
    	xuplus: xuplus,
    	xutri: xutri,
    	xvee: xvee,
    	xwedge: xwedge,
    	Yacute: Yacute$1,
    	yacute: yacute$1,
    	YAcy: YAcy,
    	yacy: yacy,
    	Ycirc: Ycirc,
    	ycirc: ycirc,
    	Ycy: Ycy,
    	ycy: ycy,
    	yen: yen$1,
    	Yfr: Yfr,
    	yfr: yfr,
    	YIcy: YIcy,
    	yicy: yicy,
    	Yopf: Yopf,
    	yopf: yopf,
    	Yscr: Yscr,
    	yscr: yscr,
    	YUcy: YUcy,
    	yucy: yucy,
    	yuml: yuml$1,
    	Yuml: Yuml,
    	Zacute: Zacute,
    	zacute: zacute,
    	Zcaron: Zcaron,
    	zcaron: zcaron,
    	Zcy: Zcy,
    	zcy: zcy,
    	Zdot: Zdot,
    	zdot: zdot,
    	zeetrf: zeetrf,
    	ZeroWidthSpace: ZeroWidthSpace,
    	Zeta: Zeta,
    	zeta: zeta,
    	zfr: zfr,
    	Zfr: Zfr,
    	ZHcy: ZHcy,
    	zhcy: zhcy,
    	zigrarr: zigrarr,
    	zopf: zopf,
    	Zopf: Zopf,
    	Zscr: Zscr,
    	zscr: zscr,
    	zwj: zwj,
    	zwnj: zwnj
    };

    var Aacute = "Á";
    var aacute = "á";
    var Acirc = "Â";
    var acirc = "â";
    var acute = "´";
    var AElig = "Æ";
    var aelig = "æ";
    var Agrave = "À";
    var agrave = "à";
    var amp$1 = "&";
    var AMP = "&";
    var Aring = "Å";
    var aring = "å";
    var Atilde = "Ã";
    var atilde = "ã";
    var Auml = "Ä";
    var auml = "ä";
    var brvbar = "¦";
    var Ccedil = "Ç";
    var ccedil = "ç";
    var cedil = "¸";
    var cent = "¢";
    var copy = "©";
    var COPY = "©";
    var curren = "¤";
    var deg = "°";
    var divide = "÷";
    var Eacute = "É";
    var eacute = "é";
    var Ecirc = "Ê";
    var ecirc = "ê";
    var Egrave = "È";
    var egrave = "è";
    var ETH = "Ð";
    var eth = "ð";
    var Euml = "Ë";
    var euml = "ë";
    var frac12 = "½";
    var frac14 = "¼";
    var frac34 = "¾";
    var gt$2 = ">";
    var GT = ">";
    var Iacute = "Í";
    var iacute = "í";
    var Icirc = "Î";
    var icirc = "î";
    var iexcl = "¡";
    var Igrave = "Ì";
    var igrave = "ì";
    var iquest = "¿";
    var Iuml = "Ï";
    var iuml = "ï";
    var laquo = "«";
    var lt$1 = "<";
    var LT = "<";
    var macr = "¯";
    var micro = "µ";
    var middot = "·";
    var nbsp = " ";
    var not = "¬";
    var Ntilde = "Ñ";
    var ntilde = "ñ";
    var Oacute = "Ó";
    var oacute = "ó";
    var Ocirc = "Ô";
    var ocirc = "ô";
    var Ograve = "Ò";
    var ograve = "ò";
    var ordf = "ª";
    var ordm = "º";
    var Oslash = "Ø";
    var oslash = "ø";
    var Otilde = "Õ";
    var otilde = "õ";
    var Ouml = "Ö";
    var ouml = "ö";
    var para = "¶";
    var plusmn = "±";
    var pound = "£";
    var quot$1 = "\"";
    var QUOT = "\"";
    var raquo = "»";
    var reg = "®";
    var REG = "®";
    var sect = "§";
    var shy = "­";
    var sup1 = "¹";
    var sup2 = "²";
    var sup3 = "³";
    var szlig = "ß";
    var THORN = "Þ";
    var thorn = "þ";
    var times = "×";
    var Uacute = "Ú";
    var uacute = "ú";
    var Ucirc = "Û";
    var ucirc = "û";
    var Ugrave = "Ù";
    var ugrave = "ù";
    var uml = "¨";
    var Uuml = "Ü";
    var uuml = "ü";
    var Yacute = "Ý";
    var yacute = "ý";
    var yen = "¥";
    var yuml = "ÿ";
    var require$$1$2 = {
    	Aacute: Aacute,
    	aacute: aacute,
    	Acirc: Acirc,
    	acirc: acirc,
    	acute: acute,
    	AElig: AElig,
    	aelig: aelig,
    	Agrave: Agrave,
    	agrave: agrave,
    	amp: amp$1,
    	AMP: AMP,
    	Aring: Aring,
    	aring: aring,
    	Atilde: Atilde,
    	atilde: atilde,
    	Auml: Auml,
    	auml: auml,
    	brvbar: brvbar,
    	Ccedil: Ccedil,
    	ccedil: ccedil,
    	cedil: cedil,
    	cent: cent,
    	copy: copy,
    	COPY: COPY,
    	curren: curren,
    	deg: deg,
    	divide: divide,
    	Eacute: Eacute,
    	eacute: eacute,
    	Ecirc: Ecirc,
    	ecirc: ecirc,
    	Egrave: Egrave,
    	egrave: egrave,
    	ETH: ETH,
    	eth: eth,
    	Euml: Euml,
    	euml: euml,
    	frac12: frac12,
    	frac14: frac14,
    	frac34: frac34,
    	gt: gt$2,
    	GT: GT,
    	Iacute: Iacute,
    	iacute: iacute,
    	Icirc: Icirc,
    	icirc: icirc,
    	iexcl: iexcl,
    	Igrave: Igrave,
    	igrave: igrave,
    	iquest: iquest,
    	Iuml: Iuml,
    	iuml: iuml,
    	laquo: laquo,
    	lt: lt$1,
    	LT: LT,
    	macr: macr,
    	micro: micro,
    	middot: middot,
    	nbsp: nbsp,
    	not: not,
    	Ntilde: Ntilde,
    	ntilde: ntilde,
    	Oacute: Oacute,
    	oacute: oacute,
    	Ocirc: Ocirc,
    	ocirc: ocirc,
    	Ograve: Ograve,
    	ograve: ograve,
    	ordf: ordf,
    	ordm: ordm,
    	Oslash: Oslash,
    	oslash: oslash,
    	Otilde: Otilde,
    	otilde: otilde,
    	Ouml: Ouml,
    	ouml: ouml,
    	para: para,
    	plusmn: plusmn,
    	pound: pound,
    	quot: quot$1,
    	QUOT: QUOT,
    	raquo: raquo,
    	reg: reg,
    	REG: REG,
    	sect: sect,
    	shy: shy,
    	sup1: sup1,
    	sup2: sup2,
    	sup3: sup3,
    	szlig: szlig,
    	THORN: THORN,
    	thorn: thorn,
    	times: times,
    	Uacute: Uacute,
    	uacute: uacute,
    	Ucirc: Ucirc,
    	ucirc: ucirc,
    	Ugrave: Ugrave,
    	ugrave: ugrave,
    	uml: uml,
    	Uuml: Uuml,
    	uuml: uuml,
    	Yacute: Yacute,
    	yacute: yacute,
    	yen: yen,
    	yuml: yuml
    };

    var amp = "&";
    var apos = "'";
    var gt$1 = ">";
    var lt = "<";
    var quot = "\"";
    var require$$0$2 = {
    	amp: amp,
    	apos: apos,
    	gt: gt$1,
    	lt: lt,
    	quot: quot
    };

    var require$$3$1 = decode_codepoint;

    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    var decode_codepoint_1 = __importDefault(require$$3$1);
    var entities_json_1 = __importDefault(require$$1$3);
    var legacy_json_1 = __importDefault(require$$1$2);
    var xml_json_1 = __importDefault(require$$0$2);
    function whitespace(c) {
        return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
    }
    function isASCIIAlpha(c) {
        return (c >= "a" && c <= "z") || (c >= "A" && c <= "Z");
    }
    function ifElseState(upper, SUCCESS, FAILURE) {
        var lower = upper.toLowerCase();
        if (upper === lower) {
            return function (t, c) {
                if (c === lower) {
                    t._state = SUCCESS;
                }
                else {
                    t._state = FAILURE;
                    t._index--;
                }
            };
        }
        return function (t, c) {
            if (c === lower || c === upper) {
                t._state = SUCCESS;
            }
            else {
                t._state = FAILURE;
                t._index--;
            }
        };
    }
    function consumeSpecialNameChar(upper, NEXT_STATE) {
        var lower = upper.toLowerCase();
        return function (t, c) {
            if (c === lower || c === upper) {
                t._state = NEXT_STATE;
            }
            else {
                t._state = 3 /* InTagName */;
                t._index--; // Consume the token again
            }
        };
    }
    var stateBeforeCdata1 = ifElseState("C", 24 /* BeforeCdata2 */, 16 /* InDeclaration */);
    var stateBeforeCdata2 = ifElseState("D", 25 /* BeforeCdata3 */, 16 /* InDeclaration */);
    var stateBeforeCdata3 = ifElseState("A", 26 /* BeforeCdata4 */, 16 /* InDeclaration */);
    var stateBeforeCdata4 = ifElseState("T", 27 /* BeforeCdata5 */, 16 /* InDeclaration */);
    var stateBeforeCdata5 = ifElseState("A", 28 /* BeforeCdata6 */, 16 /* InDeclaration */);
    var stateBeforeScript1 = consumeSpecialNameChar("R", 35 /* BeforeScript2 */);
    var stateBeforeScript2 = consumeSpecialNameChar("I", 36 /* BeforeScript3 */);
    var stateBeforeScript3 = consumeSpecialNameChar("P", 37 /* BeforeScript4 */);
    var stateBeforeScript4 = consumeSpecialNameChar("T", 38 /* BeforeScript5 */);
    var stateAfterScript1 = ifElseState("R", 40 /* AfterScript2 */, 1 /* Text */);
    var stateAfterScript2 = ifElseState("I", 41 /* AfterScript3 */, 1 /* Text */);
    var stateAfterScript3 = ifElseState("P", 42 /* AfterScript4 */, 1 /* Text */);
    var stateAfterScript4 = ifElseState("T", 43 /* AfterScript5 */, 1 /* Text */);
    var stateBeforeStyle1 = consumeSpecialNameChar("Y", 45 /* BeforeStyle2 */);
    var stateBeforeStyle2 = consumeSpecialNameChar("L", 46 /* BeforeStyle3 */);
    var stateBeforeStyle3 = consumeSpecialNameChar("E", 47 /* BeforeStyle4 */);
    var stateAfterStyle1 = ifElseState("Y", 49 /* AfterStyle2 */, 1 /* Text */);
    var stateAfterStyle2 = ifElseState("L", 50 /* AfterStyle3 */, 1 /* Text */);
    var stateAfterStyle3 = ifElseState("E", 51 /* AfterStyle4 */, 1 /* Text */);
    var stateBeforeSpecialT = consumeSpecialNameChar("I", 54 /* BeforeTitle1 */);
    var stateBeforeTitle1 = consumeSpecialNameChar("T", 55 /* BeforeTitle2 */);
    var stateBeforeTitle2 = consumeSpecialNameChar("L", 56 /* BeforeTitle3 */);
    var stateBeforeTitle3 = consumeSpecialNameChar("E", 57 /* BeforeTitle4 */);
    var stateAfterSpecialTEnd = ifElseState("I", 58 /* AfterTitle1 */, 1 /* Text */);
    var stateAfterTitle1 = ifElseState("T", 59 /* AfterTitle2 */, 1 /* Text */);
    var stateAfterTitle2 = ifElseState("L", 60 /* AfterTitle3 */, 1 /* Text */);
    var stateAfterTitle3 = ifElseState("E", 61 /* AfterTitle4 */, 1 /* Text */);
    var stateBeforeEntity = ifElseState("#", 63 /* BeforeNumericEntity */, 64 /* InNamedEntity */);
    var stateBeforeNumericEntity = ifElseState("X", 66 /* InHexEntity */, 65 /* InNumericEntity */);
    var Tokenizer = /** @class */ (function () {
        function Tokenizer(options, cbs) {
            var _a;
            /** The current state the tokenizer is in. */
            this._state = 1 /* Text */;
            /** The read buffer. */
            this.buffer = "";
            /** The beginning of the section that is currently being read. */
            this.sectionStart = 0;
            /** The index within the buffer that we are currently looking at. */
            this._index = 0;
            /**
             * Data that has already been processed will be removed from the buffer occasionally.
             * `_bufferOffset` keeps track of how many characters have been removed, to make sure position information is accurate.
             */
            this.bufferOffset = 0;
            /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
            this.baseState = 1 /* Text */;
            /** For special parsing behavior inside of script and style tags. */
            this.special = 1 /* None */;
            /** Indicates whether the tokenizer has been paused. */
            this.running = true;
            /** Indicates whether the tokenizer has finished running / `.end` has been called. */
            this.ended = false;
            this.cbs = cbs;
            this.xmlMode = !!(options === null || options === void 0 ? void 0 : options.xmlMode);
            this.decodeEntities = (_a = options === null || options === void 0 ? void 0 : options.decodeEntities) !== null && _a !== void 0 ? _a : true;
        }
        Tokenizer.prototype.reset = function () {
            this._state = 1 /* Text */;
            this.buffer = "";
            this.sectionStart = 0;
            this._index = 0;
            this.bufferOffset = 0;
            this.baseState = 1 /* Text */;
            this.special = 1 /* None */;
            this.running = true;
            this.ended = false;
        };
        Tokenizer.prototype.write = function (chunk) {
            if (this.ended)
                this.cbs.onerror(Error(".write() after done!"));
            this.buffer += chunk;
            this.parse();
        };
        Tokenizer.prototype.end = function (chunk) {
            if (this.ended)
                this.cbs.onerror(Error(".end() after done!"));
            if (chunk)
                this.write(chunk);
            this.ended = true;
            if (this.running)
                this.finish();
        };
        Tokenizer.prototype.pause = function () {
            this.running = false;
        };
        Tokenizer.prototype.resume = function () {
            this.running = true;
            if (this._index < this.buffer.length) {
                this.parse();
            }
            if (this.ended) {
                this.finish();
            }
        };
        /**
         * The current index within all of the written data.
         */
        Tokenizer.prototype.getAbsoluteIndex = function () {
            return this.bufferOffset + this._index;
        };
        Tokenizer.prototype.stateText = function (c) {
            if (c === "<") {
                if (this._index > this.sectionStart) {
                    this.cbs.ontext(this.getSection());
                }
                this._state = 2 /* BeforeTagName */;
                this.sectionStart = this._index;
            }
            else if (this.decodeEntities &&
                c === "&" &&
                (this.special === 1 /* None */ || this.special === 4 /* Title */)) {
                if (this._index > this.sectionStart) {
                    this.cbs.ontext(this.getSection());
                }
                this.baseState = 1 /* Text */;
                this._state = 62 /* BeforeEntity */;
                this.sectionStart = this._index;
            }
        };
        /**
         * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
         *
         * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
         * We allow anything that wouldn't end the tag.
         */
        Tokenizer.prototype.isTagStartChar = function (c) {
            return (isASCIIAlpha(c) ||
                (this.xmlMode && !whitespace(c) && c !== "/" && c !== ">"));
        };
        Tokenizer.prototype.stateBeforeTagName = function (c) {
            if (c === "/") {
                this._state = 5 /* BeforeClosingTagName */;
            }
            else if (c === "<") {
                this.cbs.ontext(this.getSection());
                this.sectionStart = this._index;
            }
            else if (c === ">" ||
                this.special !== 1 /* None */ ||
                whitespace(c)) {
                this._state = 1 /* Text */;
            }
            else if (c === "!") {
                this._state = 15 /* BeforeDeclaration */;
                this.sectionStart = this._index + 1;
            }
            else if (c === "?") {
                this._state = 17 /* InProcessingInstruction */;
                this.sectionStart = this._index + 1;
            }
            else if (!this.isTagStartChar(c)) {
                this._state = 1 /* Text */;
            }
            else {
                this._state =
                    !this.xmlMode && (c === "s" || c === "S")
                        ? 32 /* BeforeSpecialS */
                        : !this.xmlMode && (c === "t" || c === "T")
                            ? 52 /* BeforeSpecialT */
                            : 3 /* InTagName */;
                this.sectionStart = this._index;
            }
        };
        Tokenizer.prototype.stateInTagName = function (c) {
            if (c === "/" || c === ">" || whitespace(c)) {
                this.emitToken("onopentagname");
                this._state = 8 /* BeforeAttributeName */;
                this._index--;
            }
        };
        Tokenizer.prototype.stateBeforeClosingTagName = function (c) {
            if (whitespace(c)) ;
            else if (c === ">") {
                this._state = 1 /* Text */;
            }
            else if (this.special !== 1 /* None */) {
                if (this.special !== 4 /* Title */ && (c === "s" || c === "S")) {
                    this._state = 33 /* BeforeSpecialSEnd */;
                }
                else if (this.special === 4 /* Title */ &&
                    (c === "t" || c === "T")) {
                    this._state = 53 /* BeforeSpecialTEnd */;
                }
                else {
                    this._state = 1 /* Text */;
                    this._index--;
                }
            }
            else if (!this.isTagStartChar(c)) {
                this._state = 20 /* InSpecialComment */;
                this.sectionStart = this._index;
            }
            else {
                this._state = 6 /* InClosingTagName */;
                this.sectionStart = this._index;
            }
        };
        Tokenizer.prototype.stateInClosingTagName = function (c) {
            if (c === ">" || whitespace(c)) {
                this.emitToken("onclosetag");
                this._state = 7 /* AfterClosingTagName */;
                this._index--;
            }
        };
        Tokenizer.prototype.stateAfterClosingTagName = function (c) {
            // Skip everything until ">"
            if (c === ">") {
                this._state = 1 /* Text */;
                this.sectionStart = this._index + 1;
            }
        };
        Tokenizer.prototype.stateBeforeAttributeName = function (c) {
            if (c === ">") {
                this.cbs.onopentagend();
                this._state = 1 /* Text */;
                this.sectionStart = this._index + 1;
            }
            else if (c === "/") {
                this._state = 4 /* InSelfClosingTag */;
            }
            else if (!whitespace(c)) {
                this._state = 9 /* InAttributeName */;
                this.sectionStart = this._index;
            }
        };
        Tokenizer.prototype.stateInSelfClosingTag = function (c) {
            if (c === ">") {
                this.cbs.onselfclosingtag();
                this._state = 1 /* Text */;
                this.sectionStart = this._index + 1;
                this.special = 1 /* None */; // Reset special state, in case of self-closing special tags
            }
            else if (!whitespace(c)) {
                this._state = 8 /* BeforeAttributeName */;
                this._index--;
            }
        };
        Tokenizer.prototype.stateInAttributeName = function (c) {
            if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
                this.cbs.onattribname(this.getSection());
                this.sectionStart = -1;
                this._state = 10 /* AfterAttributeName */;
                this._index--;
            }
        };
        Tokenizer.prototype.stateAfterAttributeName = function (c) {
            if (c === "=") {
                this._state = 11 /* BeforeAttributeValue */;
            }
            else if (c === "/" || c === ">") {
                this.cbs.onattribend(undefined);
                this._state = 8 /* BeforeAttributeName */;
                this._index--;
            }
            else if (!whitespace(c)) {
                this.cbs.onattribend(undefined);
                this._state = 9 /* InAttributeName */;
                this.sectionStart = this._index;
            }
        };
        Tokenizer.prototype.stateBeforeAttributeValue = function (c) {
            if (c === '"') {
                this._state = 12 /* InAttributeValueDq */;
                this.sectionStart = this._index + 1;
            }
            else if (c === "'") {
                this._state = 13 /* InAttributeValueSq */;
                this.sectionStart = this._index + 1;
            }
            else if (!whitespace(c)) {
                this._state = 14 /* InAttributeValueNq */;
                this.sectionStart = this._index;
                this._index--; // Reconsume token
            }
        };
        Tokenizer.prototype.handleInAttributeValue = function (c, quote) {
            if (c === quote) {
                this.emitToken("onattribdata");
                this.cbs.onattribend(quote);
                this._state = 8 /* BeforeAttributeName */;
            }
            else if (this.decodeEntities && c === "&") {
                this.emitToken("onattribdata");
                this.baseState = this._state;
                this._state = 62 /* BeforeEntity */;
                this.sectionStart = this._index;
            }
        };
        Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {
            this.handleInAttributeValue(c, '"');
        };
        Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {
            this.handleInAttributeValue(c, "'");
        };
        Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {
            if (whitespace(c) || c === ">") {
                this.emitToken("onattribdata");
                this.cbs.onattribend(null);
                this._state = 8 /* BeforeAttributeName */;
                this._index--;
            }
            else if (this.decodeEntities && c === "&") {
                this.emitToken("onattribdata");
                this.baseState = this._state;
                this._state = 62 /* BeforeEntity */;
                this.sectionStart = this._index;
            }
        };
        Tokenizer.prototype.stateBeforeDeclaration = function (c) {
            this._state =
                c === "["
                    ? 23 /* BeforeCdata1 */
                    : c === "-"
                        ? 18 /* BeforeComment */
                        : 16 /* InDeclaration */;
        };
        Tokenizer.prototype.stateInDeclaration = function (c) {
            if (c === ">") {
                this.cbs.ondeclaration(this.getSection());
                this._state = 1 /* Text */;
                this.sectionStart = this._index + 1;
            }
        };
        Tokenizer.prototype.stateInProcessingInstruction = function (c) {
            if (c === ">") {
                this.cbs.onprocessinginstruction(this.getSection());
                this._state = 1 /* Text */;
                this.sectionStart = this._index + 1;
            }
        };
        Tokenizer.prototype.stateBeforeComment = function (c) {
            if (c === "-") {
                this._state = 19 /* InComment */;
                this.sectionStart = this._index + 1;
            }
            else {
                this._state = 16 /* InDeclaration */;
            }
        };
        Tokenizer.prototype.stateInComment = function (c) {
            if (c === "-")
                this._state = 21 /* AfterComment1 */;
        };
        Tokenizer.prototype.stateInSpecialComment = function (c) {
            if (c === ">") {
                this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index));
                this._state = 1 /* Text */;
                this.sectionStart = this._index + 1;
            }
        };
        Tokenizer.prototype.stateAfterComment1 = function (c) {
            if (c === "-") {
                this._state = 22 /* AfterComment2 */;
            }
            else {
                this._state = 19 /* InComment */;
            }
        };
        Tokenizer.prototype.stateAfterComment2 = function (c) {
            if (c === ">") {
                // Remove 2 trailing chars
                this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2));
                this._state = 1 /* Text */;
                this.sectionStart = this._index + 1;
            }
            else if (c !== "-") {
                this._state = 19 /* InComment */;
            }
            // Else: stay in AFTER_COMMENT_2 (`--->`)
        };
        Tokenizer.prototype.stateBeforeCdata6 = function (c) {
            if (c === "[") {
                this._state = 29 /* InCdata */;
                this.sectionStart = this._index + 1;
            }
            else {
                this._state = 16 /* InDeclaration */;
                this._index--;
            }
        };
        Tokenizer.prototype.stateInCdata = function (c) {
            if (c === "]")
                this._state = 30 /* AfterCdata1 */;
        };
        Tokenizer.prototype.stateAfterCdata1 = function (c) {
            if (c === "]")
                this._state = 31 /* AfterCdata2 */;
            else
                this._state = 29 /* InCdata */;
        };
        Tokenizer.prototype.stateAfterCdata2 = function (c) {
            if (c === ">") {
                // Remove 2 trailing chars
                this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2));
                this._state = 1 /* Text */;
                this.sectionStart = this._index + 1;
            }
            else if (c !== "]") {
                this._state = 29 /* InCdata */;
            }
            // Else: stay in AFTER_CDATA_2 (`]]]>`)
        };
        Tokenizer.prototype.stateBeforeSpecialS = function (c) {
            if (c === "c" || c === "C") {
                this._state = 34 /* BeforeScript1 */;
            }
            else if (c === "t" || c === "T") {
                this._state = 44 /* BeforeStyle1 */;
            }
            else {
                this._state = 3 /* InTagName */;
                this._index--; // Consume the token again
            }
        };
        Tokenizer.prototype.stateBeforeSpecialSEnd = function (c) {
            if (this.special === 2 /* Script */ && (c === "c" || c === "C")) {
                this._state = 39 /* AfterScript1 */;
            }
            else if (this.special === 3 /* Style */ && (c === "t" || c === "T")) {
                this._state = 48 /* AfterStyle1 */;
            }
            else
                this._state = 1 /* Text */;
        };
        Tokenizer.prototype.stateBeforeSpecialLast = function (c, special) {
            if (c === "/" || c === ">" || whitespace(c)) {
                this.special = special;
            }
            this._state = 3 /* InTagName */;
            this._index--; // Consume the token again
        };
        Tokenizer.prototype.stateAfterSpecialLast = function (c, sectionStartOffset) {
            if (c === ">" || whitespace(c)) {
                this.special = 1 /* None */;
                this._state = 6 /* InClosingTagName */;
                this.sectionStart = this._index - sectionStartOffset;
                this._index--; // Reconsume the token
            }
            else
                this._state = 1 /* Text */;
        };
        // For entities terminated with a semicolon
        Tokenizer.prototype.parseFixedEntity = function (map) {
            if (map === void 0) { map = this.xmlMode ? xml_json_1.default : entities_json_1.default; }
            // Offset = 1
            if (this.sectionStart + 1 < this._index) {
                var entity = this.buffer.substring(this.sectionStart + 1, this._index);
                if (Object.prototype.hasOwnProperty.call(map, entity)) {
                    this.emitPartial(map[entity]);
                    this.sectionStart = this._index + 1;
                }
            }
        };
        // Parses legacy entities (without trailing semicolon)
        Tokenizer.prototype.parseLegacyEntity = function () {
            var start = this.sectionStart + 1;
            // The max length of legacy entities is 6
            var limit = Math.min(this._index - start, 6);
            while (limit >= 2) {
                // The min length of legacy entities is 2
                var entity = this.buffer.substr(start, limit);
                if (Object.prototype.hasOwnProperty.call(legacy_json_1.default, entity)) {
                    this.emitPartial(legacy_json_1.default[entity]);
                    this.sectionStart += limit + 1;
                    return;
                }
                limit--;
            }
        };
        Tokenizer.prototype.stateInNamedEntity = function (c) {
            if (c === ";") {
                this.parseFixedEntity();
                // Retry as legacy entity if entity wasn't parsed
                if (this.baseState === 1 /* Text */ &&
                    this.sectionStart + 1 < this._index &&
                    !this.xmlMode) {
                    this.parseLegacyEntity();
                }
                this._state = this.baseState;
            }
            else if ((c < "0" || c > "9") && !isASCIIAlpha(c)) {
                if (this.xmlMode || this.sectionStart + 1 === this._index) ;
                else if (this.baseState !== 1 /* Text */) {
                    if (c !== "=") {
                        // Parse as legacy entity, without allowing additional characters.
                        this.parseFixedEntity(legacy_json_1.default);
                    }
                }
                else {
                    this.parseLegacyEntity();
                }
                this._state = this.baseState;
                this._index--;
            }
        };
        Tokenizer.prototype.decodeNumericEntity = function (offset, base, strict) {
            var sectionStart = this.sectionStart + offset;
            if (sectionStart !== this._index) {
                // Parse entity
                var entity = this.buffer.substring(sectionStart, this._index);
                var parsed = parseInt(entity, base);
                this.emitPartial(decode_codepoint_1.default(parsed));
                this.sectionStart = strict ? this._index + 1 : this._index;
            }
            this._state = this.baseState;
        };
        Tokenizer.prototype.stateInNumericEntity = function (c) {
            if (c === ";") {
                this.decodeNumericEntity(2, 10, true);
            }
            else if (c < "0" || c > "9") {
                if (!this.xmlMode) {
                    this.decodeNumericEntity(2, 10, false);
                }
                else {
                    this._state = this.baseState;
                }
                this._index--;
            }
        };
        Tokenizer.prototype.stateInHexEntity = function (c) {
            if (c === ";") {
                this.decodeNumericEntity(3, 16, true);
            }
            else if ((c < "a" || c > "f") &&
                (c < "A" || c > "F") &&
                (c < "0" || c > "9")) {
                if (!this.xmlMode) {
                    this.decodeNumericEntity(3, 16, false);
                }
                else {
                    this._state = this.baseState;
                }
                this._index--;
            }
        };
        Tokenizer.prototype.cleanup = function () {
            if (this.sectionStart < 0) {
                this.buffer = "";
                this.bufferOffset += this._index;
                this._index = 0;
            }
            else if (this.running) {
                if (this._state === 1 /* Text */) {
                    if (this.sectionStart !== this._index) {
                        this.cbs.ontext(this.buffer.substr(this.sectionStart));
                    }
                    this.buffer = "";
                    this.bufferOffset += this._index;
                    this._index = 0;
                }
                else if (this.sectionStart === this._index) {
                    // The section just started
                    this.buffer = "";
                    this.bufferOffset += this._index;
                    this._index = 0;
                }
                else {
                    // Remove everything unnecessary
                    this.buffer = this.buffer.substr(this.sectionStart);
                    this._index -= this.sectionStart;
                    this.bufferOffset += this.sectionStart;
                }
                this.sectionStart = 0;
            }
        };
        /**
         * Iterates through the buffer, calling the function corresponding to the current state.
         *
         * States that are more likely to be hit are higher up, as a performance improvement.
         */
        Tokenizer.prototype.parse = function () {
            while (this._index < this.buffer.length && this.running) {
                var c = this.buffer.charAt(this._index);
                if (this._state === 1 /* Text */) {
                    this.stateText(c);
                }
                else if (this._state === 12 /* InAttributeValueDq */) {
                    this.stateInAttributeValueDoubleQuotes(c);
                }
                else if (this._state === 9 /* InAttributeName */) {
                    this.stateInAttributeName(c);
                }
                else if (this._state === 19 /* InComment */) {
                    this.stateInComment(c);
                }
                else if (this._state === 20 /* InSpecialComment */) {
                    this.stateInSpecialComment(c);
                }
                else if (this._state === 8 /* BeforeAttributeName */) {
                    this.stateBeforeAttributeName(c);
                }
                else if (this._state === 3 /* InTagName */) {
                    this.stateInTagName(c);
                }
                else if (this._state === 6 /* InClosingTagName */) {
                    this.stateInClosingTagName(c);
                }
                else if (this._state === 2 /* BeforeTagName */) {
                    this.stateBeforeTagName(c);
                }
                else if (this._state === 10 /* AfterAttributeName */) {
                    this.stateAfterAttributeName(c);
                }
                else if (this._state === 13 /* InAttributeValueSq */) {
                    this.stateInAttributeValueSingleQuotes(c);
                }
                else if (this._state === 11 /* BeforeAttributeValue */) {
                    this.stateBeforeAttributeValue(c);
                }
                else if (this._state === 5 /* BeforeClosingTagName */) {
                    this.stateBeforeClosingTagName(c);
                }
                else if (this._state === 7 /* AfterClosingTagName */) {
                    this.stateAfterClosingTagName(c);
                }
                else if (this._state === 32 /* BeforeSpecialS */) {
                    this.stateBeforeSpecialS(c);
                }
                else if (this._state === 21 /* AfterComment1 */) {
                    this.stateAfterComment1(c);
                }
                else if (this._state === 14 /* InAttributeValueNq */) {
                    this.stateInAttributeValueNoQuotes(c);
                }
                else if (this._state === 4 /* InSelfClosingTag */) {
                    this.stateInSelfClosingTag(c);
                }
                else if (this._state === 16 /* InDeclaration */) {
                    this.stateInDeclaration(c);
                }
                else if (this._state === 15 /* BeforeDeclaration */) {
                    this.stateBeforeDeclaration(c);
                }
                else if (this._state === 22 /* AfterComment2 */) {
                    this.stateAfterComment2(c);
                }
                else if (this._state === 18 /* BeforeComment */) {
                    this.stateBeforeComment(c);
                }
                else if (this._state === 33 /* BeforeSpecialSEnd */) {
                    this.stateBeforeSpecialSEnd(c);
                }
                else if (this._state === 53 /* BeforeSpecialTEnd */) {
                    stateAfterSpecialTEnd(this, c);
                }
                else if (this._state === 39 /* AfterScript1 */) {
                    stateAfterScript1(this, c);
                }
                else if (this._state === 40 /* AfterScript2 */) {
                    stateAfterScript2(this, c);
                }
                else if (this._state === 41 /* AfterScript3 */) {
                    stateAfterScript3(this, c);
                }
                else if (this._state === 34 /* BeforeScript1 */) {
                    stateBeforeScript1(this, c);
                }
                else if (this._state === 35 /* BeforeScript2 */) {
                    stateBeforeScript2(this, c);
                }
                else if (this._state === 36 /* BeforeScript3 */) {
                    stateBeforeScript3(this, c);
                }
                else if (this._state === 37 /* BeforeScript4 */) {
                    stateBeforeScript4(this, c);
                }
                else if (this._state === 38 /* BeforeScript5 */) {
                    this.stateBeforeSpecialLast(c, 2 /* Script */);
                }
                else if (this._state === 42 /* AfterScript4 */) {
                    stateAfterScript4(this, c);
                }
                else if (this._state === 43 /* AfterScript5 */) {
                    this.stateAfterSpecialLast(c, 6);
                }
                else if (this._state === 44 /* BeforeStyle1 */) {
                    stateBeforeStyle1(this, c);
                }
                else if (this._state === 29 /* InCdata */) {
                    this.stateInCdata(c);
                }
                else if (this._state === 45 /* BeforeStyle2 */) {
                    stateBeforeStyle2(this, c);
                }
                else if (this._state === 46 /* BeforeStyle3 */) {
                    stateBeforeStyle3(this, c);
                }
                else if (this._state === 47 /* BeforeStyle4 */) {
                    this.stateBeforeSpecialLast(c, 3 /* Style */);
                }
                else if (this._state === 48 /* AfterStyle1 */) {
                    stateAfterStyle1(this, c);
                }
                else if (this._state === 49 /* AfterStyle2 */) {
                    stateAfterStyle2(this, c);
                }
                else if (this._state === 50 /* AfterStyle3 */) {
                    stateAfterStyle3(this, c);
                }
                else if (this._state === 51 /* AfterStyle4 */) {
                    this.stateAfterSpecialLast(c, 5);
                }
                else if (this._state === 52 /* BeforeSpecialT */) {
                    stateBeforeSpecialT(this, c);
                }
                else if (this._state === 54 /* BeforeTitle1 */) {
                    stateBeforeTitle1(this, c);
                }
                else if (this._state === 55 /* BeforeTitle2 */) {
                    stateBeforeTitle2(this, c);
                }
                else if (this._state === 56 /* BeforeTitle3 */) {
                    stateBeforeTitle3(this, c);
                }
                else if (this._state === 57 /* BeforeTitle4 */) {
                    this.stateBeforeSpecialLast(c, 4 /* Title */);
                }
                else if (this._state === 58 /* AfterTitle1 */) {
                    stateAfterTitle1(this, c);
                }
                else if (this._state === 59 /* AfterTitle2 */) {
                    stateAfterTitle2(this, c);
                }
                else if (this._state === 60 /* AfterTitle3 */) {
                    stateAfterTitle3(this, c);
                }
                else if (this._state === 61 /* AfterTitle4 */) {
                    this.stateAfterSpecialLast(c, 5);
                }
                else if (this._state === 17 /* InProcessingInstruction */) {
                    this.stateInProcessingInstruction(c);
                }
                else if (this._state === 64 /* InNamedEntity */) {
                    this.stateInNamedEntity(c);
                }
                else if (this._state === 23 /* BeforeCdata1 */) {
                    stateBeforeCdata1(this, c);
                }
                else if (this._state === 62 /* BeforeEntity */) {
                    stateBeforeEntity(this, c);
                }
                else if (this._state === 24 /* BeforeCdata2 */) {
                    stateBeforeCdata2(this, c);
                }
                else if (this._state === 25 /* BeforeCdata3 */) {
                    stateBeforeCdata3(this, c);
                }
                else if (this._state === 30 /* AfterCdata1 */) {
                    this.stateAfterCdata1(c);
                }
                else if (this._state === 31 /* AfterCdata2 */) {
                    this.stateAfterCdata2(c);
                }
                else if (this._state === 26 /* BeforeCdata4 */) {
                    stateBeforeCdata4(this, c);
                }
                else if (this._state === 27 /* BeforeCdata5 */) {
                    stateBeforeCdata5(this, c);
                }
                else if (this._state === 28 /* BeforeCdata6 */) {
                    this.stateBeforeCdata6(c);
                }
                else if (this._state === 66 /* InHexEntity */) {
                    this.stateInHexEntity(c);
                }
                else if (this._state === 65 /* InNumericEntity */) {
                    this.stateInNumericEntity(c);
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                }
                else if (this._state === 63 /* BeforeNumericEntity */) {
                    stateBeforeNumericEntity(this, c);
                }
                else {
                    this.cbs.onerror(Error("unknown _state"), this._state);
                }
                this._index++;
            }
            this.cleanup();
        };
        Tokenizer.prototype.finish = function () {
            // If there is remaining data, emit it in a reasonable way
            if (this.sectionStart < this._index) {
                this.handleTrailingData();
            }
            this.cbs.onend();
        };
        Tokenizer.prototype.handleTrailingData = function () {
            var data = this.buffer.substr(this.sectionStart);
            if (this._state === 29 /* InCdata */ ||
                this._state === 30 /* AfterCdata1 */ ||
                this._state === 31 /* AfterCdata2 */) {
                this.cbs.oncdata(data);
            }
            else if (this._state === 19 /* InComment */ ||
                this._state === 21 /* AfterComment1 */ ||
                this._state === 22 /* AfterComment2 */) {
                this.cbs.oncomment(data);
            }
            else if (this._state === 64 /* InNamedEntity */ && !this.xmlMode) {
                this.parseLegacyEntity();
                if (this.sectionStart < this._index) {
                    this._state = this.baseState;
                    this.handleTrailingData();
                }
            }
            else if (this._state === 65 /* InNumericEntity */ && !this.xmlMode) {
                this.decodeNumericEntity(2, 10, false);
                if (this.sectionStart < this._index) {
                    this._state = this.baseState;
                    this.handleTrailingData();
                }
            }
            else if (this._state === 66 /* InHexEntity */ && !this.xmlMode) {
                this.decodeNumericEntity(3, 16, false);
                if (this.sectionStart < this._index) {
                    this._state = this.baseState;
                    this.handleTrailingData();
                }
            }
            else if (this._state !== 3 /* InTagName */ &&
                this._state !== 8 /* BeforeAttributeName */ &&
                this._state !== 11 /* BeforeAttributeValue */ &&
                this._state !== 10 /* AfterAttributeName */ &&
                this._state !== 9 /* InAttributeName */ &&
                this._state !== 13 /* InAttributeValueSq */ &&
                this._state !== 12 /* InAttributeValueDq */ &&
                this._state !== 14 /* InAttributeValueNq */ &&
                this._state !== 6 /* InClosingTagName */) {
                this.cbs.ontext(data);
            }
            /*
             * Else, ignore remaining data
             * TODO add a way to remove current tag
             */
        };
        Tokenizer.prototype.getSection = function () {
            return this.buffer.substring(this.sectionStart, this._index);
        };
        Tokenizer.prototype.emitToken = function (name) {
            this.cbs[name](this.getSection());
            this.sectionStart = -1;
        };
        Tokenizer.prototype.emitPartial = function (value) {
            if (this.baseState !== 1 /* Text */) {
                this.cbs.onattribdata(value); // TODO implement the new event
            }
            else {
                this.cbs.ontext(value);
            }
        };
        return Tokenizer;
    }());
    var _default$1 = Tokenizer;

    var Tokenizer_1$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$1
    }, '__esModule', {value: true});

    var Tokenizer_1 = Tokenizer_1$1;

    var Parser_1$1 = createCommonjsModule(function (module, exports) {
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    var Tokenizer_1$1 = __importDefault(Tokenizer_1);
    var formTags = new Set([
        "input",
        "option",
        "optgroup",
        "select",
        "button",
        "datalist",
        "textarea",
    ]);
    var pTag = new Set(["p"]);
    var openImpliesClose = {
        tr: new Set(["tr", "th", "td"]),
        th: new Set(["th"]),
        td: new Set(["thead", "th", "td"]),
        body: new Set(["head", "link", "script"]),
        li: new Set(["li"]),
        p: pTag,
        h1: pTag,
        h2: pTag,
        h3: pTag,
        h4: pTag,
        h5: pTag,
        h6: pTag,
        select: formTags,
        input: formTags,
        output: formTags,
        button: formTags,
        datalist: formTags,
        textarea: formTags,
        option: new Set(["option"]),
        optgroup: new Set(["optgroup", "option"]),
        dd: new Set(["dt", "dd"]),
        dt: new Set(["dt", "dd"]),
        address: pTag,
        article: pTag,
        aside: pTag,
        blockquote: pTag,
        details: pTag,
        div: pTag,
        dl: pTag,
        fieldset: pTag,
        figcaption: pTag,
        figure: pTag,
        footer: pTag,
        form: pTag,
        header: pTag,
        hr: pTag,
        main: pTag,
        nav: pTag,
        ol: pTag,
        pre: pTag,
        section: pTag,
        table: pTag,
        ul: pTag,
        rt: new Set(["rt", "rp"]),
        rp: new Set(["rt", "rp"]),
        tbody: new Set(["thead", "tbody"]),
        tfoot: new Set(["thead", "tbody"]),
    };
    var voidElements = new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr",
    ]);
    var foreignContextElements = new Set(["math", "svg"]);
    var htmlIntegrationElements = new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title",
    ]);
    var reNameEnd = /\s|\//;
    var Parser = /** @class */ (function () {
        function Parser(cbs, options) {
            if (options === void 0) { options = {}; }
            var _a, _b, _c, _d, _e;
            /** The start index of the last event. */
            this.startIndex = 0;
            /** The end index of the last event. */
            this.endIndex = null;
            this.tagname = "";
            this.attribname = "";
            this.attribvalue = "";
            this.attribs = null;
            this.stack = [];
            this.foreignContext = [];
            this.options = options;
            this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
            this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
            this.lowerCaseAttributeNames =
                (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
            this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1$1.default)(this.options, this);
            (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
        }
        Parser.prototype.updatePosition = function (initialOffset) {
            if (this.endIndex === null) {
                if (this.tokenizer.sectionStart <= initialOffset) {
                    this.startIndex = 0;
                }
                else {
                    this.startIndex = this.tokenizer.sectionStart - initialOffset;
                }
            }
            else {
                this.startIndex = this.endIndex + 1;
            }
            this.endIndex = this.tokenizer.getAbsoluteIndex();
        };
        // Tokenizer event handlers
        Parser.prototype.ontext = function (data) {
            var _a, _b;
            this.updatePosition(1);
            this.endIndex--;
            (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
        };
        Parser.prototype.onopentagname = function (name) {
            var _a, _b;
            if (this.lowerCaseTagNames) {
                name = name.toLowerCase();
            }
            this.tagname = name;
            if (!this.options.xmlMode &&
                Object.prototype.hasOwnProperty.call(openImpliesClose, name)) {
                var el = void 0;
                while (this.stack.length > 0 &&
                    openImpliesClose[name].has((el = this.stack[this.stack.length - 1]))) {
                    this.onclosetag(el);
                }
            }
            if (this.options.xmlMode || !voidElements.has(name)) {
                this.stack.push(name);
                if (foreignContextElements.has(name)) {
                    this.foreignContext.push(true);
                }
                else if (htmlIntegrationElements.has(name)) {
                    this.foreignContext.push(false);
                }
            }
            (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, name);
            if (this.cbs.onopentag)
                this.attribs = {};
        };
        Parser.prototype.onopentagend = function () {
            var _a, _b;
            this.updatePosition(1);
            if (this.attribs) {
                (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs);
                this.attribs = null;
            }
            if (!this.options.xmlMode &&
                this.cbs.onclosetag &&
                voidElements.has(this.tagname)) {
                this.cbs.onclosetag(this.tagname);
            }
            this.tagname = "";
        };
        Parser.prototype.onclosetag = function (name) {
            this.updatePosition(1);
            if (this.lowerCaseTagNames) {
                name = name.toLowerCase();
            }
            if (foreignContextElements.has(name) ||
                htmlIntegrationElements.has(name)) {
                this.foreignContext.pop();
            }
            if (this.stack.length &&
                (this.options.xmlMode || !voidElements.has(name))) {
                var pos = this.stack.lastIndexOf(name);
                if (pos !== -1) {
                    if (this.cbs.onclosetag) {
                        pos = this.stack.length - pos;
                        while (pos--) {
                            // We know the stack has sufficient elements.
                            this.cbs.onclosetag(this.stack.pop());
                        }
                    }
                    else
                        this.stack.length = pos;
                }
                else if (name === "p" && !this.options.xmlMode) {
                    this.onopentagname(name);
                    this.closeCurrentTag();
                }
            }
            else if (!this.options.xmlMode && (name === "br" || name === "p")) {
                this.onopentagname(name);
                this.closeCurrentTag();
            }
        };
        Parser.prototype.onselfclosingtag = function () {
            if (this.options.xmlMode ||
                this.options.recognizeSelfClosing ||
                this.foreignContext[this.foreignContext.length - 1]) {
                this.closeCurrentTag();
            }
            else {
                this.onopentagend();
            }
        };
        Parser.prototype.closeCurrentTag = function () {
            var _a, _b;
            var name = this.tagname;
            this.onopentagend();
            /*
             * Self-closing tags will be on the top of the stack
             * (cheaper check than in onclosetag)
             */
            if (this.stack[this.stack.length - 1] === name) {
                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name);
                this.stack.pop();
            }
        };
        Parser.prototype.onattribname = function (name) {
            if (this.lowerCaseAttributeNames) {
                name = name.toLowerCase();
            }
            this.attribname = name;
        };
        Parser.prototype.onattribdata = function (value) {
            this.attribvalue += value;
        };
        Parser.prototype.onattribend = function (quote) {
            var _a, _b;
            (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote);
            if (this.attribs &&
                !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
                this.attribs[this.attribname] = this.attribvalue;
            }
            this.attribname = "";
            this.attribvalue = "";
        };
        Parser.prototype.getInstructionName = function (value) {
            var idx = value.search(reNameEnd);
            var name = idx < 0 ? value : value.substr(0, idx);
            if (this.lowerCaseTagNames) {
                name = name.toLowerCase();
            }
            return name;
        };
        Parser.prototype.ondeclaration = function (value) {
            if (this.cbs.onprocessinginstruction) {
                var name_1 = this.getInstructionName(value);
                this.cbs.onprocessinginstruction("!" + name_1, "!" + value);
            }
        };
        Parser.prototype.onprocessinginstruction = function (value) {
            if (this.cbs.onprocessinginstruction) {
                var name_2 = this.getInstructionName(value);
                this.cbs.onprocessinginstruction("?" + name_2, "?" + value);
            }
        };
        Parser.prototype.oncomment = function (value) {
            var _a, _b, _c, _d;
            this.updatePosition(4);
            (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, value);
            (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
        };
        Parser.prototype.oncdata = function (value) {
            var _a, _b, _c, _d, _e, _f;
            this.updatePosition(1);
            if (this.options.xmlMode || this.options.recognizeCDATA) {
                (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
                (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
                (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
            }
            else {
                this.oncomment("[CDATA[" + value + "]]");
            }
        };
        Parser.prototype.onerror = function (err) {
            var _a, _b;
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, err);
        };
        Parser.prototype.onend = function () {
            var _a, _b;
            if (this.cbs.onclosetag) {
                for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i]))
                    ;
            }
            (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        /**
         * Resets the parser to a blank state, ready to parse a new HTML document
         */
        Parser.prototype.reset = function () {
            var _a, _b, _c, _d;
            (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
            this.tokenizer.reset();
            this.tagname = "";
            this.attribname = "";
            this.attribs = null;
            this.stack = [];
            (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        };
        /**
         * Resets the parser, then parses a complete document and
         * pushes it to the handler.
         *
         * @param data Document to parse.
         */
        Parser.prototype.parseComplete = function (data) {
            this.reset();
            this.end(data);
        };
        /**
         * Parses a chunk of data and calls the corresponding callbacks.
         *
         * @param chunk Chunk to parse.
         */
        Parser.prototype.write = function (chunk) {
            this.tokenizer.write(chunk);
        };
        /**
         * Parses the end of the buffer and clears the stack, calls onend.
         *
         * @param chunk Optional final chunk to parse.
         */
        Parser.prototype.end = function (chunk) {
            this.tokenizer.end(chunk);
        };
        /**
         * Pauses parsing. The parser won't emit events until `resume` is called.
         */
        Parser.prototype.pause = function () {
            this.tokenizer.pause();
        };
        /**
         * Resumes parsing after `pause` was called.
         */
        Parser.prototype.resume = function () {
            this.tokenizer.resume();
        };
        /**
         * Alias of `write`, for backwards compatibility.
         *
         * @param chunk Chunk to parse.
         * @deprecated
         */
        Parser.prototype.parseChunk = function (chunk) {
            this.write(chunk);
        };
        /**
         * Alias of `end`, for backwards compatibility.
         *
         * @param chunk Optional final chunk to parse.
         * @deprecated
         */
        Parser.prototype.done = function (chunk) {
            this.end(chunk);
        };
        return Parser;
    }());
    exports.Parser = Parser;
    });

    var decode = createCommonjsModule(function (module, exports) {
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
    var entities_json_1 = __importDefault(require$$1$3);
    var legacy_json_1 = __importDefault(require$$1$2);
    var xml_json_1 = __importDefault(require$$0$2);
    var decode_codepoint_1 = __importDefault(require$$3$1);
    var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
    exports.decodeXML = getStrictDecoder(xml_json_1.default);
    exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
    function getStrictDecoder(map) {
        var replace = getReplacer(map);
        return function (str) { return String(str).replace(strictEntityRe, replace); };
    }
    var sorter = function (a, b) { return (a < b ? 1 : -1); };
    exports.decodeHTML = (function () {
        var legacy = Object.keys(legacy_json_1.default).sort(sorter);
        var keys = Object.keys(entities_json_1.default).sort(sorter);
        for (var i = 0, j = 0; i < keys.length; i++) {
            if (legacy[j] === keys[i]) {
                keys[i] += ";?";
                j++;
            }
            else {
                keys[i] += ";";
            }
        }
        var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
        var replace = getReplacer(entities_json_1.default);
        function replacer(str) {
            if (str.substr(-1) !== ";")
                str += ";";
            return replace(str);
        }
        // TODO consider creating a merged map
        return function (str) { return String(str).replace(re, replacer); };
    })();
    function getReplacer(map) {
        return function replace(str) {
            if (str.charAt(1) === "#") {
                var secondChar = str.charAt(2);
                if (secondChar === "X" || secondChar === "x") {
                    return decode_codepoint_1.default(parseInt(str.substr(3), 16));
                }
                return decode_codepoint_1.default(parseInt(str.substr(2), 10));
            }
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            return map[str.slice(1, -1)] || str;
        };
    }
    });

    var encode = createCommonjsModule(function (module, exports) {
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
    var xml_json_1 = __importDefault(require$$0$2);
    var inverseXML = getInverseObj(xml_json_1.default);
    var xmlReplacer = getInverseReplacer(inverseXML);
    /**
     * Encodes all non-ASCII characters, as well as characters not valid in XML
     * documents using XML entities.
     *
     * If a character has no equivalent entity, a
     * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
     */
    exports.encodeXML = getASCIIEncoder(inverseXML);
    var entities_json_1 = __importDefault(require$$1$3);
    var inverseHTML = getInverseObj(entities_json_1.default);
    var htmlReplacer = getInverseReplacer(inverseHTML);
    /**
     * Encodes all entities and non-ASCII characters in the input.
     *
     * This includes characters that are valid ASCII characters in HTML documents.
     * For example `#` will be encoded as `&num;`. To get a more compact output,
     * consider using the `encodeNonAsciiHTML` function.
     *
     * If a character has no equivalent entity, a
     * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
     */
    exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
    /**
     * Encodes all non-ASCII characters, as well as characters not valid in HTML
     * documents using HTML entities.
     *
     * If a character has no equivalent entity, a
     * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
     */
    exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
    function getInverseObj(obj) {
        return Object.keys(obj)
            .sort()
            .reduce(function (inverse, name) {
            inverse[obj[name]] = "&" + name + ";";
            return inverse;
        }, {});
    }
    function getInverseReplacer(inverse) {
        var single = [];
        var multiple = [];
        for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
            var k = _a[_i];
            if (k.length === 1) {
                // Add value to single array
                single.push("\\" + k);
            }
            else {
                // Add value to multiple array
                multiple.push(k);
            }
        }
        // Add ranges to single characters.
        single.sort();
        for (var start = 0; start < single.length - 1; start++) {
            // Find the end of a run of characters
            var end = start;
            while (end < single.length - 1 &&
                single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
                end += 1;
            }
            var count = 1 + end - start;
            // We want to replace at least three characters
            if (count < 3)
                continue;
            single.splice(start, count, single[start] + "-" + single[end]);
        }
        multiple.unshift("[" + single.join("") + "]");
        return new RegExp(multiple.join("|"), "g");
    }
    // /[^\0-\x7F]/gu
    var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
    var getCodePoint = 
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null
        ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            function (str) { return str.codePointAt(0); }
        : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            function (c) {
                return (c.charCodeAt(0) - 0xd800) * 0x400 +
                    c.charCodeAt(1) -
                    0xdc00 +
                    0x10000;
            };
    function singleCharReplacer(c) {
        return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))
            .toString(16)
            .toUpperCase() + ";";
    }
    function getInverse(inverse, re) {
        return function (data) {
            return data
                .replace(re, function (name) { return inverse[name]; })
                .replace(reNonASCII, singleCharReplacer);
        };
    }
    var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
    /**
     * Encodes all non-ASCII characters, as well as characters not valid in XML
     * documents using numeric hexadecimal reference (eg. `&#xfc;`).
     *
     * Have a look at `escapeUTF8` if you want a more concise output at the expense
     * of reduced transportability.
     *
     * @param data String to escape.
     */
    function escape(data) {
        return data.replace(reEscapeChars, singleCharReplacer);
    }
    exports.escape = escape;
    /**
     * Encodes all characters not valid in XML documents using numeric hexadecimal
     * reference (eg. `&#xfc;`).
     *
     * Note that the output will be character-set dependent.
     *
     * @param data String to escape.
     */
    function escapeUTF8(data) {
        return data.replace(xmlReplacer, singleCharReplacer);
    }
    exports.escapeUTF8 = escapeUTF8;
    function getASCIIEncoder(obj) {
        return function (data) {
            return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });
        };
    }
    });

    var decode_1 = decode;

    var encode_1 = encode;

    var lib$3 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;


    /**
     * Decodes a string with entities.
     *
     * @param data String to decode.
     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
     * @deprecated Use `decodeXML` or `decodeHTML` directly.
     */
    function decode(data, level) {
        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }
    exports.decode = decode;
    /**
     * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
     *
     * @param data String to decode.
     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
     * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
     */
    function decodeStrict(data, level) {
        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }
    exports.decodeStrict = decodeStrict;
    /**
     * Encodes a string with entities.
     *
     * @param data String to encode.
     * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
     * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
     */
    function encode(data, level) {
        return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }
    exports.encode = encode;
    var encode_2 = encode_1;
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function () { return encode_2.encodeXML; } });
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });
    Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return encode_2.escape; } });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });
    // Legacy aliases (deprecated)
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
    var decode_2 = decode_1;
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function () { return decode_2.decodeXML; } });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
    // Legacy aliases (deprecated)
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function () { return decode_2.decodeXML; } });
    });

    var foreignNames = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeNames = exports.elementNames = void 0;
    exports.elementNames = new Map([
        ["altglyph", "altGlyph"],
        ["altglyphdef", "altGlyphDef"],
        ["altglyphitem", "altGlyphItem"],
        ["animatecolor", "animateColor"],
        ["animatemotion", "animateMotion"],
        ["animatetransform", "animateTransform"],
        ["clippath", "clipPath"],
        ["feblend", "feBlend"],
        ["fecolormatrix", "feColorMatrix"],
        ["fecomponenttransfer", "feComponentTransfer"],
        ["fecomposite", "feComposite"],
        ["feconvolvematrix", "feConvolveMatrix"],
        ["fediffuselighting", "feDiffuseLighting"],
        ["fedisplacementmap", "feDisplacementMap"],
        ["fedistantlight", "feDistantLight"],
        ["fedropshadow", "feDropShadow"],
        ["feflood", "feFlood"],
        ["fefunca", "feFuncA"],
        ["fefuncb", "feFuncB"],
        ["fefuncg", "feFuncG"],
        ["fefuncr", "feFuncR"],
        ["fegaussianblur", "feGaussianBlur"],
        ["feimage", "feImage"],
        ["femerge", "feMerge"],
        ["femergenode", "feMergeNode"],
        ["femorphology", "feMorphology"],
        ["feoffset", "feOffset"],
        ["fepointlight", "fePointLight"],
        ["fespecularlighting", "feSpecularLighting"],
        ["fespotlight", "feSpotLight"],
        ["fetile", "feTile"],
        ["feturbulence", "feTurbulence"],
        ["foreignobject", "foreignObject"],
        ["glyphref", "glyphRef"],
        ["lineargradient", "linearGradient"],
        ["radialgradient", "radialGradient"],
        ["textpath", "textPath"],
    ]);
    exports.attributeNames = new Map([
        ["definitionurl", "definitionURL"],
        ["attributename", "attributeName"],
        ["attributetype", "attributeType"],
        ["basefrequency", "baseFrequency"],
        ["baseprofile", "baseProfile"],
        ["calcmode", "calcMode"],
        ["clippathunits", "clipPathUnits"],
        ["diffuseconstant", "diffuseConstant"],
        ["edgemode", "edgeMode"],
        ["filterunits", "filterUnits"],
        ["glyphref", "glyphRef"],
        ["gradienttransform", "gradientTransform"],
        ["gradientunits", "gradientUnits"],
        ["kernelmatrix", "kernelMatrix"],
        ["kernelunitlength", "kernelUnitLength"],
        ["keypoints", "keyPoints"],
        ["keysplines", "keySplines"],
        ["keytimes", "keyTimes"],
        ["lengthadjust", "lengthAdjust"],
        ["limitingconeangle", "limitingConeAngle"],
        ["markerheight", "markerHeight"],
        ["markerunits", "markerUnits"],
        ["markerwidth", "markerWidth"],
        ["maskcontentunits", "maskContentUnits"],
        ["maskunits", "maskUnits"],
        ["numoctaves", "numOctaves"],
        ["pathlength", "pathLength"],
        ["patterncontentunits", "patternContentUnits"],
        ["patterntransform", "patternTransform"],
        ["patternunits", "patternUnits"],
        ["pointsatx", "pointsAtX"],
        ["pointsaty", "pointsAtY"],
        ["pointsatz", "pointsAtZ"],
        ["preservealpha", "preserveAlpha"],
        ["preserveaspectratio", "preserveAspectRatio"],
        ["primitiveunits", "primitiveUnits"],
        ["refx", "refX"],
        ["refy", "refY"],
        ["repeatcount", "repeatCount"],
        ["repeatdur", "repeatDur"],
        ["requiredextensions", "requiredExtensions"],
        ["requiredfeatures", "requiredFeatures"],
        ["specularconstant", "specularConstant"],
        ["specularexponent", "specularExponent"],
        ["spreadmethod", "spreadMethod"],
        ["startoffset", "startOffset"],
        ["stddeviation", "stdDeviation"],
        ["stitchtiles", "stitchTiles"],
        ["surfacescale", "surfaceScale"],
        ["systemlanguage", "systemLanguage"],
        ["tablevalues", "tableValues"],
        ["targetx", "targetX"],
        ["targety", "targetY"],
        ["textlength", "textLength"],
        ["viewbox", "viewBox"],
        ["viewtarget", "viewTarget"],
        ["xchannelselector", "xChannelSelector"],
        ["ychannelselector", "yChannelSelector"],
        ["zoomandpan", "zoomAndPan"],
    ]);
    });

    var entities_1 = lib$3;

    var foreignNames_1 = foreignNames;

    var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };

    /*
     * Module dependencies
     */
    var ElementType = __importStar(require$$0$4);

    /**
     * Mixed-case SVG and MathML tags & attributes
     * recognized by the HTML parser.
     *
     * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
     */

    var unencodedElements = new Set([
        "style",
        "script",
        "xmp",
        "iframe",
        "noembed",
        "noframes",
        "plaintext",
        "noscript",
    ]);
    /**
     * Format attributes
     */
    function formatAttributes(attributes, opts) {
        if (!attributes)
            return;
        return Object.keys(attributes)
            .map(function (key) {
            var _a, _b;
            var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
            if (opts.xmlMode === "foreign") {
                /* Fix up mixed-case attribute names */
                key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
            }
            if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
                return key;
            }
            return key + "=\"" + (opts.decodeEntities !== false
                ? entities_1.encodeXML(value)
                : value.replace(/"/g, "&quot;")) + "\"";
        })
            .join(" ");
    }
    /**
     * Self-enclosing tags
     */
    var singleTag = new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr",
    ]);
    /**
     * Renders a DOM node or an array of DOM nodes to a string.
     *
     * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
     *
     * @param node Node to be rendered.
     * @param options Changes serialization behavior
     */
    function render(node, options) {
        if (options === void 0) { options = {}; }
        var nodes = "length" in node ? node : [node];
        var output = "";
        for (var i = 0; i < nodes.length; i++) {
            output += renderNode(nodes[i], options);
        }
        return output;
    }
    var _default = render;
    function renderNode(node, options) {
        switch (node.type) {
            case ElementType.Root:
                return render(node.children, options);
            case ElementType.Directive:
            case ElementType.Doctype:
                return renderDirective(node);
            case ElementType.Comment:
                return renderComment(node);
            case ElementType.CDATA:
                return renderCdata(node);
            case ElementType.Script:
            case ElementType.Style:
            case ElementType.Tag:
                return renderTag(node, options);
            case ElementType.Text:
                return renderText(node, options);
        }
    }
    var foreignModeIntegrationPoints = new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title",
    ]);
    var foreignElements = new Set(["svg", "math"]);
    function renderTag(elem, opts) {
        var _a;
        // Handle SVG / MathML in HTML
        if (opts.xmlMode === "foreign") {
            /* Fix up mixed-case element names */
            elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
            /* Exit foreign mode at integration points */
            if (elem.parent &&
                foreignModeIntegrationPoints.has(elem.parent.name)) {
                opts = __assign(__assign({}, opts), { xmlMode: false });
            }
        }
        if (!opts.xmlMode && foreignElements.has(elem.name)) {
            opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
        }
        var tag = "<" + elem.name;
        var attribs = formatAttributes(elem.attribs, opts);
        if (attribs) {
            tag += " " + attribs;
        }
        if (elem.children.length === 0 &&
            (opts.xmlMode
                ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                    opts.selfClosingTags !== false
                : // User explicitly asked for self-closing tags, even in HTML mode
                    opts.selfClosingTags && singleTag.has(elem.name))) {
            if (!opts.xmlMode)
                tag += " ";
            tag += "/>";
        }
        else {
            tag += ">";
            if (elem.children.length > 0) {
                tag += render(elem.children, opts);
            }
            if (opts.xmlMode || !singleTag.has(elem.name)) {
                tag += "</" + elem.name + ">";
            }
        }
        return tag;
    }
    function renderDirective(elem) {
        return "<" + elem.data + ">";
    }
    function renderText(elem, opts) {
        var data = elem.data || "";
        // If entities weren't decoded, no need to encode them back
        if (opts.decodeEntities !== false &&
            !(!opts.xmlMode &&
                elem.parent &&
                unencodedElements.has(elem.parent.name))) {
            data = entities_1.encodeXML(data);
        }
        return data;
    }
    function renderCdata(elem) {
        return "<![CDATA[" + elem.children[0].data + "]]>";
    }
    function renderComment(elem) {
        return "<!--" + elem.data + "-->";
    }

    var lib$2 = /*#__PURE__*/Object.defineProperty({
    	default: _default
    }, '__esModule', {value: true});

    var require$$0$1 = lib$2;

    var stringify = createCommonjsModule(function (module, exports) {
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;

    var dom_serializer_1 = __importDefault(require$$0$1);

    /**
     * @param node Node to get the outer HTML of.
     * @param options Options for serialization.
     * @deprecated Use the `dom-serializer` module directly.
     * @returns `node`'s outer HTML.
     */
    function getOuterHTML(node, options) {
        return (0, dom_serializer_1.default)(node, options);
    }
    exports.getOuterHTML = getOuterHTML;
    /**
     * @param node Node to get the inner HTML of.
     * @param options Options for serialization.
     * @deprecated Use the `dom-serializer` module directly.
     * @returns `node`'s inner HTML.
     */
    function getInnerHTML(node, options) {
        return (0, domhandler_1.hasChildren)(node)
            ? node.children.map(function (node) { return getOuterHTML(node, options); }).join("")
            : "";
    }
    exports.getInnerHTML = getInnerHTML;
    /**
     * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags.
     *
     * @deprecated Use `textContent` instead.
     * @param node Node to get the inner text of.
     * @returns `node`'s inner text.
     */
    function getText(node) {
        if (Array.isArray(node))
            return node.map(getText).join("");
        if ((0, domhandler_1.isTag)(node))
            return node.name === "br" ? "\n" : getText(node.children);
        if ((0, domhandler_1.isCDATA)(node))
            return getText(node.children);
        if ((0, domhandler_1.isText)(node))
            return node.data;
        return "";
    }
    exports.getText = getText;
    /**
     * Get a node's text content.
     *
     * @param node Node to get the text content of.
     * @returns `node`'s text content.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
     */
    function textContent(node) {
        if (Array.isArray(node))
            return node.map(textContent).join("");
        if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
            return textContent(node.children);
        }
        if ((0, domhandler_1.isText)(node))
            return node.data;
        return "";
    }
    exports.textContent = textContent;
    /**
     * Get a node's inner text.
     *
     * @param node Node to get the inner text of.
     * @returns `node`'s inner text.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
     */
    function innerText(node) {
        if (Array.isArray(node))
            return node.map(innerText).join("");
        if ((0, domhandler_1.hasChildren)(node) && (node.type === require$$0$4.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
            return innerText(node.children);
        }
        if ((0, domhandler_1.isText)(node))
            return node.data;
        return "";
    }
    exports.innerText = innerText;
    });

    var traversal = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;

    var emptyArray = [];
    /**
     * Get a node's children.
     *
     * @param elem Node to get the children of.
     * @returns `elem`'s children, or an empty array.
     */
    function getChildren(elem) {
        var _a;
        return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
    }
    exports.getChildren = getChildren;
    /**
     * Get a node's parent.
     *
     * @param elem Node to get the parent of.
     * @returns `elem`'s parent node.
     */
    function getParent(elem) {
        return elem.parent || null;
    }
    exports.getParent = getParent;
    /**
     * Gets an elements siblings, including the element itself.
     *
     * Attempts to get the children through the element's parent first.
     * If we don't have a parent (the element is a root node),
     * we walk the element's `prev` & `next` to get all remaining nodes.
     *
     * @param elem Element to get the siblings of.
     * @returns `elem`'s siblings.
     */
    function getSiblings(elem) {
        var _a, _b;
        var parent = getParent(elem);
        if (parent != null)
            return getChildren(parent);
        var siblings = [elem];
        var prev = elem.prev, next = elem.next;
        while (prev != null) {
            siblings.unshift(prev);
            (_a = prev, prev = _a.prev);
        }
        while (next != null) {
            siblings.push(next);
            (_b = next, next = _b.next);
        }
        return siblings;
    }
    exports.getSiblings = getSiblings;
    /**
     * Gets an attribute from an element.
     *
     * @param elem Element to check.
     * @param name Attribute name to retrieve.
     * @returns The element's attribute value, or `undefined`.
     */
    function getAttributeValue(elem, name) {
        var _a;
        return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
    }
    exports.getAttributeValue = getAttributeValue;
    /**
     * Checks whether an element has an attribute.
     *
     * @param elem Element to check.
     * @param name Attribute name to look for.
     * @returns Returns whether `elem` has the attribute `name`.
     */
    function hasAttrib(elem, name) {
        return (elem.attribs != null &&
            Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
            elem.attribs[name] != null);
    }
    exports.hasAttrib = hasAttrib;
    /**
     * Get the tag name of an element.
     *
     * @param elem The element to get the name for.
     * @returns The tag name of `elem`.
     */
    function getName(elem) {
        return elem.name;
    }
    exports.getName = getName;
    /**
     * Returns the next element sibling of a node.
     *
     * @param elem The element to get the next sibling of.
     * @returns `elem`'s next sibling that is a tag.
     */
    function nextElementSibling(elem) {
        var _a;
        var next = elem.next;
        while (next !== null && !(0, domhandler_1.isTag)(next))
            (_a = next, next = _a.next);
        return next;
    }
    exports.nextElementSibling = nextElementSibling;
    /**
     * Returns the previous element sibling of a node.
     *
     * @param elem The element to get the previous sibling of.
     * @returns `elem`'s previous sibling that is a tag.
     */
    function prevElementSibling(elem) {
        var _a;
        var prev = elem.prev;
        while (prev !== null && !(0, domhandler_1.isTag)(prev))
            (_a = prev, prev = _a.prev);
        return prev;
    }
    exports.prevElementSibling = prevElementSibling;
    });

    var manipulation = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
    /**
     * Remove an element from the dom
     *
     * @param elem The element to be removed
     */
    function removeElement(elem) {
        if (elem.prev)
            elem.prev.next = elem.next;
        if (elem.next)
            elem.next.prev = elem.prev;
        if (elem.parent) {
            var childs = elem.parent.children;
            childs.splice(childs.lastIndexOf(elem), 1);
        }
    }
    exports.removeElement = removeElement;
    /**
     * Replace an element in the dom
     *
     * @param elem The element to be replaced
     * @param replacement The element to be added
     */
    function replaceElement(elem, replacement) {
        var prev = (replacement.prev = elem.prev);
        if (prev) {
            prev.next = replacement;
        }
        var next = (replacement.next = elem.next);
        if (next) {
            next.prev = replacement;
        }
        var parent = (replacement.parent = elem.parent);
        if (parent) {
            var childs = parent.children;
            childs[childs.lastIndexOf(elem)] = replacement;
        }
    }
    exports.replaceElement = replaceElement;
    /**
     * Append a child to an element.
     *
     * @param elem The element to append to.
     * @param child The element to be added as a child.
     */
    function appendChild(elem, child) {
        removeElement(child);
        child.next = null;
        child.parent = elem;
        if (elem.children.push(child) > 1) {
            var sibling = elem.children[elem.children.length - 2];
            sibling.next = child;
            child.prev = sibling;
        }
        else {
            child.prev = null;
        }
    }
    exports.appendChild = appendChild;
    /**
     * Append an element after another.
     *
     * @param elem The element to append after.
     * @param next The element be added.
     */
    function append(elem, next) {
        removeElement(next);
        var parent = elem.parent;
        var currNext = elem.next;
        next.next = currNext;
        next.prev = elem;
        elem.next = next;
        next.parent = parent;
        if (currNext) {
            currNext.prev = next;
            if (parent) {
                var childs = parent.children;
                childs.splice(childs.lastIndexOf(currNext), 0, next);
            }
        }
        else if (parent) {
            parent.children.push(next);
        }
    }
    exports.append = append;
    /**
     * Prepend a child to an element.
     *
     * @param elem The element to prepend before.
     * @param child The element to be added as a child.
     */
    function prependChild(elem, child) {
        removeElement(child);
        child.parent = elem;
        child.prev = null;
        if (elem.children.unshift(child) !== 1) {
            var sibling = elem.children[1];
            sibling.prev = child;
            child.next = sibling;
        }
        else {
            child.next = null;
        }
    }
    exports.prependChild = prependChild;
    /**
     * Prepend an element before another.
     *
     * @param elem The element to prepend before.
     * @param prev The element be added.
     */
    function prepend(elem, prev) {
        removeElement(prev);
        var parent = elem.parent;
        if (parent) {
            var childs = parent.children;
            childs.splice(childs.indexOf(elem), 0, prev);
        }
        if (elem.prev) {
            elem.prev.next = prev;
        }
        prev.parent = parent;
        prev.prev = elem.prev;
        prev.next = elem;
        elem.prev = prev;
    }
    exports.prepend = prepend;
    });

    var querying = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;

    /**
     * Search a node and its children for nodes passing a test function.
     *
     * @param test Function to test nodes on.
     * @param node Node to search. Will be included in the result set if it matches.
     * @param recurse Also consider child nodes.
     * @param limit Maximum number of nodes to return.
     * @returns All nodes passing `test`.
     */
    function filter(test, node, recurse, limit) {
        if (recurse === void 0) { recurse = true; }
        if (limit === void 0) { limit = Infinity; }
        if (!Array.isArray(node))
            node = [node];
        return find(test, node, recurse, limit);
    }
    exports.filter = filter;
    /**
     * Search an array of node and its children for nodes passing a test function.
     *
     * @param test Function to test nodes on.
     * @param nodes Array of nodes to search.
     * @param recurse Also consider child nodes.
     * @param limit Maximum number of nodes to return.
     * @returns All nodes passing `test`.
     */
    function find(test, nodes, recurse, limit) {
        var result = [];
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
            var elem = nodes_1[_i];
            if (test(elem)) {
                result.push(elem);
                if (--limit <= 0)
                    break;
            }
            if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
                var children = find(test, elem.children, recurse, limit);
                result.push.apply(result, children);
                limit -= children.length;
                if (limit <= 0)
                    break;
            }
        }
        return result;
    }
    exports.find = find;
    /**
     * Finds the first element inside of an array that matches a test function.
     *
     * @param test Function to test nodes on.
     * @param nodes Array of nodes to search.
     * @returns The first node in the array that passes `test`.
     */
    function findOneChild(test, nodes) {
        return nodes.find(test);
    }
    exports.findOneChild = findOneChild;
    /**
     * Finds one element in a tree that passes a test.
     *
     * @param test Function to test nodes on.
     * @param nodes Array of nodes to search.
     * @param recurse Also consider child nodes.
     * @returns The first child node that passes `test`.
     */
    function findOne(test, nodes, recurse) {
        if (recurse === void 0) { recurse = true; }
        var elem = null;
        for (var i = 0; i < nodes.length && !elem; i++) {
            var checked = nodes[i];
            if (!(0, domhandler_1.isTag)(checked)) {
                continue;
            }
            else if (test(checked)) {
                elem = checked;
            }
            else if (recurse && checked.children.length > 0) {
                elem = findOne(test, checked.children);
            }
        }
        return elem;
    }
    exports.findOne = findOne;
    /**
     * @param test Function to test nodes on.
     * @param nodes Array of nodes to search.
     * @returns Whether a tree of nodes contains at least one node passing a test.
     */
    function existsOne(test, nodes) {
        return nodes.some(function (checked) {
            return (0, domhandler_1.isTag)(checked) &&
                (test(checked) ||
                    (checked.children.length > 0 &&
                        existsOne(test, checked.children)));
        });
    }
    exports.existsOne = existsOne;
    /**
     * Search and array of nodes and its children for nodes passing a test function.
     *
     * Same as `find`, only with less options, leading to reduced complexity.
     *
     * @param test Function to test nodes on.
     * @param nodes Array of nodes to search.
     * @returns All nodes passing `test`.
     */
    function findAll(test, nodes) {
        var _a;
        var result = [];
        var stack = nodes.filter(domhandler_1.isTag);
        var elem;
        while ((elem = stack.shift())) {
            var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);
            if (children && children.length > 0) {
                stack.unshift.apply(stack, children);
            }
            if (test(elem))
                result.push(elem);
        }
        return result;
    }
    exports.findAll = findAll;
    });

    var require$$3 = querying;

    var legacy = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;


    var Checks = {
        tag_name: function (name) {
            if (typeof name === "function") {
                return function (elem) { return (0, domhandler_1.isTag)(elem) && name(elem.name); };
            }
            else if (name === "*") {
                return domhandler_1.isTag;
            }
            return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.name === name; };
        },
        tag_type: function (type) {
            if (typeof type === "function") {
                return function (elem) { return type(elem.type); };
            }
            return function (elem) { return elem.type === type; };
        },
        tag_contains: function (data) {
            if (typeof data === "function") {
                return function (elem) { return (0, domhandler_1.isText)(elem) && data(elem.data); };
            }
            return function (elem) { return (0, domhandler_1.isText)(elem) && elem.data === data; };
        },
    };
    /**
     * @param attrib Attribute to check.
     * @param value Attribute value to look for.
     * @returns A function to check whether the a node has an attribute with a particular value.
     */
    function getAttribCheck(attrib, value) {
        if (typeof value === "function") {
            return function (elem) { return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]); };
        }
        return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value; };
    }
    /**
     * @param a First function to combine.
     * @param b Second function to combine.
     * @returns A function taking a node and returning `true` if either
     * of the input functions returns `true` for the node.
     */
    function combineFuncs(a, b) {
        return function (elem) { return a(elem) || b(elem); };
    }
    /**
     * @param options An object describing nodes to look for.
     * @returns A function executing all checks in `options` and returning `true`
     * if any of them match a node.
     */
    function compileTest(options) {
        var funcs = Object.keys(options).map(function (key) {
            var value = options[key];
            return Object.prototype.hasOwnProperty.call(Checks, key)
                ? Checks[key](value)
                : getAttribCheck(key, value);
        });
        return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    /**
     * @param options An object describing nodes to look for.
     * @param node The element to test.
     * @returns Whether the element matches the description in `options`.
     */
    function testElement(options, node) {
        var test = compileTest(options);
        return test ? test(node) : true;
    }
    exports.testElement = testElement;
    /**
     * @param options An object describing nodes to look for.
     * @param nodes Nodes to search through.
     * @param recurse Also consider child nodes.
     * @param limit Maximum number of nodes to return.
     * @returns All nodes that match `options`.
     */
    function getElements(options, nodes, recurse, limit) {
        if (limit === void 0) { limit = Infinity; }
        var test = compileTest(options);
        return test ? (0, require$$3.filter)(test, nodes, recurse, limit) : [];
    }
    exports.getElements = getElements;
    /**
     * @param id The unique ID attribute value to look for.
     * @param nodes Nodes to search through.
     * @param recurse Also consider child nodes.
     * @returns The node with the supplied ID.
     */
    function getElementById(id, nodes, recurse) {
        if (recurse === void 0) { recurse = true; }
        if (!Array.isArray(nodes))
            nodes = [nodes];
        return (0, require$$3.findOne)(getAttribCheck("id", id), nodes, recurse);
    }
    exports.getElementById = getElementById;
    /**
     * @param tagName Tag name to search for.
     * @param nodes Nodes to search through.
     * @param recurse Also consider child nodes.
     * @param limit Maximum number of nodes to return.
     * @returns All nodes with the supplied `tagName`.
     */
    function getElementsByTagName(tagName, nodes, recurse, limit) {
        if (recurse === void 0) { recurse = true; }
        if (limit === void 0) { limit = Infinity; }
        return (0, require$$3.filter)(Checks.tag_name(tagName), nodes, recurse, limit);
    }
    exports.getElementsByTagName = getElementsByTagName;
    /**
     * @param type Element type to look for.
     * @param nodes Nodes to search through.
     * @param recurse Also consider child nodes.
     * @param limit Maximum number of nodes to return.
     * @returns All nodes with the supplied `type`.
     */
    function getElementsByTagType(type, nodes, recurse, limit) {
        if (recurse === void 0) { recurse = true; }
        if (limit === void 0) { limit = Infinity; }
        return (0, require$$3.filter)(Checks.tag_type(type), nodes, recurse, limit);
    }
    exports.getElementsByTagType = getElementsByTagType;
    });

    var helpers = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;

    /**
     * Given an array of nodes, remove any member that is contained by another.
     *
     * @param nodes Nodes to filter.
     * @returns Remaining nodes that aren't subtrees of each other.
     */
    function removeSubsets(nodes) {
        var idx = nodes.length;
        /*
         * Check if each node (or one of its ancestors) is already contained in the
         * array.
         */
        while (--idx >= 0) {
            var node = nodes[idx];
            /*
             * Remove the node if it is not unique.
             * We are going through the array from the end, so we only
             * have to check nodes that preceed the node under consideration in the array.
             */
            if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
                nodes.splice(idx, 1);
                continue;
            }
            for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
                if (nodes.includes(ancestor)) {
                    nodes.splice(idx, 1);
                    break;
                }
            }
        }
        return nodes;
    }
    exports.removeSubsets = removeSubsets;
    /**
     * Compare the position of one node against another node in any other document.
     * The return value is a bitmask with the following values:
     *
     * Document order:
     * > There is an ordering, document order, defined on all the nodes in the
     * > document corresponding to the order in which the first character of the
     * > XML representation of each node occurs in the XML representation of the
     * > document after expansion of general entities. Thus, the document element
     * > node will be the first node. Element nodes occur before their children.
     * > Thus, document order orders element nodes in order of the occurrence of
     * > their start-tag in the XML (after expansion of entities). The attribute
     * > nodes of an element occur after the element and before its children. The
     * > relative order of attribute nodes is implementation-dependent./
     *
     * Source:
     * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
     *
     * @param nodeA The first node to use in the comparison
     * @param nodeB The second node to use in the comparison
     * @returns A bitmask describing the input nodes' relative position.
     *
     * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
     * a description of these values.
     */
    function compareDocumentPosition(nodeA, nodeB) {
        var aParents = [];
        var bParents = [];
        if (nodeA === nodeB) {
            return 0;
        }
        var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
        while (current) {
            aParents.unshift(current);
            current = current.parent;
        }
        current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
        while (current) {
            bParents.unshift(current);
            current = current.parent;
        }
        var maxIdx = Math.min(aParents.length, bParents.length);
        var idx = 0;
        while (idx < maxIdx && aParents[idx] === bParents[idx]) {
            idx++;
        }
        if (idx === 0) {
            return 1 /* DISCONNECTED */;
        }
        var sharedParent = aParents[idx - 1];
        var siblings = sharedParent.children;
        var aSibling = aParents[idx];
        var bSibling = bParents[idx];
        if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
            if (sharedParent === nodeB) {
                return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;
            }
            return 4 /* FOLLOWING */;
        }
        if (sharedParent === nodeA) {
            return 2 /* PRECEDING */ | 8 /* CONTAINS */;
        }
        return 2 /* PRECEDING */;
    }
    exports.compareDocumentPosition = compareDocumentPosition;
    /**
     * Sort an array of nodes based on their relative position in the document and
     * remove any duplicate nodes. If the array contains nodes that do not belong
     * to the same document, sort order is unspecified.
     *
     * @param nodes Array of DOM nodes.
     * @returns Collection of unique nodes, sorted in document order.
     */
    function uniqueSort(nodes) {
        nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
        nodes.sort(function (a, b) {
            var relative = compareDocumentPosition(a, b);
            if (relative & 2 /* PRECEDING */) {
                return -1;
            }
            else if (relative & 4 /* FOLLOWING */) {
                return 1;
            }
            return 0;
        });
        return nodes;
    }
    exports.uniqueSort = uniqueSort;
    });

    var require$$0 = stringify;

    var require$$4 = legacy;

    var feeds = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeed = void 0;


    /**
     * Get the feed object from the root of a DOM tree.
     *
     * @param doc - The DOM to to extract the feed from.
     * @returns The feed.
     */
    function getFeed(doc) {
        var feedRoot = getOneElement(isValidFeed, doc);
        return !feedRoot
            ? null
            : feedRoot.name === "feed"
                ? getAtomFeed(feedRoot)
                : getRssFeed(feedRoot);
    }
    exports.getFeed = getFeed;
    /**
     * Parse an Atom feed.
     *
     * @param feedRoot The root of the feed.
     * @returns The parsed feed.
     */
    function getAtomFeed(feedRoot) {
        var _a;
        var childs = feedRoot.children;
        var feed = {
            type: "atom",
            items: (0, require$$4.getElementsByTagName)("entry", childs).map(function (item) {
                var _a;
                var children = item.children;
                var entry = { media: getMediaElements(children) };
                addConditionally(entry, "id", "id", children);
                addConditionally(entry, "title", "title", children);
                var href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs.href;
                if (href) {
                    entry.link = href;
                }
                var description = fetch("summary", children) || fetch("content", children);
                if (description) {
                    entry.description = description;
                }
                var pubDate = fetch("updated", children);
                if (pubDate) {
                    entry.pubDate = new Date(pubDate);
                }
                return entry;
            }),
        };
        addConditionally(feed, "id", "id", childs);
        addConditionally(feed, "title", "title", childs);
        var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs.href;
        if (href) {
            feed.link = href;
        }
        addConditionally(feed, "description", "subtitle", childs);
        var updated = fetch("updated", childs);
        if (updated) {
            feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "email", childs, true);
        return feed;
    }
    /**
     * Parse a RSS feed.
     *
     * @param feedRoot The root of the feed.
     * @returns The parsed feed.
     */
    function getRssFeed(feedRoot) {
        var _a, _b;
        var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
        var feed = {
            type: feedRoot.name.substr(0, 3),
            id: "",
            items: (0, require$$4.getElementsByTagName)("item", feedRoot.children).map(function (item) {
                var children = item.children;
                var entry = { media: getMediaElements(children) };
                addConditionally(entry, "id", "guid", children);
                addConditionally(entry, "title", "title", children);
                addConditionally(entry, "link", "link", children);
                addConditionally(entry, "description", "description", children);
                var pubDate = fetch("pubDate", children);
                if (pubDate)
                    entry.pubDate = new Date(pubDate);
                return entry;
            }),
        };
        addConditionally(feed, "title", "title", childs);
        addConditionally(feed, "link", "link", childs);
        addConditionally(feed, "description", "description", childs);
        var updated = fetch("lastBuildDate", childs);
        if (updated) {
            feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "managingEditor", childs, true);
        return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
        "fileSize",
        "bitrate",
        "framerate",
        "samplingrate",
        "channels",
        "duration",
        "height",
        "width",
    ];
    /**
     * Get all media elements of a feed item.
     *
     * @param where Nodes to search in.
     * @returns Media elements.
     */
    function getMediaElements(where) {
        return (0, require$$4.getElementsByTagName)("media:content", where).map(function (elem) {
            var attribs = elem.attribs;
            var media = {
                medium: attribs.medium,
                isDefault: !!attribs.isDefault,
            };
            for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
                var attrib = MEDIA_KEYS_STRING_1[_i];
                if (attribs[attrib]) {
                    media[attrib] = attribs[attrib];
                }
            }
            for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
                var attrib = MEDIA_KEYS_INT_1[_a];
                if (attribs[attrib]) {
                    media[attrib] = parseInt(attribs[attrib], 10);
                }
            }
            if (attribs.expression) {
                media.expression =
                    attribs.expression;
            }
            return media;
        });
    }
    /**
     * Get one element by tag name.
     *
     * @param tagName Tag name to look for
     * @param node Node to search in
     * @returns The element or null
     */
    function getOneElement(tagName, node) {
        return (0, require$$4.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    /**
     * Get the text content of an element with a certain tag name.
     *
     * @param tagName Tag name to look for.
     * @param where  Node to search in.
     * @param recurse Whether to recurse into child nodes.
     * @returns The text content of the element.
     */
    function fetch(tagName, where, recurse) {
        if (recurse === void 0) { recurse = false; }
        return (0, require$$0.textContent)((0, require$$4.getElementsByTagName)(tagName, where, recurse, 1)).trim();
    }
    /**
     * Adds a property to an object if it has a value.
     *
     * @param obj Object to be extended
     * @param prop Property name
     * @param tagName Tag name that contains the conditionally added property
     * @param where Element to search for the property
     * @param recurse Whether to recurse into child nodes.
     */
    function addConditionally(obj, prop, tagName, where, recurse) {
        if (recurse === void 0) { recurse = false; }
        var val = fetch(tagName, where, recurse);
        if (val)
            obj[prop] = val;
    }
    /**
     * Checks if an element is a feed root node.
     *
     * @param value The name of the element to check.
     * @returns Whether an element is a feed root node.
     */
    function isValidFeed(value) {
        return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
    });

    var require$$1$1 = traversal;

    var require$$2 = manipulation;

    var require$$5 = helpers;

    var require$$6 = feeds;

    var lib$1 = createCommonjsModule(function (module, exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
    __exportStar(require$$0, exports);
    __exportStar(require$$1$1, exports);
    __exportStar(require$$2, exports);
    __exportStar(require$$3, exports);
    __exportStar(require$$4, exports);
    __exportStar(require$$5, exports);
    __exportStar(require$$6, exports);
    /** @deprecated Use these methods from `domhandler` directly. */

    Object.defineProperty(exports, "isTag", { enumerable: true, get: function () { return domhandler_1.isTag; } });
    Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function () { return domhandler_1.isCDATA; } });
    Object.defineProperty(exports, "isText", { enumerable: true, get: function () { return domhandler_1.isText; } });
    Object.defineProperty(exports, "isComment", { enumerable: true, get: function () { return domhandler_1.isComment; } });
    Object.defineProperty(exports, "isDocument", { enumerable: true, get: function () { return domhandler_1.isDocument; } });
    Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function () { return domhandler_1.hasChildren; } });
    });

    var require$$1 = lib$1;

    var Parser_1 = Parser_1$1;

    var FeedHandler_1$1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseFeed = exports.FeedHandler = void 0;
    var domhandler_1$1 = __importDefault(domhandler_1);
    var DomUtils = __importStar(require$$1);

    var FeedItemMediaMedium;
    (function (FeedItemMediaMedium) {
        FeedItemMediaMedium[FeedItemMediaMedium["image"] = 0] = "image";
        FeedItemMediaMedium[FeedItemMediaMedium["audio"] = 1] = "audio";
        FeedItemMediaMedium[FeedItemMediaMedium["video"] = 2] = "video";
        FeedItemMediaMedium[FeedItemMediaMedium["document"] = 3] = "document";
        FeedItemMediaMedium[FeedItemMediaMedium["executable"] = 4] = "executable";
    })(FeedItemMediaMedium || (FeedItemMediaMedium = {}));
    var FeedItemMediaExpression;
    (function (FeedItemMediaExpression) {
        FeedItemMediaExpression[FeedItemMediaExpression["sample"] = 0] = "sample";
        FeedItemMediaExpression[FeedItemMediaExpression["full"] = 1] = "full";
        FeedItemMediaExpression[FeedItemMediaExpression["nonstop"] = 2] = "nonstop";
    })(FeedItemMediaExpression || (FeedItemMediaExpression = {}));
    // TODO: Consume data as it is coming in
    var FeedHandler = /** @class */ (function (_super) {
        __extends(FeedHandler, _super);
        /**
         *
         * @param callback
         * @param options
         */
        function FeedHandler(callback, options) {
            var _this = this;
            if (typeof callback === "object") {
                callback = undefined;
                options = callback;
            }
            _this = _super.call(this, callback, options) || this;
            return _this;
        }
        FeedHandler.prototype.onend = function () {
            var _a, _b;
            var feedRoot = getOneElement(isValidFeed, this.dom);
            if (!feedRoot) {
                this.handleCallback(new Error("couldn't find root of feed"));
                return;
            }
            var feed = {};
            if (feedRoot.name === "feed") {
                var childs = feedRoot.children;
                feed.type = "atom";
                addConditionally(feed, "id", "id", childs);
                addConditionally(feed, "title", "title", childs);
                var href = getAttribute("href", getOneElement("link", childs));
                if (href) {
                    feed.link = href;
                }
                addConditionally(feed, "description", "subtitle", childs);
                var updated = fetch("updated", childs);
                if (updated) {
                    feed.updated = new Date(updated);
                }
                addConditionally(feed, "author", "email", childs, true);
                feed.items = getElements("entry", childs).map(function (item) {
                    var entry = {};
                    var children = item.children;
                    addConditionally(entry, "id", "id", children);
                    addConditionally(entry, "title", "title", children);
                    var href = getAttribute("href", getOneElement("link", children));
                    if (href) {
                        entry.link = href;
                    }
                    var description = fetch("summary", children) || fetch("content", children);
                    if (description) {
                        entry.description = description;
                    }
                    var pubDate = fetch("updated", children);
                    if (pubDate) {
                        entry.pubDate = new Date(pubDate);
                    }
                    entry.media = getMediaElements(children);
                    return entry;
                });
            }
            else {
                var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
                feed.type = feedRoot.name.substr(0, 3);
                feed.id = "";
                addConditionally(feed, "title", "title", childs);
                addConditionally(feed, "link", "link", childs);
                addConditionally(feed, "description", "description", childs);
                var updated = fetch("lastBuildDate", childs);
                if (updated) {
                    feed.updated = new Date(updated);
                }
                addConditionally(feed, "author", "managingEditor", childs, true);
                feed.items = getElements("item", feedRoot.children).map(function (item) {
                    var entry = {};
                    var children = item.children;
                    addConditionally(entry, "id", "guid", children);
                    addConditionally(entry, "title", "title", children);
                    addConditionally(entry, "link", "link", children);
                    addConditionally(entry, "description", "description", children);
                    var pubDate = fetch("pubDate", children);
                    if (pubDate)
                        entry.pubDate = new Date(pubDate);
                    entry.media = getMediaElements(children);
                    return entry;
                });
            }
            this.feed = feed;
            this.handleCallback(null);
        };
        return FeedHandler;
    }(domhandler_1$1.default));
    exports.FeedHandler = FeedHandler;
    function getMediaElements(where) {
        return getElements("media:content", where).map(function (elem) {
            var media = {
                medium: elem.attribs.medium,
                isDefault: !!elem.attribs.isDefault,
            };
            if (elem.attribs.url) {
                media.url = elem.attribs.url;
            }
            if (elem.attribs.fileSize) {
                media.fileSize = parseInt(elem.attribs.fileSize, 10);
            }
            if (elem.attribs.type) {
                media.type = elem.attribs.type;
            }
            if (elem.attribs.expression) {
                media.expression = elem.attribs
                    .expression;
            }
            if (elem.attribs.bitrate) {
                media.bitrate = parseInt(elem.attribs.bitrate, 10);
            }
            if (elem.attribs.framerate) {
                media.framerate = parseInt(elem.attribs.framerate, 10);
            }
            if (elem.attribs.samplingrate) {
                media.samplingrate = parseInt(elem.attribs.samplingrate, 10);
            }
            if (elem.attribs.channels) {
                media.channels = parseInt(elem.attribs.channels, 10);
            }
            if (elem.attribs.duration) {
                media.duration = parseInt(elem.attribs.duration, 10);
            }
            if (elem.attribs.height) {
                media.height = parseInt(elem.attribs.height, 10);
            }
            if (elem.attribs.width) {
                media.width = parseInt(elem.attribs.width, 10);
            }
            if (elem.attribs.lang) {
                media.lang = elem.attribs.lang;
            }
            return media;
        });
    }
    function getElements(tagName, where) {
        return DomUtils.getElementsByTagName(tagName, where, true);
    }
    function getOneElement(tagName, node) {
        return DomUtils.getElementsByTagName(tagName, node, true, 1)[0];
    }
    function fetch(tagName, where, recurse) {
        if (recurse === void 0) { recurse = false; }
        return DomUtils.getText(DomUtils.getElementsByTagName(tagName, where, recurse, 1)).trim();
    }
    function getAttribute(name, elem) {
        if (!elem) {
            return null;
        }
        var attribs = elem.attribs;
        return attribs[name];
    }
    function addConditionally(obj, prop, what, where, recurse) {
        if (recurse === void 0) { recurse = false; }
        var tmp = fetch(what, where, recurse);
        if (tmp)
            obj[prop] = tmp;
    }
    function isValidFeed(value) {
        return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
    /**
     * Parse a feed.
     *
     * @param feed The feed that should be parsed, as a string.
     * @param options Optionally, options for parsing. When using this option, you should set `xmlMode` to `true`.
     */
    function parseFeed(feed, options) {
        if (options === void 0) { options = { xmlMode: true }; }
        var handler = new FeedHandler(options);
        new Parser_1.Parser(handler, options).end(feed);
        return handler.feed;
    }
    exports.parseFeed = parseFeed;
    });

    var FeedHandler_1 = FeedHandler_1$1;

    var lib = createCommonjsModule(function (module, exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RssHandler = exports.DefaultHandler = exports.DomUtils = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DomHandler = exports.Parser = void 0;

    Object.defineProperty(exports, "Parser", { enumerable: true, get: function () { return Parser_1.Parser; } });

    Object.defineProperty(exports, "DomHandler", { enumerable: true, get: function () { return domhandler_1.DomHandler; } });
    Object.defineProperty(exports, "DefaultHandler", { enumerable: true, get: function () { return domhandler_1.DomHandler; } });
    // Helper methods
    /**
     * Parses the data, returns the resulting document.
     *
     * @param data The data that should be parsed.
     * @param options Optional options for the parser and DOM builder.
     */
    function parseDocument(data, options) {
        var handler = new domhandler_1.DomHandler(undefined, options);
        new Parser_1.Parser(handler, options).end(data);
        return handler.root;
    }
    exports.parseDocument = parseDocument;
    /**
     * Parses data, returns an array of the root nodes.
     *
     * Note that the root nodes still have a `Document` node as their parent.
     * Use `parseDocument` to get the `Document` node instead.
     *
     * @param data The data that should be parsed.
     * @param options Optional options for the parser and DOM builder.
     * @deprecated Use `parseDocument` instead.
     */
    function parseDOM(data, options) {
        return parseDocument(data, options).children;
    }
    exports.parseDOM = parseDOM;
    /**
     * Creates a parser instance, with an attached DOM handler.
     *
     * @param cb A callback that will be called once parsing has been completed.
     * @param options Optional options for the parser and DOM builder.
     * @param elementCb An optional callback that will be called every time a tag has been completed inside of the DOM.
     */
    function createDomStream(cb, options, elementCb) {
        var handler = new domhandler_1.DomHandler(cb, options, elementCb);
        return new Parser_1.Parser(handler, options);
    }
    exports.createDomStream = createDomStream;

    Object.defineProperty(exports, "Tokenizer", { enumerable: true, get: function () { return __importDefault(Tokenizer_1).default; } });
    var ElementType = __importStar(require$$0$4);
    exports.ElementType = ElementType;
    /*
     * All of the following exports exist for backwards-compatibility.
     * They should probably be removed eventually.
     */
    __exportStar(FeedHandler_1, exports);
    exports.DomUtils = __importStar(require$$1);

    Object.defineProperty(exports, "RssHandler", { enumerable: true, get: function () { return FeedHandler_1.FeedHandler; } });
    });

    /**
     * Given a list of class and ID selectors (prefixed with '.' and '#'),
     * return them as separate lists of names without prefixes.
     *
     * @param { string[] } selectors Class and ID selectors (`[".class", "#id"]` etc).
     * @returns { { classes: string[], ids: string[] } }
     */
    function splitClassesAndIds$1 (selectors) {
      const classes = [];
      const ids = [];
      for (const selector of selectors) {
        if (selector.startsWith('.')) {
          classes.push(selector.substring(1));
        } else if (selector.startsWith('#')) {
          ids.push(selector.substring(1));
        }
      }
      return { classes: classes, ids: ids };
    }

    /**
     * Make a recursive function that will only run to a given depth
     * and switches to an alternative function at that depth. \
     * No limitation if `n` is `undefined` (Just wraps `f` in that case).
     *
     * @param   { number | undefined } n   Allowed depth of recursion. `undefined` for no limitation.
     * @param   { Function }           f   Function that accepts recursive callback as the first argument.
     * @param   { Function }           [g] Function to run instead, when maximum depth was reached. Do nothing by default.
     * @returns { Function }
     */
    function limitedDepthRecursive$1 (n, f, g = () => undefined) {
      if (n === undefined) {
        const f1 = function (...args) { return f(f1, ...args); };
        return f1;
      }
      if (n >= 0) {
        return function (...args) { return f(limitedDepthRecursive$1(n - 1, f, g), ...args); };
      }
      return g;
    }

    /**
     * Convert a number into alphabetic sequence representation (Sequence without zeroes).
     *
     * For example: `a, ..., z, aa, ..., zz, aaa, ...`.
     *
     * @param   { number } num              Number to convert. Must be >= 1.
     * @param   { string } [baseChar = 'a'] Character for 1 in the sequence.
     * @param   { number } [base = 26]      Number of characters in the sequence.
     * @returns { string }
     */
    function numberToLetterSequence$1 (num, baseChar = 'a', base = 26) {
      const digits = [];
      do {
        num -= 1;
        digits.push(num % base);
        num = (num / base) >> 0; // quick `floor`
      } while (num > 0);
      const baseCode = baseChar.charCodeAt(0);
      return digits
        .reverse()
        .map(n => String.fromCharCode(baseCode + n))
        .join('');
    }

    const I = ['I', 'X', 'C', 'M'];
    const V = ['V', 'L', 'D'];

    /**
     * Convert a number to it's Roman representation. No large numbers extension.
     *
     * @param   { number } num Number to convert. `0 < num <= 3999`.
     * @returns { string }
     */
    function numberToRoman$1 (num) {
      return [...(num) + '']
        .map(n => +n)
        .reverse()
        .map((v, i) => ((v % 5 < 4)
          ? (v < 5 ? '' : V[i]) + I[i].repeat(v % 5)
          : I[i] + (v < 5 ? V[i] : I[i + 1])))
        .reverse()
        .join('');
    }

    /**
     * Return the same string or a substring with the given character occurences removed from each end if any.
     *
     * @param   { string } str  A string to trim.
     * @param   { string } char A character to be trimmed.
     * @returns { string }
     */
    function trimCharacter$2 (str, char) {
      let start = 0;
      let end = str.length;
      while (start < end && str[start] === char) { ++start; }
      while (end > start && str[end - 1] === char) { --end; }
      return (start > 0 || end < str.length)
        ? str.substring(start, end)
        : str;
    }

    /**
     * Get a nested property from an object.
     *
     * @param   { object }   obj  The object to query for the value.
     * @param   { string[] } path The path to the property.
     * @returns { any }
     */
    function get$2 (obj, path) {
      for (const key of path) {
        if (!obj) { return undefined; }
        obj = obj[key];
      }
      return obj;
    }

    /**
     * Deduplicate an array by a given key callback.
     * Item properties are merged recursively and with the preference for last defined values.
     * Of items with the same key, merged item takes the place of the last item,
     * others are omitted.
     *
     * @param { any[] } items An array to deduplicate.
     * @param { (x: any) => string } getKey Callback to get a value that distinguishes unique items.
     * @returns { any[] }
     */
    function mergeDuplicatesPreferLast$1 (items, getKey) {
      const map = new Map();
      for (let i = items.length; i-- > 0;) {
        const item = items[i];
        const key = getKey(item);
        map.set(
          key,
          (map.has(key))
            ? cjs(item, map.get(key), { arrayMerge: overwriteMerge$1 })
            : item
        );
      }
      return [...map.values()].reverse();
    }

    const overwriteMerge$1 = (acc, src, options) => [...src];

    var helper = {
      get: get$2,
      limitedDepthRecursive: limitedDepthRecursive$1,
      mergeDuplicatesPreferLast: mergeDuplicatesPreferLast$1,
      numberToLetterSequence: numberToLetterSequence$1,
      numberToRoman: numberToRoman$1,
      splitClassesAndIds: splitClassesAndIds$1,
      trimCharacter: trimCharacter$2
    };

    // eslint-disable-next-line import/no-unassigned-import


    /**
     * Helps to build text from words.
     */
    class InlineTextBuilder$1 {
      /**
       * Creates an instance of InlineTextBuilder.
       *
       * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.
       *
       * @param { Options } options           HtmlToText options.
       * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.
       */
      constructor (options, maxLineLength = undefined) {
        /** @type { string[][] } */
        this.lines = [];
        /** @type { string[] }   */
        this.nextLineWords = [];
        this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
        this.nextLineAvailableChars = this.maxLineLength;
        this.wrapCharacters = options.longWordSplit.wrapCharacters || [];
        this.forceWrapOnLimit = options.longWordSplit.forceWrapOnLimit || false;

        this.stashedSpace = false;
        this.wordBreakOpportunity = false;
      }

      /**
       * Add a new word.
       *
       * @param { string } word A word to add.
       */
      pushWord (word) {
        if (this.nextLineAvailableChars <= 0) {
          this.startNewLine();
        }
        const isLineStart = this.nextLineWords.length === 0;
        const cost = word.length + (isLineStart ? 0 : 1);
        if (cost <= this.nextLineAvailableChars) { // Fits into available budget

          this.nextLineWords.push(word);
          this.nextLineAvailableChars -= cost;

        } else { // Does not fit - try to split the word

          // The word is moved to a new line - prefer to wrap between words.
          const [first, ...rest] = this.splitLongWord(word);
          if (!isLineStart) { this.startNewLine(); }
          this.nextLineWords.push(first);
          this.nextLineAvailableChars -= first.length;
          for (const part of rest) {
            this.startNewLine();
            this.nextLineWords.push(part);
            this.nextLineAvailableChars -= part.length;
          }

        }
      }

      /**
       * Pop a word from the currently built line.
       * This doesn't affect completed lines.
       *
       * @returns { string }
       */
      popWord () {
        const lastWord = this.nextLineWords.pop();
        if (lastWord !== undefined) {
          const isLineStart = this.nextLineWords.length === 0;
          const cost = lastWord.length + (isLineStart ? 0 : 1);
          this.nextLineAvailableChars += cost;
        }
        return lastWord;
      }

      /**
       * Concat a word to the last word already in the builder.
       * Adds a new word in case there are no words yet in the last line.
       *
       * @param { string } word A word to be concatenated.
       */
      concatWord (word) {
        if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
          this.pushWord(word);
          this.wordBreakOpportunity = false;
        } else {
          const lastWord = this.popWord();
          this.pushWord((lastWord) ? lastWord.concat(word) : word);
        }
      }

      /**
       * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.
       *
       * @param { number } n Number of line breaks that will be added to the resulting string.
       */
      startNewLine (n = 1) {
        this.lines.push(this.nextLineWords);
        if (n > 1) {
          this.lines.push(...Array.from({ length: n - 1 }, () => []));
        }
        this.nextLineWords = [];
        this.nextLineAvailableChars = this.maxLineLength;
      }

      /**
       * No words in this builder.
       *
       * @returns { boolean }
       */
      isEmpty () {
        return this.lines.length === 0
            && this.nextLineWords.length === 0;
      }

      clear () {
        this.lines.length = 0;
        this.nextLineWords.length = 0;
        this.nextLineAvailableChars = this.maxLineLength;
      }

      /**
       * Join all lines of words inside the InlineTextBuilder into a complete string.
       *
       * @returns { string }
       */
      toString () {
        return [...this.lines, this.nextLineWords]
          .map(words => words.join(' '))
          .join('\n');
      }

      /**
       * Split a long word up to fit within the word wrap limit.
       * Use either a character to split looking back from the word wrap limit,
       * or truncate to the word wrap limit.
       *
       * @param   { string }   word Input word.
       * @returns { string[] }      Parts of the word.
       */
      splitLongWord (word) {
        const parts = [];
        let idx = 0;
        while (word.length > this.maxLineLength) {

          const firstLine = word.substring(0, this.maxLineLength);
          const remainingChars = word.substring(this.maxLineLength);

          const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);

          if (splitIndex > -1) { // Found a character to split on

            word = firstLine.substring(splitIndex + 1) + remainingChars;
            parts.push(firstLine.substring(0, splitIndex + 1));

          } else { // Not found a character to split on

            idx++;
            if (idx < this.wrapCharacters.length) { // There is next character to try

              word = firstLine + remainingChars;

            } else { // No more characters to try

              if (this.forceWrapOnLimit) {
                parts.push(firstLine);
                word = remainingChars;
                if (word.length > this.maxLineLength) {
                  continue;
                }
              } else {
                word = firstLine + remainingChars;
              }
              break;

            }

          }

        }
        parts.push(word); // Add remaining part to array
        return parts;
      }
    }

    var inlineTextBuilder = { InlineTextBuilder: InlineTextBuilder$1 };

    /* eslint-disable max-classes-per-file */

    const { InlineTextBuilder } = inlineTextBuilder;


    class StackItem$1 {
      constructor (next = null) { this.next = next; }

      getRoot () { return (this.next) ? this.next : this; }
    }

    class BlockStackItem$1 extends StackItem$1 {
      constructor (options, next = null, leadingLineBreaks = 1, maxLineLength = undefined) {
        super(next);
        this.leadingLineBreaks = leadingLineBreaks;
        this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
        this.rawText = '';
        this.stashedLineBreaks = 0;
        this.isPre = next && next.isPre;
      }
    }

    class TableStackItem$1 extends StackItem$1 {
      constructor (next = null) {
        super(next);
        this.rows = [];
        this.isPre = next && next.isPre;
      }
    }

    class TableRowStackItem$1 extends StackItem$1 {
      constructor (next = null) {
        super(next);
        this.cells = [];
        this.isPre = next && next.isPre;
      }
    }

    class TableCellStackItem$1 extends StackItem$1 {
      constructor (options, next = null, maxColumnWidth = undefined) {
        super(next);
        this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
        this.rawText = '';
        this.stashedLineBreaks = 0;
        this.isPre = next && next.isPre;
      }
    }

    class TransformerStackItem$1 extends StackItem$1 {
      constructor (next = null, transform) {
        super(next);
        this.transform = transform;
      }
    }

    var stackItem = {
      BlockStackItem: BlockStackItem$1,
      StackItem: StackItem$1,
      TableCellStackItem: TableCellStackItem$1,
      TableRowStackItem: TableRowStackItem$1,
      TableStackItem: TableStackItem$1,
      TransformerStackItem: TransformerStackItem$1,
    };

    function getRow (matrix, j) {
      if (!matrix[j]) { matrix[j] = []; }
      return matrix[j];
    }

    function findFirstVacantIndex (row, x = 0) {
      while (row[x]) { x++; }
      return x;
    }

    function transposeInPlace (matrix, maxSize) {
      for (let i = 0; i < maxSize; i++) {
        const rowI = getRow(matrix, i);
        for (let j = 0; j < i; j++) {
          const rowJ = getRow(matrix, j);
          const temp = rowI[j];
          rowI[j] = rowJ[i];
          rowJ[i] = temp;
        }
      }
    }

    function putCellIntoLayout (cell, layout, baseRow, baseCol) {
      for (let r = 0; r < cell.rowspan; r++) {
        const layoutRow = getRow(layout, baseRow + r);
        for (let c = 0; c < cell.colspan; c++) {
          layoutRow[baseCol + c] = cell;
        }
      }
    }

    function updateOffset (offsets, base, span, value) {
      offsets[base + span] = Math.max(
        offsets[base + span] || 0,
        offsets[base] + value
      );
    }

    /**
     * @typedef { object } TablePrinterCell
     * Cell definition for the table printer.
     *
     * @property { number } colspan Number of columns this cell occupies.
     * @property { number } rowspan Number of rows this cell occupies.
     * @property { string } text Cell contents (pre-wrapped).
     */

    /**
     * Render a table into string.
     * Cells can contain multiline text and span across multiple rows and columns.
     *
     * Modifies cells to add lines array.
     *
     * @param { TablePrinterCell[][] } tableRows Table to render.
     * @param { number } rowSpacing Number of spaces between columns.
     * @param { number } colSpacing Number of empty lines between rows.
     * @returns { string }
     */
    function tableToString$1 (tableRows, rowSpacing, colSpacing) {
      const layout = [];
      let colNumber = 0;
      const rowNumber = tableRows.length;
      const rowOffsets = [0];
      // Fill the layout table and row offsets row-by-row.
      for (let j = 0; j < rowNumber; j++) {
        const layoutRow = getRow(layout, j);
        const cells = tableRows[j];
        let x = 0;
        for (let i = 0; i < cells.length; i++) {
          const cell = cells[i];
          x = findFirstVacantIndex(layoutRow, x);
          putCellIntoLayout(cell, layout, j, x);
          x += cell.colspan;
          cell.lines = cell.text.split('\n');
          const cellHeight = cell.lines.length;
          updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);
        }
        colNumber = (layoutRow.length > colNumber) ? layoutRow.length : colNumber;
      }

      transposeInPlace(layout, (rowNumber > colNumber) ? rowNumber : colNumber);

      const outputLines = [];
      const colOffsets = [0];
      // Fill column offsets and output lines column-by-column.
      for (let x = 0; x < colNumber; x++) {
        let y = 0;
        let cell;
        while (y < rowNumber && (cell = layout[x][y])) {
          if (!cell.rendered) {
            let cellWidth = 0;
            for (let j = 0; j < cell.lines.length; j++) {
              const line = cell.lines[j];
              const lineOffset = rowOffsets[y] + j;
              outputLines[lineOffset] = (outputLines[lineOffset] || '').padEnd(colOffsets[x]) + line;
              cellWidth = (line.length > cellWidth) ? line.length : cellWidth;
            }
            updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);
            cell.rendered = true;
          }
          y += cell.rowspan;
        }
      }

      return outputLines.join('\n');
    }

    var tablePrinter = { tableToString: tableToString$1 };

    // eslint-disable-next-line import/no-unassigned-import



    function charactersToCodes (str) {
      return [...str]
        .map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0'))
        .join('');
    }

    /**
     * Helps to handle HTML whitespaces.
     *
     * @class WhitespaceProcessor
     */
    class WhitespaceProcessor$1 {

      /**
       * Creates an instance of WhitespaceProcessor.
       *
       * @param { Options } options    HtmlToText options.
       * @memberof WhitespaceProcessor
       */
      constructor (options) {
        this.whitespaceChars = (options.preserveNewlines)
          ? options.whitespaceCharacters.replace(/\n/g, '')
          : options.whitespaceCharacters;
        const whitespaceCodes = charactersToCodes(this.whitespaceChars);
        this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
        this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);
        this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);
        this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, 'g');

        if (options.preserveNewlines) {

          const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, 'gm');

          /**
           * Shrink whitespaces and wrap text, add to the builder.
           *
           * @param { string }                  text              Input text.
           * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.
           * @param { (str: string) => string } [ transform ]     A transform to be applied to words.
           */
          this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str)) {
            if (!text) { return; }
            const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
            let anyMatch = false;
            let m = wordOrNewlineRe.exec(text);
            if (m) {
              anyMatch = true;
              if (m[0] === '\n') {
                inlineTextBuilder.startNewLine();
              } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
                inlineTextBuilder.pushWord(transform(m[0]));
              } else {
                inlineTextBuilder.concatWord(transform(m[0]));
              }
              while ((m = wordOrNewlineRe.exec(text)) !== null) {
                if (m[0] === '\n') {
                  inlineTextBuilder.startNewLine();
                } else {
                  inlineTextBuilder.pushWord(transform(m[0]));
                }
              }
            }
            inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || (this.testTrailingWhitespace(text));
            // No need to stash a space in case last added item was a new line,
            // but that won't affect anything later anyway.
          };

        } else {

          const wordRe = new RegExp(`[^${whitespaceCodes}]+`, 'g');

          this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str)) {
            if (!text) { return; }
            const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
            let anyMatch = false;
            let m = wordRe.exec(text);
            if (m) {
              anyMatch = true;
              if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
                inlineTextBuilder.pushWord(transform(m[0]));
              } else {
                inlineTextBuilder.concatWord(transform(m[0]));
              }
              while ((m = wordRe.exec(text)) !== null) {
                inlineTextBuilder.pushWord(transform(m[0]));
              }
            }
            inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || this.testTrailingWhitespace(text);
          };

        }
      }

      /**
       * Test whether the given text starts with HTML whitespace character.
       *
       * @param   { string }  text  The string to test.
       * @returns { boolean }
       */
      testLeadingWhitespace (text) {
        return this.leadingWhitespaceRe.test(text);
      }

      /**
       * Test whether the given text ends with HTML whitespace character.
       *
       * @param   { string }  text  The string to test.
       * @returns { boolean }
       */
      testTrailingWhitespace (text) {
        return this.trailingWhitespaceRe.test(text);
      }

      /**
       * Test whether the given text contains any non-whitespace characters.
       *
       * @param   { string }  text  The string to test.
       * @returns { boolean }
       */
      testContainsWords (text) {
        return !this.allWhitespaceOrEmptyRe.test(text);
      }

      /**
       * Return the number of newlines if there are no words.
       *
       * If any word is found then return zero regardless of the actual number of newlines.
       *
       * @param   { string }  text  Input string.
       * @returns { number }
       */
      countNewlinesNoWords (text) {
        this.newlineOrNonWhitespaceRe.lastIndex = 0;
        let counter = 0;
        let match;
        while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {
          if (match[0] === '\n') {
            counter++;
          } else {
            return 0;
          }
        }
        return counter;
      }

    }

    var whitespaceProcessor = { WhitespaceProcessor: WhitespaceProcessor$1 };

    const { trimCharacter: trimCharacter$1 } = helper;
    // eslint-disable-next-line no-unused-vars
    const { StackItem, BlockStackItem, TableCellStackItem, TableRowStackItem, TableStackItem, TransformerStackItem }
      = stackItem;
    const { tableToString } = tablePrinter;
    const { WhitespaceProcessor } = whitespaceProcessor;

    // eslint-disable-next-line import/no-unassigned-import



    /**
     * Helps to build text from inline and block elements.
     *
     * @class BlockTextBuilder
     */
    class BlockTextBuilder$1 {

      /**
       * Creates an instance of BlockTextBuilder.
       *
       * @param { Options } options HtmlToText options.
       * @param { Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.
       */
      constructor (options, picker) {
        this.options = options;
        this.picker = picker;
        this.whitespaceProcessor = new WhitespaceProcessor(options);
        /** @type { StackItem } */
        this._stackItem = new BlockStackItem(options);
        /** @type { TransformerStackItem } */
        this._wordTransformer = undefined;
      }

      /**
       * Put a word-by-word transform function onto the transformations stack.
       *
       * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.
       *
       * Word transformations applied before wrapping.
       *
       * @param { (str: string) => string } wordTransform Word transformation function.
       */
      pushWordTransform (wordTransform) {
        this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
      }

      /**
       * Remove a function from the word transformations stack.
       *
       * @returns { (str: string) => string } A function that was removed.
       */
      popWordTransform () {
        if (!this._wordTransformer) { return undefined; }
        const transform = this._wordTransformer.transform;
        this._wordTransformer = this._wordTransformer.next;
        return transform;
      }

      /** @returns { (str: string) => string } */
      _getCombinedWordTransformer () {
        const applyTransformer = (str, transformer) =>
          ((transformer) ? applyTransformer(transformer.transform(str), transformer.next) : str);
        return (str) => applyTransformer(str, this._wordTransformer);
      }

      _popStackItem () {
        const item = this._stackItem;
        this._stackItem = item.next;
        return item;
      }

      /**
       * Add a line break into currently built block.
       */
      addLineBreak () {
        if (!(
          this._stackItem instanceof BlockStackItem
          || this._stackItem instanceof TableCellStackItem
        )) { return; }
        if (this._stackItem.isPre) {
          this._stackItem.rawText += '\n';
        } else {
          this._stackItem.inlineTextBuilder.startNewLine();
        }
      }

      /**
       * Allow to break line in case directly following text will not fit.
       */
      addWordBreakOpportunity () {
        if (
          this._stackItem instanceof BlockStackItem
          || this._stackItem instanceof TableCellStackItem
        ) {
          this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
        }
      }

      /**
       * Add a node inline into the currently built block.
       *
       * @param { string } str
       * Text content of a node to add.
       *
       * @param { object | boolean } [ optionsObjectOrNoWordTransform ]
       * Object holding the parameters of the operation.
       *
       * Boolean value is deprecated.
       *
       * @param { boolean } [ optionsObjectOrNoWordTransform.noWordTransform = false ]
       * Ignore word transformers if there are any.
       */
      addInline (str, optionsObjectOrNoWordTransform = {}) {
        if (typeof optionsObjectOrNoWordTransform === 'object') {
          this._addInline(str, optionsObjectOrNoWordTransform);
        } else {
          this._addInline(str, { noWordTransform: optionsObjectOrNoWordTransform });
        }
      }

      _addInline (str, { noWordTransform = false } = {}) {
        if (!(
          this._stackItem instanceof BlockStackItem
          || this._stackItem instanceof TableCellStackItem
        )) { return; }

        if (this._stackItem.isPre) {
          this._stackItem.rawText += str;
          return;
        }

        if (
          str.length === 0 || // empty string
          (
            this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant
            !this.whitespaceProcessor.testContainsWords(str) // no words to add
          )
        ) { return; }

        if (this.options.preserveNewlines) {
          const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
          if (newlinesNumber > 0) {
            this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
            // keep stashedLineBreaks unchanged
            return;
          }
        }

        if (this._stackItem.stashedLineBreaks) {
          this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
        }
        this.whitespaceProcessor.shrinkWrapAdd(
          str,
          this._stackItem.inlineTextBuilder,
          (this._wordTransformer && !noWordTransform) ? this._getCombinedWordTransformer() : undefined
        );
        this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks
      }

      /**
       * Start building a new block.
       *
       * @param { object | number } [optionsObjectOrLeadingLineBreaks]
       * Object holding the parameters of the block.
       *
       * Number value is deprecated.
       *
       * @param { number }  [optionsObjectOrLeadingLineBreaks.leadingLineBreaks = 1]
       * This block should have at least this number of line breaks to separate if from any preceding block.
       *
       * @param { number }  [optionsObjectOrLeadingLineBreaks.reservedLineLength = 0]
       * Reserve this number of characters on each line for block markup.
       *
       * @param { boolean } [optionsObjectOrLeadingLineBreaks.isPre = false]
       * Should HTML whitespace be preserved inside this block.
       *
       * @param { number }  [reservedLineLength]
       * Deprecated.
       *
       * @param { boolean } [isPre]
       * Deprecated.
       */
      openBlock (optionsObjectOrLeadingLineBreaks = {}, reservedLineLength = undefined, isPre = undefined) {
        if (typeof optionsObjectOrLeadingLineBreaks === 'object') {
          this._openBlock(optionsObjectOrLeadingLineBreaks);
        } else {
          this._openBlock({
            isPre: isPre,
            leadingLineBreaks: optionsObjectOrLeadingLineBreaks,
            reservedLineLength: reservedLineLength,
          });
        }
      }

      _openBlock ({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
        const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
        this._stackItem = new BlockStackItem(
          this.options,
          this._stackItem,
          leadingLineBreaks,
          maxLineLength
        );
        if (isPre) { this._stackItem.isPre = true; }
      }

      /**
       * Finalize currently built block, add it's content to the parent block.
       *
       * @param { object | number }         [optionsObjectOrTrailingLineBreaks]
       * Object holding the parameters of the block.
       *
       * Number value is deprecated.
       *
       * @param { number }                  [optionsObjectOrTrailingLineBreaks.trailingLineBreaks = 1]
       * This block should have at least this number of line breaks to separate it from any following block.
       *
       * @param { (str: string) => string } [optionsObjectOrTrailingLineBreaks.blockTransform = undefined]
       * A function to transform the block text before adding to the parent block.
       * This happens after word wrap and should be used in combination with reserved line length
       * in order to keep line lengths correct.
       * Used for whole block markup.
       *
       * @param { (str: string) => string } [blockTransform]
       * Deprecated.
       */
      closeBlock (optionsObjectOrTrailingLineBreaks = {}, blockTransform = undefined) {
        if (typeof optionsObjectOrTrailingLineBreaks === 'object') {
          this._closeBlock(optionsObjectOrTrailingLineBreaks);
        } else {
          this._closeBlock({
            trailingLineBreaks: optionsObjectOrTrailingLineBreaks,
            blockTransform: blockTransform,
          });
        }
      }

      _closeBlock ({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {
        const block = this._popStackItem();
        const blockText = (blockTransform) ? blockTransform(getText(block)) : getText(block);
        addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
      }

      /**
       * Start building a table.
       */
      openTable () {
        this._stackItem = new TableStackItem(this._stackItem);
      }

      /**
       * Start building a table row.
       */
      openTableRow () {
        if (!(this._stackItem instanceof TableStackItem)) {
          throw new Error('Can\'t add table row to something that is not a table! Check the formatter.');
        }
        this._stackItem = new TableRowStackItem(this._stackItem);
      }

      /**
       * Start building a table cell.
       *
       * @param { object | number } [optionsObjectOrMaxColumnWidth = undefined]
       * Object holding the parameters of the cell.
       *
       * Number value is deprecated.
       *
       * @param { number } [optionsObjectOrMaxColumnWidth.maxColumnWidth = undefined]
       * Wrap cell content to this width. Fall back to global wordwrap value if undefined.
       */
      openTableCell (optionsObjectOrMaxColumnWidth = {}) {
        if (typeof optionsObjectOrMaxColumnWidth === 'object') {
          this._openTableCell(optionsObjectOrMaxColumnWidth);
        } else {
          this._openTableCell({ maxColumnWidth: optionsObjectOrMaxColumnWidth });
        }
      }

      _openTableCell ({ maxColumnWidth = undefined } = {}) {
        if (!(this._stackItem instanceof TableRowStackItem)) {
          throw new Error('Can\'t add table cell to something that is not a table row! Check the formatter.');
        }
        this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
      }

      /**
       * Finalize currently built table cell and add it to parent table row's cells.
       *
       * @param { object | number } [optionsObjectOrColspan]
       * Object holding the parameters of the cell.
       *
       * Number value is deprecated.
       *
       * @param { number } [optionsObjectOrColspan.colspan = 1] How many columns this cell should occupy.
       * @param { number } [optionsObjectOrColspan.rowspan = 1] How many rows this cell should occupy.
       *
       * @param { number } [rowspan] Deprecated.
       */
      closeTableCell (optionsObjectOrColspan = {}, rowspan = undefined) {
        if (typeof optionsObjectOrColspan === 'object') {
          this._closeTableCell(optionsObjectOrColspan);
        } else {
          this._closeTableCell({
            colspan: optionsObjectOrColspan,
            rowspan: rowspan,
          });
        }
      }

      _closeTableCell ({ colspan = 1, rowspan = 1 } = {}) {
        const cell = this._popStackItem();
        const text = trimCharacter$1(getText(cell), '\n');
        cell.next.cells.push({ colspan: colspan, rowspan: rowspan, text: text });
      }

      /**
       * Finalize currently built table row and add it to parent table's rows.
       */
      closeTableRow () {
        const row = this._popStackItem();
        row.next.rows.push(row.cells);
      }

      /**
       * Finalize currently built table and add the rendered text to the parent block.
       *
       * @param { object | number } [optionsObjectOrColSpacing]
       * Object holding the parameters of the table.
       *
       * Number value is deprecated.
       *
       * @param { number } [optionsObjectOrColSpacing.colSpacing = 3]
       * Number of spaces between table columns.
       *
       * @param { number } [optionsObjectOrColSpacing.rowSpacing = 0]
       * Number of empty lines between table rows.
       *
       * @param { number } [optionsObjectOrColSpacing.leadingLineBreaks = 2]
       * This table should have at least this number of line breaks to separate if from any preceding block.
       *
       * @param { number } [optionsObjectOrColSpacing.trailingLineBreaks = 2]
       * This table should have at least this number of line breaks to separate it from any following block.
       *
       * @param { number } [rowSpacing]
       * Deprecated.
       *
       * @param { number } [leadingLineBreaks]
       * Deprecated.
       *
       * @param { number } [trailingLineBreaks]
       * Deprecated.
       */
      closeTable (
        optionsObjectOrColSpacing = {},
        rowSpacing = undefined,
        leadingLineBreaks = undefined,
        trailingLineBreaks = undefined
      ) {
        if (typeof optionsObjectOrColSpacing === 'object') {
          this._closeTable(optionsObjectOrColSpacing);
        } else {
          this._closeTable({
            colSpacing: optionsObjectOrColSpacing,
            leadingLineBreaks: leadingLineBreaks,
            rowSpacing: rowSpacing,
            trailingLineBreaks: trailingLineBreaks
          });
        }
      }

      _closeTable ({ colSpacing = 3, rowSpacing = 0, leadingLineBreaks = 2, trailingLineBreaks = 2 } = {}) {
        const table = this._popStackItem();
        const output = tableToString(table.rows, rowSpacing, colSpacing);
        if (output) {
          addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
        }
      }

      /**
       * Return the rendered text content of this builder.
       *
       * @returns { string }
       */
      toString () {
        return getText(this._stackItem.getRoot());
        // There should only be the root item if everything is closed properly.
      }

    }

    function getText (stackItem) {
      if (!(
        stackItem instanceof BlockStackItem
        || stackItem instanceof TableCellStackItem
      )) {
        throw new Error('Only blocks and table cells can be requested for text contents.');
      }
      return (stackItem.inlineTextBuilder.isEmpty())
        ? stackItem.rawText
        : stackItem.rawText + stackItem.inlineTextBuilder.toString();
    }

    function addText (stackItem, text, leadingLineBreaks, trailingLineBreaks) {
      if (!(
        stackItem instanceof BlockStackItem
        || stackItem instanceof TableCellStackItem
      )) {
        throw new Error('Only blocks and table cells can contain text.');
      }
      const parentText = getText(stackItem);
      const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
      stackItem.inlineTextBuilder.clear();
      if (parentText) {
        stackItem.rawText = parentText + '\n'.repeat(lineBreaks) + text;
      } else {
        stackItem.rawText = text;
        stackItem.leadingLineBreaks = lineBreaks;
      }
      stackItem.stashedLineBreaks = trailingLineBreaks;
    }

    var blockTextBuilder = { BlockTextBuilder: BlockTextBuilder$1 };

    const { get: get$1, numberToLetterSequence, numberToRoman, splitClassesAndIds, trimCharacter } = helper;

    // eslint-disable-next-line import/no-unassigned-import



    /**
     * Dummy formatter that discards the input and does nothing.
     *
     * @type { FormatCallback }
     */
    function formatSkip (elem, walk, builder, formatOptions) {
      /* do nothing */
    }

    /**
     * Process an inline-level element.
     *
     * @type { FormatCallback }
     */
    function formatInline (elem, walk, builder, formatOptions) {
      walk(elem.children, builder);
    }

    /**
     * Process a block-level container.
     *
     * @type { FormatCallback }
     */
    function formatBlock (elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
      walk(elem.children, builder);
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
    }

    /**
     * Process a line-break.
     *
     * @type { FormatCallback }
     */
    function formatLineBreak (elem, walk, builder, formatOptions) {
      builder.addLineBreak();
    }

    /**
     * Process a `wbk` tag (word break opportunity).
     *
     * @type { FormatCallback }
     */
    function formatWbr (elem, walk, builder, formatOptions) {
      builder.addWordBreakOpportunity();
    }

    /**
     * Process a horizontal line.
     *
     * @type { FormatCallback }
     */
    function formatHorizontalLine (elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
      builder.addInline('-'.repeat(formatOptions.length || builder.options.wordwrap || 40));
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }

    /**
     * Process a paragraph.
     *
     * @type { FormatCallback }
     */
    function formatParagraph (elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
      walk(elem.children, builder);
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }

    /**
     * Process a preformatted content.
     *
     * @type { FormatCallback }
     */
    function formatPre (elem, walk, builder, formatOptions) {
      builder.openBlock({
        isPre: true,
        leadingLineBreaks: formatOptions.leadingLineBreaks || 2
      });
      walk(elem.children, builder);
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }

    /**
     * Process a heading.
     *
     * @type { FormatCallback }
     */
    function formatHeading (elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
      if (formatOptions.uppercase !== false) {
        builder.pushWordTransform(str => str.toUpperCase());
        walk(elem.children, builder);
        builder.popWordTransform();
      } else {
        walk(elem.children, builder);
      }
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }

    /**
     * Process a blockquote.
     *
     * @type { FormatCallback }
     */
    function formatBlockquote (elem, walk, builder, formatOptions) {
      builder.openBlock({
        leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
        reservedLineLength: 2
      });
      walk(elem.children, builder);
      builder.closeBlock({
        trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
        blockTransform: str => ((formatOptions.trimEmptyLines !== false) ? trimCharacter(str, '\n') : str)
          .split('\n')
          .map(line => '> ' + line)
          .join('\n')
      });
    }

    function withBrackets (str, brackets) {
      if (!brackets) { return str; }

      const lbr = (typeof brackets[0] === 'string')
        ? brackets[0]
        : '[';
      const rbr = (typeof brackets[1] === 'string')
        ? brackets[1]
        : ']';
      return lbr + str + rbr;
    }

    /**
     * Process an image.
     *
     * @type { FormatCallback }
     */
    function formatImage (elem, walk, builder, formatOptions) {
      const attribs = elem.attribs || {};
      const alt = (attribs.alt)
        ? he.decode(attribs.alt, builder.options.decodeOptions)
        : '';
      const src = (!attribs.src)
        ? ''
        : (formatOptions.baseUrl && attribs.src.indexOf('/') === 0)
          ? formatOptions.baseUrl + attribs.src
          : attribs.src;
      const text = (!src)
        ? alt
        : (!alt)
          ? withBrackets(src, formatOptions.linkBrackets)
          : alt + ' ' + withBrackets(src, formatOptions.linkBrackets);

      builder.addInline(text);
    }

    /**
     * Process an anchor.
     *
     * @type { FormatCallback }
     */
    function formatAnchor (elem, walk, builder, formatOptions) {
      function getHref () {
        if (formatOptions.ignoreHref) { return ''; }
        if (!elem.attribs || !elem.attribs.href) { return ''; }
        let href = elem.attribs.href.replace(/^mailto:/, '');
        if (formatOptions.noAnchorUrl && href[0] === '#') { return ''; }
        href = (formatOptions.baseUrl && href[0] === '/')
          ? formatOptions.baseUrl + href
          : href;
        return he.decode(href, builder.options.decodeOptions);
      }
      const href = getHref();
      if (!href) {
        walk(elem.children, builder);
      } else {
        let text = '';
        builder.pushWordTransform(
          str => {
            if (str) { text += str; }
            return str;
          }
        );
        walk(elem.children, builder);
        builder.popWordTransform();

        const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;
        if (!hideSameLink) {
          builder.addInline(
            (!text)
              ? href
              : ' ' + withBrackets(href, formatOptions.linkBrackets),
            { noWordTransform: true }
          );
        }
      }
    }

    /**
     * @param { DomNode }           elem               List items with their prefixes.
     * @param { RecursiveCallback } walk               Recursive callback to process child nodes.
     * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.
     * @param { FormatOptions }     formatOptions      Options specific to a formatter.
     * @param { () => string }      nextPrefixCallback Function that returns increasing index each time it is called.
     */
    function formatList (elem, walk, builder, formatOptions, nextPrefixCallback) {
      const isNestedList = get$1(elem, ['parent', 'name']) === 'li';

      // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,
      // so the dumb length comparison is the most robust way to get the correct value.
      let maxPrefixLength = 0;
      const listItems = (elem.children || [])
        // it might be more accurate to check only for html spaces here, but no significant benefit
        .filter(child => child.type !== 'text' || !/^\s*$/.test(child.data))
        .map(function (child) {
          if (child.name !== 'li') {
            return { node: child, prefix: '' };
          }
          const prefix = (isNestedList)
            ? nextPrefixCallback().trimStart()
            : nextPrefixCallback();
          if (prefix.length > maxPrefixLength) { maxPrefixLength = prefix.length; }
          return { node: child, prefix: prefix };
        });
      if (!listItems.length) { return; }

      const reservedLineLength = maxPrefixLength;
      const spacing = '\n' + ' '.repeat(reservedLineLength);
      builder.openBlock({ leadingLineBreaks: isNestedList ? 1 : (formatOptions.leadingLineBreaks || 2) });
      for (const { node, prefix } of listItems) {
        builder.openBlock({
          leadingLineBreaks: 1,
          reservedLineLength: reservedLineLength
        });
        walk([node], builder);
        builder.closeBlock({
          trailingLineBreaks: 1,
          blockTransform: str => prefix + ' '.repeat(reservedLineLength - prefix.length) + str.replace(/\n/g, spacing)
        });
      }
      builder.closeBlock({ trailingLineBreaks: isNestedList ? 1 : (formatOptions.trailingLineBreaks || 2) });
    }

    /**
     * Process an unordered list.
     *
     * @type { FormatCallback }
     */
    function formatUnorderedList (elem, walk, builder, formatOptions) {
      const prefix = formatOptions.itemPrefix || ' * ';
      return formatList(elem, walk, builder, formatOptions, () => prefix);
    }

    /**
     * Process an ordered list.
     *
     * @type { FormatCallback }
     */
    function formatOrderedList (elem, walk, builder, formatOptions) {
      let nextIndex = Number(elem.attribs.start || '1');
      const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
      const nextPrefixCallback = () => ' ' + indexFunction(nextIndex++) + '. ';
      return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
    }

    /**
     * Return a function that can be used to generate index markers of a specified format.
     *
     * @param   { string } [olType='1'] Marker type.
     * @returns { (i: number) => string }
     */
    function getOrderedListIndexFunction (olType = '1') {
      switch (olType) {
        case 'a': return (i) => numberToLetterSequence(i, 'a');
        case 'A': return (i) => numberToLetterSequence(i, 'A');
        case 'i': return (i) => numberToRoman(i).toLowerCase();
        case 'I': return (i) => numberToRoman(i);
        case '1':
        default: return (i) => (i).toString();
      }
    }

    function isDataTable (attr, tables) {
      if (tables === true) { return true; }
      if (!attr) { return false; }

      const { classes, ids } = splitClassesAndIds(tables);
      const attrClasses = (attr['class'] || '').split(' ');
      const attrIds = (attr['id'] || '').split(' ');

      return attrClasses.some(x => classes.includes(x)) || attrIds.some(x => ids.includes(x));
    }

    /**
     * Process a table (either as a container or as a data table, depending on options).
     *
     * @type { FormatCallback }
     */
    function formatTable (elem, walk, builder, formatOptions) {
      return isDataTable(elem.attribs, builder.options.tables)
        ? formatDataTable(elem, walk, builder, formatOptions)
        : formatBlock(elem, walk, builder, formatOptions);
    }

    /**
     * Process a data table.
     *
     * @type { FormatCallback }
     */
    function formatDataTable (elem, walk, builder, formatOptions) {
      builder.openTable();
      elem.children.forEach(walkTable);
      builder.closeTable({
        colSpacing: formatOptions.colSpacing,
        leadingLineBreaks: formatOptions.leadingLineBreaks,
        rowSpacing: formatOptions.rowSpacing,
        trailingLineBreaks: formatOptions.trailingLineBreaks
      });

      function formatCell (cellNode) {
        const colspan = +get$1(cellNode, ['attribs', 'colspan']) || 1;
        const rowspan = +get$1(cellNode, ['attribs', 'rowspan']) || 1;
        builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
        walk(cellNode.children, builder);
        builder.closeTableCell({ colspan: colspan, rowspan: rowspan });
      }

      function walkTable (elem) {
        if (elem.type !== 'tag') { return; }

        const formatHeaderCell = (formatOptions.uppercaseHeaderCells !== false)
          ? (cellNode) => {
            builder.pushWordTransform(str => str.toUpperCase());
            formatCell(cellNode);
            builder.popWordTransform();
          }
          : formatCell;

        switch (elem.name) {
          case 'thead':
          case 'tbody':
          case 'tfoot':
          case 'center':
            elem.children.forEach(walkTable);
            return;

          case 'tr': {
            builder.openTableRow();
            for (const childOfTr of elem.children) {
              if (childOfTr.type !== 'tag') { continue; }
              switch (childOfTr.name) {
                case 'th': {
                  formatHeaderCell(childOfTr);
                  break;
                }
                case 'td': {
                  formatCell(childOfTr);
                  break;
                }
                  // do nothing
              }
            }
            builder.closeTableRow();
            break;
          }
            // do nothing
        }
      }
    }

    var formatter = {
      anchor: formatAnchor,
      block: formatBlock,
      blockquote: formatBlockquote,
      dataTable: formatDataTable,
      heading: formatHeading,
      horizontalLine: formatHorizontalLine,
      image: formatImage,
      inline: formatInline,
      lineBreak: formatLineBreak,
      orderedList: formatOrderedList,
      paragraph: formatParagraph,
      pre: formatPre,
      skip: formatSkip,
      table: formatTable,
      unorderedList: formatUnorderedList,
      wbr: formatWbr
    };

    var htmlparser = lib;

    const { hp2Builder } = hp2Builder_1;





    const { BlockTextBuilder } = blockTextBuilder;

    const { limitedDepthRecursive, mergeDuplicatesPreferLast, get } = helper;

    // eslint-disable-next-line import/no-unassigned-import



    /**
     * Default options.
     *
     * @constant
     * @type { Options }
     * @default
     * @private
     */
    const DEFAULT_OPTIONS = {
      baseElements: {
        selectors: [ 'body' ],
        orderBy: 'selectors', // 'selectors' | 'occurrence'
        returnDomByDefault: true
      },
      decodeOptions: {
        isAttributeValue: false,
        strict: false
      },
      formatters: {},
      limits: {
        ellipsis: '...',
        maxBaseElements: undefined,
        maxChildNodes: undefined,
        maxDepth: undefined,
        maxInputLength: (1 << 24) // 16_777_216
      },
      longWordSplit: {
        forceWrapOnLimit: false,
        wrapCharacters: []
      },
      preserveNewlines: false,
      selectors: [
        { selector: '*', format: 'inline' },
        {
          selector: 'a',
          format: 'anchor',
          options: {
            baseUrl: null,
            hideLinkHrefIfSameAsText: false,
            ignoreHref: false,
            linkBrackets: ['[', ']'],
            noAnchorUrl: true
          }
        },
        { selector: 'article', format: 'block' },
        { selector: 'aside', format: 'block' },
        {
          selector: 'blockquote',
          format: 'blockquote',
          options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
        },
        { selector: 'br', format: 'lineBreak' },
        { selector: 'div', format: 'block' },
        { selector: 'footer', format: 'block' },
        { selector: 'form', format: 'block' },
        { selector: 'h1', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
        { selector: 'h2', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
        { selector: 'h3', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
        { selector: 'h4', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
        { selector: 'h5', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
        { selector: 'h6', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
        { selector: 'header', format: 'block' },
        {
          selector: 'hr',
          format: 'horizontalLine',
          options: { leadingLineBreaks: 2, length: undefined, trailingLineBreaks: 2 }
        },
        {
          selector: 'img',
          format: 'image',
          options: { baseUrl: null, linkBrackets: ['[', ']'] }
        },
        { selector: 'main', format: 'block' },
        { selector: 'nav', format: 'block' },
        {
          selector: 'ol',
          format: 'orderedList',
          options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
        },
        { selector: 'p', format: 'paragraph', options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
        { selector: 'pre', format: 'pre', options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
        { selector: 'section', format: 'block' },
        {
          selector: 'table',
          format: 'table',
          options: {
            colSpacing: 3,
            leadingLineBreaks: 2,
            maxColumnWidth: 60,
            rowSpacing: 0,
            trailingLineBreaks: 2,
            uppercaseHeaderCells: true
          }
        },
        {
          selector: 'ul',
          format: 'unorderedList',
          options: { itemPrefix: ' * ', leadingLineBreaks: 2, trailingLineBreaks: 2 }
        },
        { selector: 'wbr', format: 'wbr' },
      ],
      tables: [], // deprecated
      whitespaceCharacters: ' \t\r\n\f\u200b',
      wordwrap: 80
    };

    const concatMerge = (acc, src, options) => [...acc, ...src];
    const overwriteMerge = (acc, src, options) => [...src];
    const selectorsMerge = (acc, src, options) => (
      (acc.some(s => typeof s === 'object'))
        ? concatMerge(acc, src) // selectors
        : overwriteMerge(acc, src) // baseElements.selectors
    );

    /**
     * Preprocess options, compile selectors into a decision tree,
     * return a function intended for batch processing.
     *
     * @param   { Options } [options = {}]   HtmlToText options.
     * @returns { (html: string) => string } Pre-configured converter function.
     * @static
     */
    function compile (options = {}) {
      options = cjs(
        DEFAULT_OPTIONS,
        options,
        {
          arrayMerge: overwriteMerge,
          customMerge: (key) => ((key === 'selectors') ? selectorsMerge : undefined)
        }
      );
      options.formatters = Object.assign({}, formatter, options.formatters);

      handleDeprecatedOptions(options);

      const uniqueSelectors = mergeDuplicatesPreferLast(options.selectors, (s => s.selector));
      const selectorsWithoutFormat = uniqueSelectors.filter(s => !s.format);
      if (selectorsWithoutFormat.length) {
        throw new Error(
          'Following selectors have no specified format: ' +
          selectorsWithoutFormat.map(s => `\`${s.selector}\``).join(', ')
        );
      }
      const picker = new selderee.DecisionTree(
        uniqueSelectors.map(s => [s.selector, s])
      ).build(hp2Builder);

      const baseSelectorsPicker = new selderee.DecisionTree(
        options.baseElements.selectors.map((s, i) => [s, i + 1])
      ).build(hp2Builder);
      function findBaseElements (dom) {
        return findBases(dom, options, baseSelectorsPicker);
      }

      const limitedWalk = limitedDepthRecursive(
        options.limits.maxDepth,
        recursiveWalk,
        function (dom, builder) {
          builder.addInline(options.limits.ellipsis || '');
        }
      );

      return function (html) {
        return process(html, options, picker, findBaseElements, limitedWalk);
      };
    }

    /**
     * Convert given HTML according to preprocessed options.
     *
     * @param { string } html HTML content to convert.
     * @param { Options } options HtmlToText options (preprocessed).
     * @param { Picker<DomNode, TagDefinition> } picker
     * Tag definition picker for DOM nodes processing.
     * @param { (dom: DomNode[]) => DomNode[] } findBaseElements
     * Function to extract elements from HTML DOM
     * that will only be present in the output text.
     * @param { RecursiveCallback } walk Recursive callback.
     * @returns { string }
     */
    function process (html, options, picker, findBaseElements, walk) {
      const maxInputLength = options.limits.maxInputLength;
      if (maxInputLength && html && html.length > maxInputLength) {
        console.warn(
          `Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`
        );
        html = html.substring(0, maxInputLength);
      }

      const handler = new htmlparser.DomHandler();
      new htmlparser.Parser(handler, { decodeEntities: false }).parseComplete(html);

      const bases = findBaseElements(handler.dom);
      const builder = new BlockTextBuilder(options, picker);
      walk(bases, builder);
      return builder.toString();
    }

    /**
     * Convert given HTML content to plain text string.
     *
     * @param   { string }  html           HTML content to convert.
     * @param   { Options } [options = {}] HtmlToText options.
     * @returns { string }                 Plain text string.
     * @static
     *
     * @example
     * const { convert } = require('html-to-text');
     * const text = convert('<h1>Hello World</h1>', {
     *   wordwrap: 130
     * });
     * console.log(text); // HELLO WORLD
     */
    function convert (html, options = {}) {
      return compile(options)(html);
    }

    /**
     * Map previously existing and now deprecated options to the new options layout.
     * This is a subject for cleanup in major releases.
     *
     * @param { Options } options HtmlToText options.
     */
    function handleDeprecatedOptions (options) {
      const selectorDefinitions = options.selectors;

      if (options.tags) {
        const tagDefinitions = Object.entries(options.tags).map(
          ([selector, definition]) => ({ ...definition, selector: selector || '*' })
        );
        selectorDefinitions.push(...tagDefinitions);
      }

      function set (obj, path, value) {
        const valueKey = path.pop();
        for (const key of path) {
          let nested = obj[key];
          if (!nested) {
            nested = {};
            obj[key] = nested;
          }
          obj = nested;
        }
        obj[valueKey] = value;
      }

      function copyFormatterOption (source, format, target) {
        if (options[source] === undefined) { return; }
        for (const definition of selectorDefinitions) {
          if (definition.format === format) {
            set(definition, ['options', target], options[source]);
          }
        }
      }

      copyFormatterOption('hideLinkHrefIfSameAsText', 'anchor', 'hideLinkHrefIfSameAsText');
      copyFormatterOption('ignoreHref', 'anchor', 'ignoreHref');
      copyFormatterOption('linkHrefBaseUrl', 'anchor', 'baseUrl');
      copyFormatterOption('noAnchorUrl', 'anchor', 'noAnchorUrl');
      copyFormatterOption('noLinkBrackets', 'anchor', 'noLinkBrackets');

      copyFormatterOption('linkHrefBaseUrl', 'image', 'baseUrl');

      copyFormatterOption('unorderedListItemPrefix', 'unorderedList', 'itemPrefix');

      copyFormatterOption('uppercaseHeadings', 'heading', 'uppercase');
      copyFormatterOption('uppercaseHeadings', 'table', 'uppercaseHeadings');
      copyFormatterOption('uppercaseHeadings', 'dataTable', 'uppercaseHeadings');

      if (options['ignoreImage']) {
        for (const definition of selectorDefinitions) {
          if (definition.format === 'image') {
            definition.format = 'skip';
          }
        }
      }

      if (options['singleNewLineParagraphs']) {
        for (const definition of selectorDefinitions) {
          if (definition.format === 'paragraph' || definition.format === 'pre') {
            set(definition, ['options', 'leadingLineBreaks'], 1);
            set(definition, ['options', 'trailingLineBreaks'], 1);
          }
        }
      }

      if (options['baseElement']) {
        const baseElement = options['baseElement'];
        set(
          options,
          ['baseElements', 'selectors'],
          (Array.isArray(baseElement) ? baseElement : [baseElement])
        );
      }
      if (options['returnDomByDefault'] !== undefined) {
        set(options, ['baseElements', 'returnDomByDefault'], options['returnDomByDefault']);
      }

      for (const definition of selectorDefinitions) {
        if (definition.format === 'anchor' && get(definition, ['options', 'noLinkBrackets'])) {
          set(definition, ['options', 'linkBrackets'], false);
        }
      }
    }

    function findBases (dom, options, baseSelectorsPicker) {
      const results = [];

      function recursiveWalk (walk, /** @type { DomNode[] } */ dom) {
        dom = dom.slice(0, options.limits.maxChildNodes);
        for (const elem of dom) {
          if (elem.type !== 'tag') {
            continue;
          }
          const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
          if (pickedSelectorIndex > 0) {
            results.push({ selectorIndex: pickedSelectorIndex, element: elem });
          } else if (elem.children) {
            walk(elem.children);
          }
          if (results.length >= options.limits.maxBaseElements) {
            return;
          }
        }
      }

      const limitedWalk = limitedDepthRecursive(
        options.limits.maxDepth,
        recursiveWalk
      );
      limitedWalk(dom);

      if (options.baseElements.orderBy !== 'occurrence') { // 'selectors'
        results.sort((a, b) => a.selectorIndex - b.selectorIndex);
      }
      return (options.baseElements.returnDomByDefault && results.length === 0)
        ? dom
        : results.map(x => x.element);
    }

    /**
     * Function to walk through DOM nodes and accumulate their string representations.
     *
     * @param   { RecursiveCallback } walk    Recursive callback.
     * @param   { DomNode[] }         [dom]   Nodes array to process.
     * @param   { BlockTextBuilder }  builder Passed around to accumulate output text.
     * @private
     */
    function recursiveWalk (walk, dom, builder) {
      if (!dom) { return; }

      const options = builder.options;

      const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
      if (tooManyChildNodes) {
        dom = dom.slice(0, options.limits.maxChildNodes);
        dom.push({
          data: options.limits.ellipsis,
          type: 'text'
        });
      }

      for (const elem of dom) {
        switch (elem.type) {
          case 'text': {
            builder.addInline(he.decode(elem.data, options.decodeOptions));
            break;
          }
          case 'tag': {
            const tagDefinition = builder.picker.pick1(elem);
            const format = options.formatters[tagDefinition.format];
            format(elem, walk, builder, tagDefinition.options || {});
            break;
          }
        }
      }

      return;
    }

    /**
     * @deprecated Use `{ convert }` function instead!
     * @see convert
     *
     * @param   { string }  html           HTML content to convert.
     * @param   { Options } [options = {}] HtmlToText options.
     * @returns { string }                 Plain text string.
     * @static
     */
    const fromString = (html, options = {}) => convert(html, options);

    var htmlToText$1 = {
      compile: compile,
      convert: convert,
      fromString: fromString,
      htmlToText: convert
    };

    var htmlToText = htmlToText$1;

    // >TYPE tank
    //
    // >DATA
    // introduced: March 3 1973
    // produced: 1387
    // <DATA
    //
    // >INFO tankbox
    // image: CPB:images/tank_header
    // <INFO
    //
    // >SRC Browning
    // ...
    // <SRC
    //
    // <>The tank is really strong and powerful.<Browning 55-56>
    //
    // Amalachae becomes the arisen Fisher Queen. <>Beginning with the fall of the east,
    // Amalachae and Infinit's spheres of influence, and ideologies, begin to
    // conflict.<ref canonitetl 127478>
    //

    const extensions = [];

    const add =conf=> {
      return extensions.push({
        name: conf.name,
        level: conf.level,
        start(src) { return src.match(conf.hint)?.index; },
        tokenizer(src, tokens) {
          const match = conf.rule.exec(src);
          if (match) {
            const token = Object.assign({}, match.groups, {
              type: conf.name,
              raw: match[0],
              tokens: []
            });
            if (conf.parse) {
              const k = typeof(conf.parse) == 'string' ? conf.parse : 'raw';
              this.lexer.inline(token[k], token.tokens);
            }
            return token
          }
        },
        renderer(token) {
          const inside = this.parser.parseInline(token.tokens);
          return conf.renderer(token, inside)
        }
      })
    };
    const block =conf=> add(Object.assign({}, conf, {level: 'block'}));
    const inline =conf=> add(Object.assign({}, conf, {level: 'inline'}));


    block({
      name: 'typedec',
      hint: />TYPE/,
      rule: /^>TYPE (?<name>[a-zA-Z0-9_\-]+)\n/,
      renderer: token=> `<pre>${token.name}</pre>`,
    });
    block({
      name: 'datablock',
      hint: />DATA/,
      rule: /^>DATA\n(?<data>(?:[^: ]+: [^\n]*\n)*)<DATA\n/,
      parse: 'data',
      renderer: (token, inside)=> `<pre>${inside}\n</pre>`,
    });
    inline({
      name: 'dataline',
      hint: /[^: ]+: /,
      rule: /^(?<key>[^: ]+): (?<val>[^\n]*)\n/,
      renderer: token=> `${token.key}: ${token.val}\n`,
    });
    inline({
      name: 'cpblink',
      hint: /\[\[/,
      rule: /^\[\[(?<nst>[^|]+?)(?:\|(?<text>.+?))?\]\]/,
      renderer: token=> `<a href="${token.nst}">${token.text || token.nst}</a>`,
    });

    var wmd = extensions;

    /* node_modules/svelte-markdown/src/Parser.svelte generated by Svelte v3.44.3 */

    function get_each_context_5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[18] = list[i];
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[18] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (15:2) {#if renderers[type]}
    function create_if_block_1$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$1, create_if_block_3$1, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*type*/ ctx[0] === 'table') return 0;
    		if (/*type*/ ctx[0] === 'list') return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(15:2) {#if renderers[type]}",
    		ctx
    	});

    	return block;
    }

    // (10:0) {#if !type}
    function create_if_block$5(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*tokens*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*tokens, renderers*/ 34) {
    				each_value = /*tokens*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(10:0) {#if !type}",
    		ctx
    	});

    	return block;
    }

    // (65:4) {:else}
    function create_else_block_1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*$$restProps*/ ctx[6]];
    	var switch_value = /*renderers*/ ctx[5][/*type*/ ctx[0]];

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			$$slots: { default: [create_default_slot_11] },
    			$$scope: { ctx }
    		};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$$restProps*/ 64)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*$$restProps*/ ctx[6])])
    			: {};

    			if (dirty & /*$$scope, tokens, renderers, $$restProps*/ 8388706) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*renderers*/ ctx[5][/*type*/ ctx[0]])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(65:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (47:30) 
    function create_if_block_3$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_4$1, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*ordered*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(47:30) ",
    		ctx
    	});

    	return block;
    }

    // (16:4) {#if type === 'table'}
    function create_if_block_2$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*renderers*/ ctx[5].table;

    	function switch_props(ctx) {
    		return {
    			props: {
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};

    			if (dirty & /*$$scope, renderers, rows, $$restProps, header*/ 8388716) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*renderers*/ ctx[5].table)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(16:4) {#if type === 'table'}",
    		ctx
    	});

    	return block;
    }

    // (69:8) {:else}
    function create_else_block_2(ctx) {
    	let t_value = /*$$restProps*/ ctx[6].raw + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$$restProps*/ 64 && t_value !== (t_value = /*$$restProps*/ ctx[6].raw + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(69:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (67:8) {#if tokens}
    function create_if_block_5$1(ctx) {
    	let parser;
    	let current;

    	parser = new Parser({
    			props: {
    				tokens: /*tokens*/ ctx[1],
    				renderers: /*renderers*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(parser.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(parser, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const parser_changes = {};
    			if (dirty & /*tokens*/ 2) parser_changes.tokens = /*tokens*/ ctx[1];
    			if (dirty & /*renderers*/ 32) parser_changes.renderers = /*renderers*/ ctx[5];
    			parser.$set(parser_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(parser.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(parser.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(parser, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(67:8) {#if tokens}",
    		ctx
    	});

    	return block;
    }

    // (66:6) <svelte:component this={renderers[type]} {...$$restProps}>
    function create_default_slot_11(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_5$1, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*tokens*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_3(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_3(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(66:6) <svelte:component this={renderers[type]} {...$$restProps}>",
    		ctx
    	});

    	return block;
    }

    // (56:6) {:else}
    function create_else_block$3(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ ordered: /*ordered*/ ctx[4] }, /*$$restProps*/ ctx[6]];
    	var switch_value = /*renderers*/ ctx[5].list;

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			$$slots: { default: [create_default_slot_9] },
    			$$scope: { ctx }
    		};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*ordered, $$restProps*/ 80)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*ordered*/ 16 && { ordered: /*ordered*/ ctx[4] },
    					dirty & /*$$restProps*/ 64 && get_spread_object(/*$$restProps*/ ctx[6])
    				])
    			: {};

    			if (dirty & /*$$scope, $$restProps, renderers*/ 8388704) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*renderers*/ ctx[5].list)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(56:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (48:6) {#if ordered}
    function create_if_block_4$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ ordered: /*ordered*/ ctx[4] }, /*$$restProps*/ ctx[6]];
    	var switch_value = /*renderers*/ ctx[5].list;

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			$$slots: { default: [create_default_slot_7] },
    			$$scope: { ctx }
    		};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*ordered, $$restProps*/ 80)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*ordered*/ 16 && { ordered: /*ordered*/ ctx[4] },
    					dirty & /*$$restProps*/ 64 && get_spread_object(/*$$restProps*/ ctx[6])
    				])
    			: {};

    			if (dirty & /*$$scope, $$restProps, renderers*/ 8388704) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*renderers*/ ctx[5].list)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(48:6) {#if ordered}",
    		ctx
    	});

    	return block;
    }

    // (59:12) <svelte:component this={renderers.unorderedlistitem || renderers.listitem} {...item}>
    function create_default_slot_10(ctx) {
    	let parser;
    	let t;
    	let current;

    	parser = new Parser({
    			props: {
    				tokens: /*item*/ ctx[18].tokens,
    				renderers: /*renderers*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(parser.$$.fragment);
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(parser, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const parser_changes = {};
    			if (dirty & /*$$restProps*/ 64) parser_changes.tokens = /*item*/ ctx[18].tokens;
    			if (dirty & /*renderers*/ 32) parser_changes.renderers = /*renderers*/ ctx[5];
    			parser.$set(parser_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(parser.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(parser.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(parser, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(59:12) <svelte:component this={renderers.unorderedlistitem || renderers.listitem} {...item}>",
    		ctx
    	});

    	return block;
    }

    // (58:10) {#each $$restProps.items as item}
    function create_each_block_5(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*item*/ ctx[18]];
    	var switch_value = /*renderers*/ ctx[5].unorderedlistitem || /*renderers*/ ctx[5].listitem;

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			$$slots: { default: [create_default_slot_10] },
    			$$scope: { ctx }
    		};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$$restProps*/ 64)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*item*/ ctx[18])])
    			: {};

    			if (dirty & /*$$scope, $$restProps, renderers*/ 8388704) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*renderers*/ ctx[5].unorderedlistitem || /*renderers*/ ctx[5].listitem)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5.name,
    		type: "each",
    		source: "(58:10) {#each $$restProps.items as item}",
    		ctx
    	});

    	return block;
    }

    // (57:8) <svelte:component this={renderers.list} {ordered} {...$$restProps}>
    function create_default_slot_9(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_5 = /*$$restProps*/ ctx[6].items;
    	validate_each_argument(each_value_5);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*renderers, $$restProps*/ 96) {
    				each_value_5 = /*$$restProps*/ ctx[6].items;
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5(ctx, each_value_5, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_5.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_5.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(57:8) <svelte:component this={renderers.list} {ordered} {...$$restProps}>",
    		ctx
    	});

    	return block;
    }

    // (51:12) <svelte:component this={renderers.orderedlistitem || renderers.listitem} {...item}>
    function create_default_slot_8(ctx) {
    	let parser;
    	let t;
    	let current;

    	parser = new Parser({
    			props: {
    				tokens: /*item*/ ctx[18].tokens,
    				renderers: /*renderers*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(parser.$$.fragment);
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(parser, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const parser_changes = {};
    			if (dirty & /*$$restProps*/ 64) parser_changes.tokens = /*item*/ ctx[18].tokens;
    			if (dirty & /*renderers*/ 32) parser_changes.renderers = /*renderers*/ ctx[5];
    			parser.$set(parser_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(parser.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(parser.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(parser, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(51:12) <svelte:component this={renderers.orderedlistitem || renderers.listitem} {...item}>",
    		ctx
    	});

    	return block;
    }

    // (50:10) {#each $$restProps.items as item}
    function create_each_block_4(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*item*/ ctx[18]];
    	var switch_value = /*renderers*/ ctx[5].orderedlistitem || /*renderers*/ ctx[5].listitem;

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			$$slots: { default: [create_default_slot_8] },
    			$$scope: { ctx }
    		};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$$restProps*/ 64)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*item*/ ctx[18])])
    			: {};

    			if (dirty & /*$$scope, $$restProps, renderers*/ 8388704) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*renderers*/ ctx[5].orderedlistitem || /*renderers*/ ctx[5].listitem)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(50:10) {#each $$restProps.items as item}",
    		ctx
    	});

    	return block;
    }

    // (49:8) <svelte:component this={renderers.list} {ordered} {...$$restProps}>
    function create_default_slot_7(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_4 = /*$$restProps*/ ctx[6].items;
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*renderers, $$restProps*/ 96) {
    				each_value_4 = /*$$restProps*/ ctx[6].items;
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_4.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_4.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(49:8) <svelte:component this={renderers.list} {ordered} {...$$restProps}>",
    		ctx
    	});

    	return block;
    }

    // (21:14) <svelte:component                 this={renderers.tablecell}                 header={true}                 align={$$restProps.align[i] || 'center'}                 >
    function create_default_slot_6(ctx) {
    	let parser;
    	let t;
    	let current;

    	parser = new Parser({
    			props: {
    				tokens: /*headerItem*/ ctx[16].tokens,
    				renderers: /*renderers*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(parser.$$.fragment);
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(parser, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const parser_changes = {};
    			if (dirty & /*header*/ 4) parser_changes.tokens = /*headerItem*/ ctx[16].tokens;
    			if (dirty & /*renderers*/ 32) parser_changes.renderers = /*renderers*/ ctx[5];
    			parser.$set(parser_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(parser.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(parser.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(parser, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(21:14) <svelte:component                 this={renderers.tablecell}                 header={true}                 align={$$restProps.align[i] || 'center'}                 >",
    		ctx
    	});

    	return block;
    }

    // (20:12) {#each header as headerItem, i}
    function create_each_block_3(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*renderers*/ ctx[5].tablecell;

    	function switch_props(ctx) {
    		return {
    			props: {
    				header: true,
    				align: /*$$restProps*/ ctx[6].align[/*i*/ ctx[15]] || 'center',
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*$$restProps*/ 64) switch_instance_changes.align = /*$$restProps*/ ctx[6].align[/*i*/ ctx[15]] || 'center';

    			if (dirty & /*$$scope, header, renderers*/ 8388644) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*renderers*/ ctx[5].tablecell)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(20:12) {#each header as headerItem, i}",
    		ctx
    	});

    	return block;
    }

    // (19:10) <svelte:component this={renderers.tablerow}>
    function create_default_slot_5(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_3 = /*header*/ ctx[2];
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*renderers, $$restProps, header*/ 100) {
    				each_value_3 = /*header*/ ctx[2];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(19:10) <svelte:component this={renderers.tablerow}>",
    		ctx
    	});

    	return block;
    }

    // (18:8) <svelte:component this={renderers.tablehead}>
    function create_default_slot_4(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*renderers*/ ctx[5].tablerow;

    	function switch_props(ctx) {
    		return {
    			props: {
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};

    			if (dirty & /*$$scope, header, renderers, $$restProps*/ 8388708) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*renderers*/ ctx[5].tablerow)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(18:8) <svelte:component this={renderers.tablehead}>",
    		ctx
    	});

    	return block;
    }

    // (35:16) <svelte:component                   this={renderers.tablecell}                   header={false}                   align={$$restProps.align[i] || 'center'}                   >
    function create_default_slot_3(ctx) {
    	let parser;
    	let current;

    	parser = new Parser({
    			props: {
    				tokens: /*cells*/ ctx[13].tokens,
    				renderers: /*renderers*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(parser.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(parser, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const parser_changes = {};
    			if (dirty & /*rows*/ 8) parser_changes.tokens = /*cells*/ ctx[13].tokens;
    			if (dirty & /*renderers*/ 32) parser_changes.renderers = /*renderers*/ ctx[5];
    			parser.$set(parser_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(parser.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(parser.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(parser, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(35:16) <svelte:component                   this={renderers.tablecell}                   header={false}                   align={$$restProps.align[i] || 'center'}                   >",
    		ctx
    	});

    	return block;
    }

    // (34:14) {#each row as cells, i}
    function create_each_block_2(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*renderers*/ ctx[5].tablecell;

    	function switch_props(ctx) {
    		return {
    			props: {
    				header: false,
    				align: /*$$restProps*/ ctx[6].align[/*i*/ ctx[15]] || 'center',
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*$$restProps*/ 64) switch_instance_changes.align = /*$$restProps*/ ctx[6].align[/*i*/ ctx[15]] || 'center';

    			if (dirty & /*$$scope, rows, renderers*/ 8388648) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*renderers*/ ctx[5].tablecell)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(34:14) {#each row as cells, i}",
    		ctx
    	});

    	return block;
    }

    // (33:12) <svelte:component this={renderers.tablerow}>
    function create_default_slot_2(ctx) {
    	let t;
    	let current;
    	let each_value_2 = /*row*/ ctx[10];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*renderers, $$restProps, rows*/ 104) {
    				each_value_2 = /*row*/ ctx[10];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(33:12) <svelte:component this={renderers.tablerow}>",
    		ctx
    	});

    	return block;
    }

    // (32:10) {#each rows as row}
    function create_each_block_1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*renderers*/ ctx[5].tablerow;

    	function switch_props(ctx) {
    		return {
    			props: {
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};

    			if (dirty & /*$$scope, rows, renderers, $$restProps*/ 8388712) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*renderers*/ ctx[5].tablerow)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(32:10) {#each rows as row}",
    		ctx
    	});

    	return block;
    }

    // (31:8) <svelte:component this={renderers.tablebody}>
    function create_default_slot_1$1(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*rows*/ ctx[3];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*renderers, rows, $$restProps*/ 104) {
    				each_value_1 = /*rows*/ ctx[3];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(31:8) <svelte:component this={renderers.tablebody}>",
    		ctx
    	});

    	return block;
    }

    // (17:6) <svelte:component this={renderers.table}>
    function create_default_slot$2(ctx) {
    	let switch_instance0;
    	let t;
    	let switch_instance1;
    	let switch_instance1_anchor;
    	let current;
    	var switch_value = /*renderers*/ ctx[5].tablehead;

    	function switch_props(ctx) {
    		return {
    			props: {
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance0 = new switch_value(switch_props(ctx));
    	}

    	var switch_value_1 = /*renderers*/ ctx[5].tablebody;

    	function switch_props_1(ctx) {
    		return {
    			props: {
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value_1) {
    		switch_instance1 = new switch_value_1(switch_props_1(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance0) create_component(switch_instance0.$$.fragment);
    			t = space();
    			if (switch_instance1) create_component(switch_instance1.$$.fragment);
    			switch_instance1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance0) {
    				mount_component(switch_instance0, target, anchor);
    			}

    			insert_dev(target, t, anchor);

    			if (switch_instance1) {
    				mount_component(switch_instance1, target, anchor);
    			}

    			insert_dev(target, switch_instance1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance0_changes = {};

    			if (dirty & /*$$scope, renderers, header, $$restProps*/ 8388708) {
    				switch_instance0_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*renderers*/ ctx[5].tablehead)) {
    				if (switch_instance0) {
    					group_outros();
    					const old_component = switch_instance0;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance0 = new switch_value(switch_props(ctx));
    					create_component(switch_instance0.$$.fragment);
    					transition_in(switch_instance0.$$.fragment, 1);
    					mount_component(switch_instance0, t.parentNode, t);
    				} else {
    					switch_instance0 = null;
    				}
    			} else if (switch_value) {
    				switch_instance0.$set(switch_instance0_changes);
    			}

    			const switch_instance1_changes = {};

    			if (dirty & /*$$scope, rows, renderers, $$restProps*/ 8388712) {
    				switch_instance1_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value_1 !== (switch_value_1 = /*renderers*/ ctx[5].tablebody)) {
    				if (switch_instance1) {
    					group_outros();
    					const old_component = switch_instance1;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_1) {
    					switch_instance1 = new switch_value_1(switch_props_1(ctx));
    					create_component(switch_instance1.$$.fragment);
    					transition_in(switch_instance1.$$.fragment, 1);
    					mount_component(switch_instance1, switch_instance1_anchor.parentNode, switch_instance1_anchor);
    				} else {
    					switch_instance1 = null;
    				}
    			} else if (switch_value_1) {
    				switch_instance1.$set(switch_instance1_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance0) transition_in(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_in(switch_instance1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance0) transition_out(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_out(switch_instance1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (switch_instance0) destroy_component(switch_instance0, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(switch_instance1_anchor);
    			if (switch_instance1) destroy_component(switch_instance1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(17:6) <svelte:component this={renderers.table}>",
    		ctx
    	});

    	return block;
    }

    // (11:2) {#each tokens as token}
    function create_each_block(ctx) {
    	let parser;
    	let current;
    	const parser_spread_levels = [/*token*/ ctx[7], { renderers: /*renderers*/ ctx[5] }];
    	let parser_props = {};

    	for (let i = 0; i < parser_spread_levels.length; i += 1) {
    		parser_props = assign(parser_props, parser_spread_levels[i]);
    	}

    	parser = new Parser({ props: parser_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(parser.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(parser, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const parser_changes = (dirty & /*tokens, renderers*/ 34)
    			? get_spread_update(parser_spread_levels, [
    					dirty & /*tokens*/ 2 && get_spread_object(/*token*/ ctx[7]),
    					dirty & /*renderers*/ 32 && { renderers: /*renderers*/ ctx[5] }
    				])
    			: {};

    			parser.$set(parser_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(parser.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(parser.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(parser, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(11:2) {#each tokens as token}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$5, create_if_block_1$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*type*/ ctx[0]) return 0;
    		if (/*renderers*/ ctx[5][/*type*/ ctx[0]]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	const omit_props_names = ["type","tokens","header","rows","ordered","renderers"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Parser', slots, []);
    	let { type = undefined } = $$props;
    	let { tokens = undefined } = $$props;
    	let { header = undefined } = $$props;
    	let { rows = undefined } = $$props;
    	let { ordered = false } = $$props;
    	let { renderers } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('type' in $$new_props) $$invalidate(0, type = $$new_props.type);
    		if ('tokens' in $$new_props) $$invalidate(1, tokens = $$new_props.tokens);
    		if ('header' in $$new_props) $$invalidate(2, header = $$new_props.header);
    		if ('rows' in $$new_props) $$invalidate(3, rows = $$new_props.rows);
    		if ('ordered' in $$new_props) $$invalidate(4, ordered = $$new_props.ordered);
    		if ('renderers' in $$new_props) $$invalidate(5, renderers = $$new_props.renderers);
    	};

    	$$self.$capture_state = () => ({
    		type,
    		tokens,
    		header,
    		rows,
    		ordered,
    		renderers
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('type' in $$props) $$invalidate(0, type = $$new_props.type);
    		if ('tokens' in $$props) $$invalidate(1, tokens = $$new_props.tokens);
    		if ('header' in $$props) $$invalidate(2, header = $$new_props.header);
    		if ('rows' in $$props) $$invalidate(3, rows = $$new_props.rows);
    		if ('ordered' in $$props) $$invalidate(4, ordered = $$new_props.ordered);
    		if ('renderers' in $$props) $$invalidate(5, renderers = $$new_props.renderers);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [type, tokens, header, rows, ordered, renderers, $$restProps];
    }

    class Parser extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {
    			type: 0,
    			tokens: 1,
    			header: 2,
    			rows: 3,
    			ordered: 4,
    			renderers: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Parser",
    			options,
    			id: create_fragment$p.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*renderers*/ ctx[5] === undefined && !('renderers' in props)) {
    			console.warn("<Parser> was created without expected prop 'renderers'");
    		}
    	}

    	get type() {
    		throw new Error("<Parser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Parser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tokens() {
    		throw new Error("<Parser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tokens(value) {
    		throw new Error("<Parser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get header() {
    		throw new Error("<Parser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set header(value) {
    		throw new Error("<Parser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rows() {
    		throw new Error("<Parser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rows(value) {
    		throw new Error("<Parser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ordered() {
    		throw new Error("<Parser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ordered(value) {
    		throw new Error("<Parser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get renderers() {
    		throw new Error("<Parser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set renderers(value) {
    		throw new Error("<Parser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const key = {};

    /* node_modules/svelte-markdown/src/renderers/Heading.svelte generated by Svelte v3.44.3 */
    const file$l = "node_modules/svelte-markdown/src/renderers/Heading.svelte";

    // (28:0) {:else}
    function create_else_block$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*raw*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*raw*/ 2) set_data_dev(t, /*raw*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(28:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (26:22) 
    function create_if_block_5(ctx) {
    	let h6;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			if (default_slot) default_slot.c();
    			attr_dev(h6, "id", /*id*/ ctx[2]);
    			add_location(h6, file$l, 26, 2, 596);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);

    			if (default_slot) {
    				default_slot.m(h6, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*id*/ 4) {
    				attr_dev(h6, "id", /*id*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(26:22) ",
    		ctx
    	});

    	return block;
    }

    // (24:22) 
    function create_if_block_4(ctx) {
    	let h5;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			h5 = element("h5");
    			if (default_slot) default_slot.c();
    			attr_dev(h5, "id", /*id*/ ctx[2]);
    			add_location(h5, file$l, 24, 2, 543);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h5, anchor);

    			if (default_slot) {
    				default_slot.m(h5, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*id*/ 4) {
    				attr_dev(h5, "id", /*id*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h5);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(24:22) ",
    		ctx
    	});

    	return block;
    }

    // (22:22) 
    function create_if_block_3(ctx) {
    	let h4;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			if (default_slot) default_slot.c();
    			attr_dev(h4, "id", /*id*/ ctx[2]);
    			add_location(h4, file$l, 22, 2, 490);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);

    			if (default_slot) {
    				default_slot.m(h4, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*id*/ 4) {
    				attr_dev(h4, "id", /*id*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(22:22) ",
    		ctx
    	});

    	return block;
    }

    // (20:22) 
    function create_if_block_2(ctx) {
    	let h3;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			if (default_slot) default_slot.c();
    			attr_dev(h3, "id", /*id*/ ctx[2]);
    			add_location(h3, file$l, 20, 2, 437);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);

    			if (default_slot) {
    				default_slot.m(h3, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*id*/ 4) {
    				attr_dev(h3, "id", /*id*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(20:22) ",
    		ctx
    	});

    	return block;
    }

    // (18:22) 
    function create_if_block_1(ctx) {
    	let h2;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			if (default_slot) default_slot.c();
    			attr_dev(h2, "id", /*id*/ ctx[2]);
    			add_location(h2, file$l, 18, 2, 384);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);

    			if (default_slot) {
    				default_slot.m(h2, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*id*/ 4) {
    				attr_dev(h2, "id", /*id*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(18:22) ",
    		ctx
    	});

    	return block;
    }

    // (16:0) {#if depth === 1}
    function create_if_block$4(ctx) {
    	let h1;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			if (default_slot) default_slot.c();
    			attr_dev(h1, "id", /*id*/ ctx[2]);
    			add_location(h1, file$l, 16, 2, 331);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);

    			if (default_slot) {
    				default_slot.m(h1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*id*/ 4) {
    				attr_dev(h1, "id", /*id*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(16:0) {#if depth === 1}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	const if_block_creators = [
    		create_if_block$4,
    		create_if_block_1,
    		create_if_block_2,
    		create_if_block_3,
    		create_if_block_4,
    		create_if_block_5,
    		create_else_block$2
    	];

    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*depth*/ ctx[0] === 1) return 0;
    		if (/*depth*/ ctx[0] === 2) return 1;
    		if (/*depth*/ ctx[0] === 3) return 2;
    		if (/*depth*/ ctx[0] === 4) return 3;
    		if (/*depth*/ ctx[0] === 5) return 4;
    		if (/*depth*/ ctx[0] === 6) return 5;
    		return 6;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let id;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Heading', slots, ['default']);
    	let { depth } = $$props;
    	let { raw } = $$props;
    	let { text } = $$props;
    	const { slug, getOptions } = getContext(key);
    	const options = getOptions();
    	const writable_props = ['depth', 'raw', 'text'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Heading> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('depth' in $$props) $$invalidate(0, depth = $$props.depth);
    		if ('raw' in $$props) $$invalidate(1, raw = $$props.raw);
    		if ('text' in $$props) $$invalidate(3, text = $$props.text);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		key,
    		depth,
    		raw,
    		text,
    		slug,
    		getOptions,
    		options,
    		id
    	});

    	$$self.$inject_state = $$props => {
    		if ('depth' in $$props) $$invalidate(0, depth = $$props.depth);
    		if ('raw' in $$props) $$invalidate(1, raw = $$props.raw);
    		if ('text' in $$props) $$invalidate(3, text = $$props.text);
    		if ('id' in $$props) $$invalidate(2, id = $$props.id);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*text*/ 8) {
    			$$invalidate(2, id = options.headerIds
    			? options.headerPrefix + slug(text)
    			: undefined);
    		}
    	};

    	return [depth, raw, id, text, $$scope, slots];
    }

    class Heading extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, { depth: 0, raw: 1, text: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Heading",
    			options,
    			id: create_fragment$o.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*depth*/ ctx[0] === undefined && !('depth' in props)) {
    			console.warn("<Heading> was created without expected prop 'depth'");
    		}

    		if (/*raw*/ ctx[1] === undefined && !('raw' in props)) {
    			console.warn("<Heading> was created without expected prop 'raw'");
    		}

    		if (/*text*/ ctx[3] === undefined && !('text' in props)) {
    			console.warn("<Heading> was created without expected prop 'text'");
    		}
    	}

    	get depth() {
    		throw new Error("<Heading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set depth(value) {
    		throw new Error("<Heading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get raw() {
    		throw new Error("<Heading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set raw(value) {
    		throw new Error("<Heading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Heading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Heading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/Paragraph.svelte generated by Svelte v3.44.3 */

    const file$k = "node_modules/svelte-markdown/src/renderers/Paragraph.svelte";

    function create_fragment$n(ctx) {
    	let p;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			p = element("p");
    			if (default_slot) default_slot.c();
    			add_location(p, file$k, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);

    			if (default_slot) {
    				default_slot.m(p, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Paragraph', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Paragraph> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class Paragraph extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Paragraph",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/Text.svelte generated by Svelte v3.44.3 */

    function create_fragment$m(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, ['default']);
    	let { text } = $$props;
    	let { raw } = $$props;
    	const writable_props = ['text', 'raw'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('text' in $$props) $$invalidate(0, text = $$props.text);
    		if ('raw' in $$props) $$invalidate(1, raw = $$props.raw);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ text, raw });

    	$$self.$inject_state = $$props => {
    		if ('text' in $$props) $$invalidate(0, text = $$props.text);
    		if ('raw' in $$props) $$invalidate(1, raw = $$props.raw);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [text, raw, $$scope, slots];
    }

    class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, { text: 0, raw: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*text*/ ctx[0] === undefined && !('text' in props)) {
    			console.warn("<Text> was created without expected prop 'text'");
    		}

    		if (/*raw*/ ctx[1] === undefined && !('raw' in props)) {
    			console.warn("<Text> was created without expected prop 'raw'");
    		}
    	}

    	get text() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get raw() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set raw(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/Image.svelte generated by Svelte v3.44.3 */

    const file$j = "node_modules/svelte-markdown/src/renderers/Image.svelte";

    function create_fragment$l(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*href*/ ctx[0])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "title", /*title*/ ctx[1]);
    			attr_dev(img, "alt", /*text*/ ctx[2]);
    			add_location(img, file$j, 6, 0, 97);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*href*/ 1 && !src_url_equal(img.src, img_src_value = /*href*/ ctx[0])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*title*/ 2) {
    				attr_dev(img, "title", /*title*/ ctx[1]);
    			}

    			if (dirty & /*text*/ 4) {
    				attr_dev(img, "alt", /*text*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Image', slots, []);
    	let { href = '' } = $$props;
    	let { title = undefined } = $$props;
    	let { text = '' } = $$props;
    	const writable_props = ['href', 'title', 'text'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Image> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('href' in $$props) $$invalidate(0, href = $$props.href);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('text' in $$props) $$invalidate(2, text = $$props.text);
    	};

    	$$self.$capture_state = () => ({ href, title, text });

    	$$self.$inject_state = $$props => {
    		if ('href' in $$props) $$invalidate(0, href = $$props.href);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('text' in $$props) $$invalidate(2, text = $$props.text);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [href, title, text];
    }

    class Image extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, { href: 0, title: 1, text: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Image",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get href() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/Link.svelte generated by Svelte v3.44.3 */

    const file$i = "node_modules/svelte-markdown/src/renderers/Link.svelte";

    function create_fragment$k(ctx) {
    	let a;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			attr_dev(a, "href", /*href*/ ctx[0]);
    			attr_dev(a, "title", /*title*/ ctx[1]);
    			add_location(a, file$i, 5, 0, 74);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*href*/ 1) {
    				attr_dev(a, "href", /*href*/ ctx[0]);
    			}

    			if (!current || dirty & /*title*/ 2) {
    				attr_dev(a, "title", /*title*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Link', slots, ['default']);
    	let { href = '' } = $$props;
    	let { title = undefined } = $$props;
    	const writable_props = ['href', 'title'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Link> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('href' in $$props) $$invalidate(0, href = $$props.href);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ href, title });

    	$$self.$inject_state = $$props => {
    		if ('href' in $$props) $$invalidate(0, href = $$props.href);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [href, title, $$scope, slots];
    }

    class Link extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, { href: 0, title: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Link",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get href() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/Em.svelte generated by Svelte v3.44.3 */

    const file$h = "node_modules/svelte-markdown/src/renderers/Em.svelte";

    function create_fragment$j(ctx) {
    	let em;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			em = element("em");
    			if (default_slot) default_slot.c();
    			add_location(em, file$h, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, em, anchor);

    			if (default_slot) {
    				default_slot.m(em, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(em);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Em', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Em> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class Em extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Em",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/Del.svelte generated by Svelte v3.44.3 */

    const file$g = "node_modules/svelte-markdown/src/renderers/Del.svelte";

    function create_fragment$i(ctx) {
    	let del;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			del = element("del");
    			if (default_slot) default_slot.c();
    			add_location(del, file$g, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, del, anchor);

    			if (default_slot) {
    				default_slot.m(del, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(del);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Del', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Del> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class Del extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Del",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/Codespan.svelte generated by Svelte v3.44.3 */

    const file$f = "node_modules/svelte-markdown/src/renderers/Codespan.svelte";

    function create_fragment$h(ctx) {
    	let code;
    	let t_value = /*raw*/ ctx[0].replace(/`/g, '') + "";
    	let t;

    	const block = {
    		c: function create() {
    			code = element("code");
    			t = text(t_value);
    			add_location(code, file$f, 4, 0, 37);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, code, anchor);
    			append_dev(code, t);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*raw*/ 1 && t_value !== (t_value = /*raw*/ ctx[0].replace(/`/g, '') + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(code);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Codespan', slots, []);
    	let { raw } = $$props;
    	const writable_props = ['raw'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Codespan> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('raw' in $$props) $$invalidate(0, raw = $$props.raw);
    	};

    	$$self.$capture_state = () => ({ raw });

    	$$self.$inject_state = $$props => {
    		if ('raw' in $$props) $$invalidate(0, raw = $$props.raw);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [raw];
    }

    class Codespan extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, { raw: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Codespan",
    			options,
    			id: create_fragment$h.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*raw*/ ctx[0] === undefined && !('raw' in props)) {
    			console.warn("<Codespan> was created without expected prop 'raw'");
    		}
    	}

    	get raw() {
    		throw new Error("<Codespan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set raw(value) {
    		throw new Error("<Codespan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/Strong.svelte generated by Svelte v3.44.3 */

    const file$e = "node_modules/svelte-markdown/src/renderers/Strong.svelte";

    function create_fragment$g(ctx) {
    	let strong;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			strong = element("strong");
    			if (default_slot) default_slot.c();
    			add_location(strong, file$e, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, strong, anchor);

    			if (default_slot) {
    				default_slot.m(strong, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(strong);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Strong', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Strong> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class Strong extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Strong",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/Table.svelte generated by Svelte v3.44.3 */

    const file$d = "node_modules/svelte-markdown/src/renderers/Table.svelte";

    function create_fragment$f(ctx) {
    	let table;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			table = element("table");
    			if (default_slot) default_slot.c();
    			add_location(table, file$d, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);

    			if (default_slot) {
    				default_slot.m(table, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Table', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Table> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class Table extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Table",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/TableHead.svelte generated by Svelte v3.44.3 */

    const file$c = "node_modules/svelte-markdown/src/renderers/TableHead.svelte";

    function create_fragment$e(ctx) {
    	let thead;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			thead = element("thead");
    			if (default_slot) default_slot.c();
    			add_location(thead, file$c, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);

    			if (default_slot) {
    				default_slot.m(thead, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TableHead', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TableHead> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class TableHead extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableHead",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/TableBody.svelte generated by Svelte v3.44.3 */

    const file$b = "node_modules/svelte-markdown/src/renderers/TableBody.svelte";

    function create_fragment$d(ctx) {
    	let tbody;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			tbody = element("tbody");
    			if (default_slot) default_slot.c();
    			add_location(tbody, file$b, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tbody, anchor);

    			if (default_slot) {
    				default_slot.m(tbody, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tbody);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TableBody', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TableBody> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class TableBody extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableBody",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/TableRow.svelte generated by Svelte v3.44.3 */

    const file$a = "node_modules/svelte-markdown/src/renderers/TableRow.svelte";

    function create_fragment$c(ctx) {
    	let tr;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			if (default_slot) default_slot.c();
    			add_location(tr, file$a, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			if (default_slot) {
    				default_slot.m(tr, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TableRow', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TableRow> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class TableRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableRow",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/TableCell.svelte generated by Svelte v3.44.3 */

    const file$9 = "node_modules/svelte-markdown/src/renderers/TableCell.svelte";

    // (8:0) {:else}
    function create_else_block$1(ctx) {
    	let td;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			td = element("td");
    			if (default_slot) default_slot.c();
    			attr_dev(td, "align", /*align*/ ctx[1]);
    			add_location(td, file$9, 8, 2, 115);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);

    			if (default_slot) {
    				default_slot.m(td, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*align*/ 2) {
    				attr_dev(td, "align", /*align*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(8:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (6:0) {#if header}
    function create_if_block$3(ctx) {
    	let th;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			th = element("th");
    			if (default_slot) default_slot.c();
    			attr_dev(th, "align", /*align*/ ctx[1]);
    			add_location(th, file$9, 6, 2, 74);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, th, anchor);

    			if (default_slot) {
    				default_slot.m(th, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*align*/ 2) {
    				attr_dev(th, "align", /*align*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(th);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(6:0) {#if header}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$3, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*header*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TableCell', slots, ['default']);
    	let { header } = $$props;
    	let { align } = $$props;
    	const writable_props = ['header', 'align'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TableCell> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('header' in $$props) $$invalidate(0, header = $$props.header);
    		if ('align' in $$props) $$invalidate(1, align = $$props.align);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ header, align });

    	$$self.$inject_state = $$props => {
    		if ('header' in $$props) $$invalidate(0, header = $$props.header);
    		if ('align' in $$props) $$invalidate(1, align = $$props.align);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [header, align, $$scope, slots];
    }

    class TableCell extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { header: 0, align: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableCell",
    			options,
    			id: create_fragment$b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*header*/ ctx[0] === undefined && !('header' in props)) {
    			console.warn("<TableCell> was created without expected prop 'header'");
    		}

    		if (/*align*/ ctx[1] === undefined && !('align' in props)) {
    			console.warn("<TableCell> was created without expected prop 'align'");
    		}
    	}

    	get header() {
    		throw new Error("<TableCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set header(value) {
    		throw new Error("<TableCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get align() {
    		throw new Error("<TableCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set align(value) {
    		throw new Error("<TableCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/List.svelte generated by Svelte v3.44.3 */

    const file$8 = "node_modules/svelte-markdown/src/renderers/List.svelte";

    // (8:0) {:else}
    function create_else_block(ctx) {
    	let ul;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			add_location(ul, file$8, 8, 2, 117);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(8:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (6:0) {#if ordered}
    function create_if_block$2(ctx) {
    	let ol;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			ol = element("ol");
    			if (default_slot) default_slot.c();
    			attr_dev(ol, "start", /*start*/ ctx[1]);
    			add_location(ol, file$8, 6, 2, 76);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ol, anchor);

    			if (default_slot) {
    				default_slot.m(ol, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*start*/ 2) {
    				attr_dev(ol, "start", /*start*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ol);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(6:0) {#if ordered}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$2, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*ordered*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('List', slots, ['default']);
    	let { ordered } = $$props;
    	let { start } = $$props;
    	const writable_props = ['ordered', 'start'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<List> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('ordered' in $$props) $$invalidate(0, ordered = $$props.ordered);
    		if ('start' in $$props) $$invalidate(1, start = $$props.start);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ ordered, start });

    	$$self.$inject_state = $$props => {
    		if ('ordered' in $$props) $$invalidate(0, ordered = $$props.ordered);
    		if ('start' in $$props) $$invalidate(1, start = $$props.start);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [ordered, start, $$scope, slots];
    }

    class List extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, { ordered: 0, start: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List",
    			options,
    			id: create_fragment$a.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*ordered*/ ctx[0] === undefined && !('ordered' in props)) {
    			console.warn("<List> was created without expected prop 'ordered'");
    		}

    		if (/*start*/ ctx[1] === undefined && !('start' in props)) {
    			console.warn("<List> was created without expected prop 'start'");
    		}
    	}

    	get ordered() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ordered(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get start() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set start(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/ListItem.svelte generated by Svelte v3.44.3 */

    const file$7 = "node_modules/svelte-markdown/src/renderers/ListItem.svelte";

    function create_fragment$9(ctx) {
    	let li;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (default_slot) default_slot.c();
    			add_location(li, file$7, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ListItem', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ListItem> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class ListItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ListItem",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/Hr.svelte generated by Svelte v3.44.3 */

    const file$6 = "node_modules/svelte-markdown/src/renderers/Hr.svelte";

    function create_fragment$8(ctx) {
    	let hr;

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			add_location(hr, file$6, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Hr', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Hr> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Hr extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Hr",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/Html.svelte generated by Svelte v3.44.3 */

    function create_fragment$7(ctx) {
    	let html_tag;
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty$1();
    			html_tag.a = html_anchor;
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(/*text*/ ctx[0], target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*text*/ 1) html_tag.p(/*text*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Html', slots, []);
    	let { text } = $$props;
    	const writable_props = ['text'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Html> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('text' in $$props) $$invalidate(0, text = $$props.text);
    	};

    	$$self.$capture_state = () => ({ text });

    	$$self.$inject_state = $$props => {
    		if ('text' in $$props) $$invalidate(0, text = $$props.text);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [text];
    }

    class Html extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, { text: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Html",
    			options,
    			id: create_fragment$7.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*text*/ ctx[0] === undefined && !('text' in props)) {
    			console.warn("<Html> was created without expected prop 'text'");
    		}
    	}

    	get text() {
    		throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/Blockquote.svelte generated by Svelte v3.44.3 */

    const file$5 = "node_modules/svelte-markdown/src/renderers/Blockquote.svelte";

    function create_fragment$6(ctx) {
    	let blockquote;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			blockquote = element("blockquote");
    			if (default_slot) default_slot.c();
    			add_location(blockquote, file$5, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, blockquote, anchor);

    			if (default_slot) {
    				default_slot.m(blockquote, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(blockquote);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Blockquote', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Blockquote> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class Blockquote extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Blockquote",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/Code.svelte generated by Svelte v3.44.3 */

    const file$4 = "node_modules/svelte-markdown/src/renderers/Code.svelte";

    function create_fragment$5(ctx) {
    	let pre;
    	let code;
    	let t;

    	const block = {
    		c: function create() {
    			pre = element("pre");
    			code = element("code");
    			t = text(/*text*/ ctx[1]);
    			add_location(code, file$4, 5, 18, 74);
    			attr_dev(pre, "class", /*lang*/ ctx[0]);
    			add_location(pre, file$4, 5, 0, 56);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, pre, anchor);
    			append_dev(pre, code);
    			append_dev(code, t);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*text*/ 2) set_data_dev(t, /*text*/ ctx[1]);

    			if (dirty & /*lang*/ 1) {
    				attr_dev(pre, "class", /*lang*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(pre);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Code', slots, []);
    	let { lang } = $$props;
    	let { text } = $$props;
    	const writable_props = ['lang', 'text'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Code> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('lang' in $$props) $$invalidate(0, lang = $$props.lang);
    		if ('text' in $$props) $$invalidate(1, text = $$props.text);
    	};

    	$$self.$capture_state = () => ({ lang, text });

    	$$self.$inject_state = $$props => {
    		if ('lang' in $$props) $$invalidate(0, lang = $$props.lang);
    		if ('text' in $$props) $$invalidate(1, text = $$props.text);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [lang, text];
    }

    class Code extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { lang: 0, text: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Code",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*lang*/ ctx[0] === undefined && !('lang' in props)) {
    			console.warn("<Code> was created without expected prop 'lang'");
    		}

    		if (/*text*/ ctx[1] === undefined && !('text' in props)) {
    			console.warn("<Code> was created without expected prop 'text'");
    		}
    	}

    	get lang() {
    		throw new Error("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lang(value) {
    		throw new Error("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-markdown/src/renderers/Br.svelte generated by Svelte v3.44.3 */

    const file$3 = "node_modules/svelte-markdown/src/renderers/Br.svelte";

    function create_fragment$4(ctx) {
    	let br;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			br = element("br");
    			if (default_slot) default_slot.c();
    			add_location(br, file$3, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, br, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(br);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Br', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Br> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class Br extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Br",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    const defaultRenderers = {
      heading: Heading,
      paragraph: Paragraph,
      text: Text,
      image: Image,
      link: Link,
      em: Em,
      strong: Strong,
      codespan: Codespan,
      del: Del,
      table: Table,
      tablehead: TableHead,
      tablebody: TableBody,
      tablerow: TableRow,
      tablecell: TableCell,
      list: List,
      orderedlistitem: null,
      unorderedlistitem: null,
      listitem: ListItem,
      hr: Hr,
      html: Html,
      blockquote: Blockquote,
      code: Code,
      br: Br,
    };
    const defaultOptions = {
      baseUrl: null,
      breaks: false,
      gfm: true,
      headerIds: true,
      headerPrefix: '',
      highlight: null,
      langPrefix: 'language-',
      mangle: true,
      pedantic: false,
      renderer: null,
      sanitize: false,
      sanitizer: null,
      silent: false,
      smartLists: false,
      smartypants: false,
      tokenizer: null,
      xhtml: false,
    };

    /* node_modules/svelte-markdown/src/SvelteMarkdown.svelte generated by Svelte v3.44.3 */

    function create_fragment$3(ctx) {
    	let parser;
    	let current;

    	parser = new Parser({
    			props: {
    				tokens: /*tokens*/ ctx[0],
    				renderers: /*combinedRenderers*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(parser.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(parser, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const parser_changes = {};
    			if (dirty & /*tokens*/ 1) parser_changes.tokens = /*tokens*/ ctx[0];
    			if (dirty & /*combinedRenderers*/ 2) parser_changes.renderers = /*combinedRenderers*/ ctx[1];
    			parser.$set(parser_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(parser.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(parser.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(parser, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let slugger;
    	let combinedOptions;
    	let combinedRenderers;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SvelteMarkdown', slots, []);
    	let { source = '' } = $$props;
    	let { renderers = {} } = $$props;
    	let { options = {} } = $$props;
    	let { isInline = false } = $$props;
    	const dispatch = createEventDispatcher();
    	let tokens;
    	let lexer;
    	let mounted;

    	setContext(key, {
    		slug: val => slugger ? slugger.slug(val) : '',
    		getOptions: () => combinedOptions
    	});

    	onMount(() => {
    		$$invalidate(7, mounted = true);
    	});

    	const writable_props = ['source', 'renderers', 'options', 'isInline'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SvelteMarkdown> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('source' in $$props) $$invalidate(2, source = $$props.source);
    		if ('renderers' in $$props) $$invalidate(3, renderers = $$props.renderers);
    		if ('options' in $$props) $$invalidate(4, options = $$props.options);
    		if ('isInline' in $$props) $$invalidate(5, isInline = $$props.isInline);
    	};

    	$$self.$capture_state = () => ({
    		setContext,
    		createEventDispatcher,
    		onMount,
    		Parser,
    		Lexer,
    		Slugger,
    		defaultOptions,
    		defaultRenderers,
    		key,
    		source,
    		renderers,
    		options,
    		isInline,
    		dispatch,
    		tokens,
    		lexer,
    		mounted,
    		combinedOptions,
    		slugger,
    		combinedRenderers
    	});

    	$$self.$inject_state = $$props => {
    		if ('source' in $$props) $$invalidate(2, source = $$props.source);
    		if ('renderers' in $$props) $$invalidate(3, renderers = $$props.renderers);
    		if ('options' in $$props) $$invalidate(4, options = $$props.options);
    		if ('isInline' in $$props) $$invalidate(5, isInline = $$props.isInline);
    		if ('tokens' in $$props) $$invalidate(0, tokens = $$props.tokens);
    		if ('lexer' in $$props) $$invalidate(6, lexer = $$props.lexer);
    		if ('mounted' in $$props) $$invalidate(7, mounted = $$props.mounted);
    		if ('combinedOptions' in $$props) $$invalidate(8, combinedOptions = $$props.combinedOptions);
    		if ('slugger' in $$props) slugger = $$props.slugger;
    		if ('combinedRenderers' in $$props) $$invalidate(1, combinedRenderers = $$props.combinedRenderers);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*source*/ 4) {
    			slugger = source ? new Slugger() : undefined;
    		}

    		if ($$self.$$.dirty & /*options*/ 16) {
    			$$invalidate(8, combinedOptions = { ...defaultOptions, ...options });
    		}

    		if ($$self.$$.dirty & /*combinedOptions, isInline, lexer, source, tokens*/ 357) {
    			{
    				$$invalidate(6, lexer = new Lexer(combinedOptions));

    				$$invalidate(0, tokens = isInline
    				? lexer.inlineTokens(source)
    				: lexer.lex(source));

    				dispatch('parsed', { tokens });
    			}
    		}

    		if ($$self.$$.dirty & /*renderers*/ 8) {
    			$$invalidate(1, combinedRenderers = { ...defaultRenderers, ...renderers });
    		}

    		if ($$self.$$.dirty & /*mounted, tokens*/ 129) {
    			mounted && dispatch('parsed', { tokens });
    		}
    	};

    	return [
    		tokens,
    		combinedRenderers,
    		source,
    		renderers,
    		options,
    		isInline,
    		lexer,
    		mounted,
    		combinedOptions
    	];
    }

    class SvelteMarkdown extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
    			source: 2,
    			renderers: 3,
    			options: 4,
    			isInline: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SvelteMarkdown",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get source() {
    		throw new Error("<SvelteMarkdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set source(value) {
    		throw new Error("<SvelteMarkdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get renderers() {
    		throw new Error("<SvelteMarkdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set renderers(value) {
    		throw new Error("<SvelteMarkdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<SvelteMarkdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<SvelteMarkdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isInline() {
    		throw new Error("<SvelteMarkdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isInline(value) {
    		throw new Error("<SvelteMarkdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Viewer.svelte generated by Svelte v3.44.3 */

    const { console: console_1$1 } = globals;
    const file$2 = "src/Viewer.svelte";

    // (55:0) {#if $haspage}
    function create_if_block$1(ctx) {
    	let div;
    	let contentcontrols;
    	let t0;
    	let infobar;
    	let t1;
    	let sveltemarkdown;
    	let current;
    	contentcontrols = new ContentControls({ $$inline: true });
    	infobar = new Infobar({ $$inline: true });

    	sveltemarkdown = new SvelteMarkdown({
    			props: {
    				source: /*$page*/ ctx[2].val.body,
    				renderers: /*renderers*/ ctx[7],
    				options: /*options*/ ctx[6]
    			},
    			$$inline: true
    		});

    	sveltemarkdown.$on("parsed", /*onparse*/ ctx[8]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(contentcontrols.$$.fragment);
    			t0 = space();
    			create_component(infobar.$$.fragment);
    			t1 = space();
    			create_component(sveltemarkdown.$$.fragment);
    			attr_dev(div, "class", "rendered");
    			add_location(div, file$2, 55, 2, 1491);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(contentcontrols, div, null);
    			append_dev(div, t0);
    			mount_component(infobar, div, null);
    			append_dev(div, t1);
    			mount_component(sveltemarkdown, div, null);
    			/*div_binding*/ ctx[9](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const sveltemarkdown_changes = {};
    			if (dirty & /*$page*/ 4) sveltemarkdown_changes.source = /*$page*/ ctx[2].val.body;
    			sveltemarkdown.$set(sveltemarkdown_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contentcontrols.$$.fragment, local);
    			transition_in(infobar.$$.fragment, local);
    			transition_in(sveltemarkdown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contentcontrols.$$.fragment, local);
    			transition_out(infobar.$$.fragment, local);
    			transition_out(sveltemarkdown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(contentcontrols);
    			destroy_component(infobar);
    			destroy_component(sveltemarkdown);
    			/*div_binding*/ ctx[9](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(55:0) {#if $haspage}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$haspage*/ ctx[1] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$haspage*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$haspage*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $rc;
    	let $haspage;
    	let $page;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Viewer', slots, []);
    	const rc = getContext('rc');
    	validate_store(rc, 'rc');
    	component_subscribe($$self, rc, value => $$invalidate(13, $rc = value));
    	const haspage = getContext('haspage');
    	validate_store(haspage, 'haspage');
    	component_subscribe($$self, haspage, value => $$invalidate(1, $haspage = value));
    	const page = getContext('page');
    	validate_store(page, 'page');
    	component_subscribe($$self, page, value => $$invalidate(2, $page = value));
    	const setTokens = getContext('setTokens');
    	const setPageinfo = getContext('setPageinfo');
    	marked.use({ extensions: wmd });
    	const options = marked.defaults;
    	const renderers = { link: LinkShim, cpblink: CPBLinkShim };
    	let body;
    	let wc = 0;
    	let links = 0;
    	let readTime = '';
    	let info = null;

    	const countlinks = tokens => {
    		tokens.forEach(token => {
    			if (token.type == 'cpblink') links += 1;
    			if (token.tokens) countlinks(token.tokens);
    		});
    	};

    	function onparse(e) {
    		links = 0;
    		console.log(e.detail.tokens);
    		setTokens(e.detail.tokens);
    		const txt = htmlToText.convert(body.innerHTML);
    		wc = txt.trim().split(/\s+/).length;
    		const m = wc / $rc.readSpeed;
    		if (m < 2) readTime = 'a minute'; else readTime = `${Math.ceil(m)} minutes`;
    		countlinks(e.detail.tokens);
    		setPageinfo(wc, readTime, links);
    	}

    	onMount(() => console.log('bar'));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Viewer> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			body = $$value;
    			$$invalidate(0, body);
    		});
    	}

    	$$self.$capture_state = () => ({
    		Link: Link$1,
    		LinkShim,
    		CPBLinkShim,
    		ContentControls,
    		Infobar,
    		marked,
    		convert: htmlToText.convert,
    		getContext,
    		extensions: wmd,
    		rc,
    		haspage,
    		page,
    		setTokens,
    		setPageinfo,
    		SvelteMarkdown,
    		options,
    		renderers,
    		body,
    		wc,
    		links,
    		readTime,
    		info,
    		countlinks,
    		onparse,
    		onMount,
    		$rc,
    		$haspage,
    		$page
    	});

    	$$self.$inject_state = $$props => {
    		if ('body' in $$props) $$invalidate(0, body = $$props.body);
    		if ('wc' in $$props) wc = $$props.wc;
    		if ('links' in $$props) links = $$props.links;
    		if ('readTime' in $$props) readTime = $$props.readTime;
    		if ('info' in $$props) info = $$props.info;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		body,
    		$haspage,
    		$page,
    		rc,
    		haspage,
    		page,
    		options,
    		renderers,
    		onparse,
    		div_binding
    	];
    }

    class Viewer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Viewer",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src/PageForm.svelte generated by Svelte v3.44.3 */
    const file$1 = "src/PageForm.svelte";

    // (18:0) <FB vert zero form expand c="editor-area">
    function create_default_slot$1(ctx) {
    	let div0;
    	let t0;
    	let textarea;
    	let t1;
    	let div1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			textarea = element("textarea");
    			t1 = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "editor-rule");
    			add_location(div0, file$1, 18, 2, 524);
    			attr_dev(textarea, "class", "main-editor");
    			attr_dev(textarea, "spellcheck", "false");
    			add_location(textarea, file$1, 19, 2, 558);
    			attr_dev(div1, "class", "editor-rule bottom-rule");
    			add_location(div1, file$1, 20, 2, 639);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, textarea, anchor);
    			set_input_value(textarea, /*body*/ ctx[0]);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);

    			if (!mounted) {
    				dispose = listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[4]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*body*/ 1) {
    				set_input_value(textarea, /*body*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(textarea);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(18:0) <FB vert zero form expand c=\\\"editor-area\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let fb;
    	let current;

    	fb = new FB({
    			props: {
    				vert: true,
    				zero: true,
    				form: true,
    				expand: true,
    				c: "editor-area",
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fb.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fb, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const fb_changes = {};

    			if (dirty & /*$$scope, body*/ 2049) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fb, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $draft;
    	let $page;
    	let $loc;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PageForm', slots, []);
    	const page = getContext('page');
    	validate_store(page, 'page');
    	component_subscribe($$self, page, value => $$invalidate(6, $page = value));
    	const draft = getContext('draft');
    	validate_store(draft, 'draft');
    	component_subscribe($$self, draft, value => $$invalidate(5, $draft = value));
    	const postdraft = getContext('postdraft');
    	const loc = getContext('loc');
    	validate_store(loc, 'loc');
    	component_subscribe($$self, loc, value => $$invalidate(7, $loc = value));
    	let namespace = $page.val ? $page.val.namespace : $loc.namespace;
    	let title = $page.val ? $page.val.title : $loc.title;
    	let body = $page.val ? $page.val.body : '';
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PageForm> was created with unknown prop '${key}'`);
    	});

    	function textarea_input_handler() {
    		body = this.value;
    		$$invalidate(0, body);
    	}

    	$$self.$capture_state = () => ({
    		Link: Link$1,
    		FB,
    		getContext,
    		page,
    		draft,
    		postdraft,
    		loc,
    		namespace,
    		title,
    		body,
    		$draft,
    		$page,
    		$loc
    	});

    	$$self.$inject_state = $$props => {
    		if ('namespace' in $$props) $$invalidate(9, namespace = $$props.namespace);
    		if ('title' in $$props) $$invalidate(10, title = $$props.title);
    		if ('body' in $$props) $$invalidate(0, body = $$props.body);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*body*/ 1) {
    			set_store_value(draft, $draft = { namespace, title, body }, $draft);
    		}
    	};

    	return [body, page, draft, loc, textarea_input_handler];
    }

    class PageForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PageForm",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/Main.svelte generated by Svelte v3.44.3 */

    const { Object: Object_1, console: console_1, document: document_1, window: window_1 } = globals;
    const file = "src/Main.svelte";

    // (990:2) <svelte:fragment slot="inner">
    function create_inner_slot(ctx) {
    	let loadingscreen;
    	let current;
    	loadingscreen = new LoadingScreen({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loadingscreen.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loadingscreen, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loadingscreen.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loadingscreen.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loadingscreen, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_inner_slot.name,
    		type: "slot",
    		source: "(990:2) <svelte:fragment slot=\\\"inner\\\">",
    		ctx
    	});

    	return block;
    }

    // (995:2) {#if $uc.debug}
    function create_if_block(ctx) {
    	let debugger_1;
    	let current;
    	debugger_1 = new Debugger({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(debugger_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(debugger_1, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(debugger_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(debugger_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(debugger_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(995:2) {#if $uc.debug}",
    		ctx
    	});

    	return block;
    }

    // (994:1) <FB vert c="cpb-main" ghost={!$booted} flex={$ui >= 3}>
    function create_default_slot_1(ctx) {
    	let t0;
    	let headframe;
    	let t1;
    	let contents;
    	let current;
    	let if_block = /*$uc*/ ctx[5].debug && create_if_block(ctx);
    	headframe = new Headframe({ $$inline: true });
    	let contents_props = {};
    	contents = new Contents({ props: contents_props, $$inline: true });
    	/*contents_binding*/ ctx[63](contents);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			create_component(headframe.$$.fragment);
    			t1 = space();
    			create_component(contents.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(headframe, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(contents, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$uc*/ ctx[5].debug) {
    				if (if_block) {
    					if (dirty[0] & /*$uc*/ 32) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t0.parentNode, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const contents_changes = {};
    			contents.$set(contents_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(headframe.$$.fragment, local);
    			transition_in(contents.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(headframe.$$.fragment, local);
    			transition_out(contents.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(headframe, detaching);
    			if (detaching) detach_dev(t1);
    			/*contents_binding*/ ctx[63](null);
    			destroy_component(contents, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(994:1) <FB vert c=\\\"cpb-main\\\" ghost={!$booted} flex={$ui >= 3}>",
    		ctx
    	});

    	return block;
    }

    // (988:0) <FB center {c} rel>
    function create_default_slot(ctx) {
    	let r2hider;
    	let t0;
    	let fb;
    	let t1;
    	let wideui;
    	let current;

    	r2hider = new R2Hider({
    			props: {
    				hide: !/*$booted*/ ctx[8],
    				hyper: true,
    				$$slots: { inner: [create_inner_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fb = new FB({
    			props: {
    				vert: true,
    				c: "cpb-main",
    				ghost: !/*$booted*/ ctx[8],
    				flex: /*$ui*/ ctx[3] >= 3,
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	wideui = new WideUI({
    			props: { ghost: !/*$booted*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(r2hider.$$.fragment);
    			t0 = space();
    			create_component(fb.$$.fragment);
    			t1 = space();
    			create_component(wideui.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(r2hider, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(fb, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(wideui, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const r2hider_changes = {};
    			if (dirty[0] & /*$booted*/ 256) r2hider_changes.hide = !/*$booted*/ ctx[8];

    			if (dirty[5] & /*$$scope*/ 131072) {
    				r2hider_changes.$$scope = { dirty, ctx };
    			}

    			r2hider.$set(r2hider_changes);
    			const fb_changes = {};
    			if (dirty[0] & /*$booted*/ 256) fb_changes.ghost = !/*$booted*/ ctx[8];
    			if (dirty[0] & /*$ui*/ 8) fb_changes.flex = /*$ui*/ ctx[3] >= 3;

    			if (dirty[0] & /*contentscmp, $uc*/ 96 | dirty[5] & /*$$scope*/ 131072) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);
    			const wideui_changes = {};
    			if (dirty[0] & /*$booted*/ 256) wideui_changes.ghost = !/*$booted*/ ctx[8];
    			wideui.$set(wideui_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(r2hider.$$.fragment, local);
    			transition_in(fb.$$.fragment, local);
    			transition_in(wideui.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(r2hider.$$.fragment, local);
    			transition_out(fb.$$.fragment, local);
    			transition_out(wideui.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(r2hider, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(fb, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(wideui, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(988:0) <FB center {c} rel>",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let title_value;
    	let style_1;
    	let t1;
    	let div;
    	let fb;
    	let current;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowresize*/ ctx[61]);
    	document_1.title = title_value = /*doctitle*/ ctx[7];

    	fb = new FB({
    			props: {
    				center: true,
    				c: /*c*/ ctx[0],
    				rel: true,
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			style_1 = element("style");
    			style_1.textContent = ":root {\n\t\t}";
    			t1 = space();
    			div = element("div");
    			create_component(fb.$$.fragment);
    			add_location(style_1, file, 980, 1, 22291);
    			attr_dev(div, "class", "cpb-shell");
    			toggle_class(div, "darkmode", /*$usedark*/ ctx[2]);
    			add_location(div, file, 986, 0, 22357);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document_1.head, style_1);
    			/*style_1_binding*/ ctx[62](style_1);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(fb, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window_1, "keydown", /*keydown*/ ctx[44], false, false, false),
    					listen_dev(window_1, "keyup", /*keyup*/ ctx[45], false, false, false),
    					listen_dev(window_1, "resize", /*onwindowresize*/ ctx[61])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*doctitle*/ 128) && title_value !== (title_value = /*doctitle*/ ctx[7])) {
    				document_1.title = title_value;
    			}

    			const fb_changes = {};
    			if (dirty[0] & /*c*/ 1) fb_changes.c = /*c*/ ctx[0];

    			if (dirty[0] & /*$booted, $ui, contentscmp, $uc*/ 360 | dirty[5] & /*$$scope*/ 131072) {
    				fb_changes.$$scope = { dirty, ctx };
    			}

    			fb.$set(fb_changes);

    			if (dirty[0] & /*$usedark*/ 4) {
    				toggle_class(div, "darkmode", /*$usedark*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fb.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fb.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(style_1);
    			/*style_1_binding*/ ctx[62](null);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(fb);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $pageinfo;
    	let $uiname;
    	let $finished;
    	let $loading;
    	let $usedark;
    	let $ui;
    	let $ww;
    	let $uc;
    	let $loc;
    	let $rc;
    	let $path;
    	let $trail;
    	let $links;
    	let $modifiers;
    	let $linkmap;
    	let $title;
    	let $space;
    	let $page;
    	let $haspage;
    	let $hash;
    	let $stem;
    	let $fresh;
    	let $gs;
    	let $hassess;
    	let $scrollinfo;
    	let $session;
    	let $haslogin;
    	let $editing;
    	let $creating;
    	let $state;
    	let $booted;
    	let $component;
    	let $hashistory;
    	let $history;
    	let $user;
    	let $hasuser;
    	let $tokens;
    	let $message;
    	let $aod;
    	let $draft;
    	let $wh;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Main', slots, []);
    	let booted = writable(false);
    	validate_store(booted, 'booted');
    	component_subscribe($$self, booted, value => $$invalidate(8, $booted = value));
    	let lut;
    	let rc$1 = writable(rc);
    	validate_store(rc$1, 'rc');
    	component_subscribe($$self, rc$1, value => $$invalidate(73, $rc = value));
    	let aod = writable(0);
    	validate_store(aod, 'aod');
    	component_subscribe($$self, aod, value => $$invalidate(98, $aod = value));
    	let links = writable([]);
    	validate_store(links, 'links');
    	component_subscribe($$self, links, value => $$invalidate(60, $links = value));
    	let linkmap = writable({});
    	validate_store(linkmap, 'linkmap');
    	component_subscribe($$self, linkmap, value => $$invalidate(75, $linkmap = value));
    	let path = writable(window.location.pathname + window.location.search + window.location.hash);
    	validate_store(path, 'path');
    	component_subscribe($$self, path, value => $$invalidate(58, $path = value));
    	let stem = writable(window.location.pathname + window.location.search);
    	validate_store(stem, 'stem');
    	component_subscribe($$self, stem, value => $$invalidate(81, $stem = value));
    	let hash = writable(window.location.hash);
    	validate_store(hash, 'hash');
    	component_subscribe($$self, hash, value => $$invalidate(80, $hash = value));
    	let loc = writable({});
    	validate_store(loc, 'loc');
    	component_subscribe($$self, loc, value => $$invalidate(57, $loc = value));
    	let fresh = writable(true);
    	validate_store(fresh, 'fresh');
    	component_subscribe($$self, fresh, value => $$invalidate(82, $fresh = value));
    	let session = writable({});
    	validate_store(session, 'session');
    	component_subscribe($$self, session, value => $$invalidate(86, $session = value));
    	let message = writable({});
    	validate_store(message, 'message');
    	component_subscribe($$self, message, value => $$invalidate(97, $message = value));
    	let loading = writable(true);
    	validate_store(loading, 'loading');
    	component_subscribe($$self, loading, value => $$invalidate(56, $loading = value));
    	let finished = writable(false);
    	validate_store(finished, 'finished');
    	component_subscribe($$self, finished, value => $$invalidate(55, $finished = value));
    	let debug = writable(true);
    	let space = writable('');
    	validate_store(space, 'space');
    	component_subscribe($$self, space, value => $$invalidate(77, $space = value));
    	let title = writable('');
    	validate_store(title, 'title');
    	component_subscribe($$self, title, value => $$invalidate(76, $title = value));
    	let page = writable(null);
    	validate_store(page, 'page');
    	component_subscribe($$self, page, value => $$invalidate(78, $page = value));
    	let tokens = writable(null);
    	validate_store(tokens, 'tokens');
    	component_subscribe($$self, tokens, value => $$invalidate(96, $tokens = value));
    	let user = writable(null);
    	validate_store(user, 'user');
    	component_subscribe($$self, user, value => $$invalidate(94, $user = value));
    	let history = writable(null);
    	validate_store(history, 'history');
    	component_subscribe($$self, history, value => $$invalidate(93, $history = value));
    	let draft = writable(null);
    	validate_store(draft, 'draft');
    	component_subscribe($$self, draft, value => $$invalidate(99, $draft = value));
    	let trail = writable([]);
    	validate_store(trail, 'trail');
    	component_subscribe($$self, trail, value => $$invalidate(59, $trail = value));
    	let creating = writable(false);
    	validate_store(creating, 'creating');
    	component_subscribe($$self, creating, value => $$invalidate(89, $creating = value));
    	let editing = writable(false);
    	validate_store(editing, 'editing');
    	component_subscribe($$self, editing, value => $$invalidate(88, $editing = value));
    	let haspage = writable(false);
    	validate_store(haspage, 'haspage');
    	component_subscribe($$self, haspage, value => $$invalidate(79, $haspage = value));
    	let hashistory = writable(false);
    	validate_store(hashistory, 'hashistory');
    	component_subscribe($$self, hashistory, value => $$invalidate(92, $hashistory = value));
    	let hasuser = writable(false);
    	validate_store(hasuser, 'hasuser');
    	component_subscribe($$self, hasuser, value => $$invalidate(95, $hasuser = value));
    	let hassess = writable(null);
    	validate_store(hassess, 'hassess');
    	component_subscribe($$self, hassess, value => $$invalidate(84, $hassess = value));
    	let haslogin = writable(false);
    	validate_store(haslogin, 'haslogin');
    	component_subscribe($$self, haslogin, value => $$invalidate(87, $haslogin = value));

    	let uc = writable({
    		debug: false,
    		darkmode: false,
    		autodark: true
    	});

    	validate_store(uc, 'uc');
    	component_subscribe($$self, uc, value => $$invalidate(5, $uc = value));
    	setContext('booted', booted);
    	setContext('rc', rc$1);
    	setContext('aod', aod);
    	setContext('links', links);
    	setContext('linkmap', linkmap);
    	setContext('path', path);
    	setContext('loc', loc);
    	setContext('fresh', fresh);
    	setContext('session', session);
    	setContext('message', message);
    	setContext('loading', loading);
    	setContext('finished', finished);
    	setContext('debug', debug);
    	setContext('space', space);
    	setContext('title', title);
    	setContext('page', page);
    	setContext('tokens', tokens);
    	setContext('user', user);
    	setContext('history', history);
    	setContext('draft', draft);
    	setContext('trail', trail);
    	setContext('creating', creating);
    	setContext('editing', editing);
    	setContext('haspage', haspage);
    	setContext('hashistory', hashistory);
    	setContext('hasuser', hasuser);
    	setContext('hassess', hassess);
    	setContext('haslogin', haslogin);
    	setContext('uc', uc);

    	const handle = e => {
    		// XXX
    		throw e;
    	};

    	setContext('handle', handle);
    	const burl = () => `${$rc.proto}://${$rc.domain}${$rc.port ? ':' + $rc.port : ''}`;
    	const surl = () => `${burl()}/${$rc.syskey}`;
    	const aurl = () => `${surl()}/${$rc.defapi}`;

    	const cmdu = (c, ...a) => {
    		let o = '';

    		if (a.length) {
    			if (typeof a[a.length - 1] == 'object') {
    				o = util.mkq(a.pop());
    			}

    			a = `/${a.join('/')}`;
    		} else a = '';

    		return `${aurl()}/${c}${a}${o}`;
    	};

    	const grab = (...a) => {
    		const url = cmdu(...a);

    		return fetch(url).then(res => res.json()).then(r => {
    			console.log(`GET ${url}`);
    			console.log(r);
    			return r;
    		});
    	};

    	// post('update', ns, t, {title, body})
    	const post = (...a) => {
    		const body = a.pop();
    		const url = cmdu(...a);
    		console.log(`POST ${url}`);

    		return fetch(url, {
    			method: 'POST',
    			body: JSON.stringify(body),
    			headers: { 'Content-Type': 'application/json' }
    		}).then(res => res.json()).then(r => {
    			return r;
    		});
    	};

    	setContext('grab', grab);
    	setContext('post', post);

    	const setTokens = t => {
    		set_store_value(tokens, $tokens = t, $tokens);
    	};

    	setContext('setTokens', setTokens);

    	const postdraft = () => {
    		const a = $loc.uuid ? [$loc.uuid] : [$loc.namespace, $loc.title];
    		const c = $loc.opt.edit ? 'update' : 'get';

    		return post(c, ...a, $draft).then(res => {
    			set_store_value(draft, $draft = null, $draft);
    			if (!!$creating) set_store_value(aod, $aod = Date.now(), $aod);
    			hold(`Created '${$gs.tag()}'`);
    		}).catch(e => handle(e));
    	};

    	const postuser = b => {
    		post('register', b).then(res => {
    			hold(`Created user '${b.handle}'`);
    		}).catch(e => handle(e));
    	};

    	setContext('postdraft', postdraft);
    	setContext('postuser', postuser);

    	const login = b => {
    		const start = $session.val.handle;

    		return post('login', b).then(res => {
    			setsession(res);

    			if (res.err == 0) {
    				if (start != $session.val.handle) {
    					hold(`Logged in as '${$session.val.handle}'`);
    				}

    				return true;
    			} else {
    				if (res.err == 5) hold(res.val.join('\n')); else hold(`Sorry, an error occurred.`);
    				return false;
    			}
    		}).catch(e => handle(e));
    	};

    	const register = b => {
    		return post('register', b).then(res => {
    			getsession();

    			if (res.err == 0) {
    				hold(`Registered as '${b.handle}'`);
    				return true;
    			} else {
    				if (res.err == 5) {
    					hold(res.val.join('\n'));
    				} else {
    					hold(`Sorry, an error occurred.`);
    				}

    				return false;
    			}
    		}).catch(e => handle(e));
    	};

    	const logout = () => {
    		return post('logout', {}).then(r => {
    			getsession().then(s => {
    				if ($hassess) hold(`Logged out`);
    			});
    		});
    	};

    	setContext('login', login);
    	setContext('register', register);
    	setContext('logout', logout);

    	const fortune = [
    		"a healthy air stinks of stupidity",
    		"burning burning burning burning",
    		"because it is my heart",
    		"these fragments i have shored against my ruins",
    		"where days are numbered",
    		"devised by some ancient dread"
    	];

    	let heldmsg = null;

    	const unhold = (...args) => {
    		if (heldmsg) {
    			print(...heldmsg);
    			heldmsg = null;
    		} else {
    			print(...args);
    		}
    	};

    	const unmsg = () => {
    		print(util.sample(fortune), 'z', 0);
    	};

    	let msgt;

    	const mkmsg = (text = '', level = 0, time = 3000) => {
    		return { text, level, time };
    	};

    	const hold = (...args) => {
    		heldmsg = args;
    	};

    	const msg = (...args) => {
    		if (!$finished) hold(...args); else print(...args);
    	};

    	const print = (...args) => {
    		set_store_value(message, $message = mkmsg(...args), $message);
    		console.log(`MESSAGE: ${$message.text}`);
    		if (msgt) clearTimeout(msgt);
    		if ($message.time) msgt = setTimeout(unmsg, $message.time);
    	};

    	setContext('msg', msg);

    	const fullsearch = (q, o = {}) => {
    		return grab('search', q, o).catch(e => handle(e));
    	};

    	setContext('fullsearch', fullsearch);

    	const getconf = k => {
    		return $uc[k];
    	};

    	const setconf = (k, v) => {
    		set_store_value(uc, $uc[k] = v, $uc);
    		if ($haslogin) saveconf({ [k]: v }); else savels();
    	};

    	const saveconf = c => {
    		post('config', $session.val.handle, c).then(c => {
    			if (c.err == 0) set_store_value(uc, $uc = c.val, $uc);
    		}).catch(e => handle(e));
    	};

    	const savels = () => {
    		localStorage.setItem('CPBUC', JSON.stringify($uc));
    	};

    	const loadls = () => {
    		set_store_value(uc, $uc = JSON.parse(localStorage.getItem('CPBUC')), $uc);
    	};

    	const setsession = s => {
    		set_store_value(session, $session = s, $session);
    		set_store_value(hassess, $hassess = !!$session && $session.err == 0 && !!$session.val, $hassess);
    		set_store_value(haslogin, $haslogin = !!$hassess && !!$session.val.login, $haslogin);

    		if ($haslogin) {
    			set_store_value(uc, $uc = $session.val.config, $uc);
    		} else {
    			if (localStorage.getItem('CPBUC')) loadls(); else savels();
    		}

    		console.log(`LAUNCH: Got session (${$hassess}) ${$session.val.uuid}`);
    	};

    	const getsession = () => {
    		return grab('session').then(s => setsession(s));
    	};

    	const cleardata = (to = {}) => {
    		set_store_value(tokens, $tokens = null, $tokens);
    		if (to.user) set_store_value(user, $user = to.user, $user); else if ($user) set_store_value(user, $user = null, $user);
    		if (to.page) set_store_value(page, $page = to.page, $page); else if ($page) set_store_value(page, $page = null, $page);
    		if (to.history) set_store_value(history, $history = to.history, $history); else if ($history) set_store_value(history, $history = null, $history);
    		checkdata();
    	};

    	const checkresp = r => !!r && r.err == 0 && !!r.val;

    	const checkdata = () => {
    		set_store_value(hasuser, $hasuser = checkresp($user), $hasuser);
    		set_store_value(haspage, $haspage = checkresp($page), $haspage);
    		set_store_value(hashistory, $hashistory = checkresp($history), $hashistory);
    	};

    	const errors = { 401: E401, 404: E404, 500: E500 };

    	const geterr = n => {
    		if (errors[n]) return errors[n]; else return errors[500];
    	};

    	const blankstate = () => {
    		return {
    			editing: false,
    			creating: false,
    			error: 0,
    			current: false,
    			head: false,
    			old: false,
    			anchor: false,
    			system: false,
    			history: false,
    			pageperm: false,
    			verperm: false,
    			label: 'BLANK',
    			cmp: null,
    			namespace: null,
    			title: null,
    			loading: false,
    			building: false,
    			finished: false,
    			loadstart: 0,
    			loadtime: 0,
    			buildstart: 0,
    			buildtime: 0,
    			finishtime: 0,
    			fadestart: 0,
    			fadetime: 0,
    			editable: false,
    			historical: false,
    			byid: false
    		};
    	};

    	const sidestate = () => {
    		return Object.assign({}, $state);
    	};

    	let state = writable(blankstate());
    	validate_store(state, 'state');
    	component_subscribe($$self, state, value => $$invalidate(90, $state = value));
    	setContext('state', state);

    	class Route {
    		constructor(cmp, cnd = () => true) {
    			this.cmp = cmp;
    			this.cnd = cnd;
    		}

    		resolve() {
    			const r = this.cnd();

    			if (typeof r == 'number') {
    				return new Resolution(r);
    			} else if (r === true) {
    				return new Resolution(this.cmp);
    			} else {
    				return new Resolution(500);
    			}
    		}
    	}

    	class Router {
    		constructor(routes) {
    			this.routes = routes;
    		}

    		has(p) {
    			return !!this.routes[p];
    		}

    		nav(p) {
    			if (this.has(p)) return this.routes[p].resolve(); else return new Resolution(404);
    		}
    	}

    	class Resolution {
    		constructor(cmp) {
    			if (typeof cmp == 'number') {
    				this.err = cmp;
    				this.cmp = geterr(this.err);
    			} else {
    				this.err = 0;
    				this.cmp = cmp;
    			}
    		}
    	}

    	const cpbspace = new Router({
    			login: new Route(Login, () => !$haslogin || 401),
    			register: new Route(Login,
    			() => {
    					if ($rc.singleuser) return 404; else if (!$haslogin) return true; else return 401;
    				}),
    			user: new Route(User, () => !!$haslogin || 401),
    			search: new Route(Search),
    			test: new Route(Test),
    			forms: new Route(TestForms),
    			links: new Route(TestLinks)
    		});

    	setContext('cpbspace', cpbspace);

    	const loadstate = () => {
    		const s = blankstate();
    		s.loading = true;
    		s.label = 'LOADING';
    		s.loadstart = Date.now();

    		if ($loc.uuid) s.title = $loc.uuid; else {
    			s.namespace = $loc.namespace;
    			s.title = $loc.title;
    		}

    		set_store_value(state, $state = s, $state);
    	};

    	let component = writable(null);
    	validate_store(component, 'component');
    	component_subscribe($$self, component, value => $$invalidate(91, $component = value));
    	setContext('component', component);

    	const buildstate = () => {
    		console.log($hashistory);
    		const s = sidestate();
    		s.loading = false;
    		s.loadtime = Date.now() - s.loadstart;

    		if ($haspage && $loc.uuid) {
    			if ($loc.uuid == $page.val.pageUuid) s.pageperm = true; else if ($loc.uuid == $page.val.uuid) s.verperm = true;
    		}

    		if ($hashistory && $loc.opt.history) {
    			s.cmp = History;
    			s.history = true;
    			s.label = 'HISTORY';
    		} else if ($haspage && $loc.opt.edit) {
    			if ($page.val.historical) {
    				s.cmp = geterr(401);
    				s.error = 401;
    				s.label = 'ERROR';
    			} else {
    				if ($haslogin) {
    					s.cmp = PageForm;
    					s.editing = true;
    					s.label = 'EDIT';
    				} else {
    					s.cmp = geterr(401);
    					s.error = 401;
    					s.label = 'ERROR';
    				}
    			}
    		} else if ($loc.uuid) {
    			if (!$haspage || $page && $page.err) {
    				s.cmp = geterr(404);
    				s.error = 404;
    				s.label = 'ERROR';
    			} else {
    				if ($haspage && $loc.uuid == $page.val.pageUuid) {
    					s.cmp = Viewer;
    					s.head = true;
    					s.label = 'HEAD';
    					s.editable = true;
    				} else if ($haspage && $page.val.nextUuid == null) {
    					s.cmp = Viewer;
    					s.current = true;
    					s.label = 'CURRENT';
    					s.editable = true;
    				} else {
    					s.cmp = Viewer;
    					s.old = true;
    					s.label = 'OLD';
    					s.historical = true;
    				}

    				s.byid = true;
    				s.content = true;
    			}
    		} else if ($page && $page.err == 1) {
    			if ($haslogin) {
    				s.cmp = PageForm;
    				s.creating = true;
    				s.label = 'NEW';
    			} else {
    				s.cmp = geterr(404);
    				s.error = 404;
    				s.label = 'ERROR';
    			}
    		} else if ($haspage) {
    			s.cmp = Viewer;
    			s.anchor = true;
    			s.label = 'ANCHOR';
    			s.content = true;
    			s.editable = true;
    		} else if ($loc.namespace == $rc.syskey) {
    			const res = cpbspace.nav($loc.title);

    			if (res.err > 0) {
    				s.label = 'ERROR';
    				s.error = res.err;
    				s.cmp = geterr(res.err);
    			} else {
    				s.system = true;
    				s.label = 'SYSTEM';
    				s.cmp = res.cmp;
    			}
    		} else {
    			s.cmp = geterr(500);
    			s.error = 500;
    			s.label = 'ERROR';
    		}

    		if ($haspage) {
    			s.namespace = $page.val.namespace;
    			s.title = $page.val.title;
    		} else {
    			s.namespace = $loc.namespace;
    			s.title = $loc.title;
    		}

    		s.building = true;
    		s.buildstart = Date.now();
    		set_store_value(component, $component = s.cmp, $component);
    		set_store_value(state, $state = s, $state);
    		set_store_value(creating, $creating = $state.creating, $creating);
    		set_store_value(editing, $editing = $state.editing, $editing);
    	};

    	const finishstate = () => {
    		const s = sidestate();
    		const n = Date.now();
    		s.building = false;
    		s.buildtime = n - s.buildstart;
    		s.fadestart = n;
    		set_store_value(state, $state = s, $state);
    	};

    	const finalstate = () => {
    		const s = sidestate();
    		const n = Date.now();
    		s.finishtime = n - s.loadstart;
    		s.fadetime = n - s.fadestart;
    		s.finished = true;
    		set_store_value(state, $state = s, $state);
    	};

    	const loadend = () => {
    		console.log('CPB LOAD END');
    		parsenst();
    		buildstate();
    		renderstart = Date.now();
    		set_store_value(loading, $loading = false, $loading);
    		set_store_value(fresh, $fresh = false, $fresh); // XXX there's already a 'booted' variable
    	};

    	const endboot = () => {
    		msg('CPB BOOTED');
    		console.log('CPB BOOTED');
    		set_store_value(booted, $booted = true, $booted);
    	};

    	const finishinner = () => {
    		finalstate();
    		set_store_value(finished, $finished = true, $finished);
    		console.log('FINISHED');
    		rendertime = Date.now() - renderstart;

    		if (!$booted) {
    			if ($state.finishtime < $rc.fadein) {
    				console.log('FADING');
    				setTimeout(endboot, $rc.fadein - $state.finishtime);
    			} else {
    				console.log(`NOT FADING ${$state.finishtime} (${rc$1.fadein})`);
    				endboot();
    			}
    		}

    		unhold('FINISHED', 0, 2000);
    	};

    	const finishload = () => {
    		console.log('PRE-FINISH');
    		finishstate();
    		const d = Date.now() - $state.loadstart;
    		if (d >= $rc.fade) finishinner(); else setTimeout(finishinner, $rc.fade - d);
    	};

    	setContext('finishload', finishload);

    	const preload = p => {
    		console.log('CPB PRE-LOAD');
    		set_store_value(loc, $loc = parseloc(p), $loc);

    		if ($loc.load) load(); else if ($loc.cmd) {
    			const e = document.getElementById($loc.cmd);

    			if (e) {
    				e.scrollIntoView({
    					behavior: "smooth",
    					block: "start",
    					inline: "nearest"
    				});

    				e.focus({ preventScroll: true });
    			}
    		} else {
    			unhold('FINISHED', 0, 2000);
    		}
    	};

    	let loadstart = 0;
    	let renderstart = 0;
    	let loadtime = 0;
    	let rendertime = 0;

    	const load = p => {
    		console.log('CPB LOAD');
    		loadstart = Date.now();
    		loadstate();
    		set_store_value(creating, $creating = false, $creating);
    		set_store_value(editing, $editing = false, $editing);
    		set_store_value(loading, $loading = true, $loading);
    		set_store_value(finished, $finished = false, $finished);
    		cleardata();
    		let after = false;

    		if ($loc.namespace == $rc.syskey) {
    			if ($loc.title == 'user') {
    				let u = $loc.sub[0];
    				if (!u && !!$haslogin) u = $session.val.handle;

    				if (u) {
    					after = grab('user', u).then(user => {
    						cleardata({ user });
    					});
    				}
    			}
    		} else if ($loc.opt.history) {
    			const a = $loc.uuid ? [$loc.uuid] : [$loc.namespace, $loc.title];
    			const o = {};
    			if (!!$loc.opt.pg && $loc.opt.pg != $rc.historyDefaults.pg) o.pg = $loc.opt.pg;
    			if (!!$loc.opt.sz && $loc.opt.sz != $rc.historyDefaults.sz) o.sz = $loc.opt.sz;

    			if ($loc.title || $loc.namespace || $loc.uuid) {
    				const a2 = $loc.uuid
    				? ['uuid', $loc.uuid]
    				: ['get', $loc.namespace, $loc.title];

    				after = grab(...a2).then(async page => {
    					if (page.val) page.val.historical = !!page.val.nextUuid;
    					const history = await grab('history', ...a, o);
    					cleardata({ page, history });
    				});
    			} else {
    				after = grab('history', ...a, o).then(history => {
    					cleardata({ history });
    				});
    			}
    		} else if ($loc.title || $loc.namespace || $loc.uuid) {
    			const a = $loc.uuid
    			? ['uuid', $loc.uuid]
    			: ['get', $loc.namespace, $loc.title];

    			after = grab(...a).then(page => {
    				if (page.val) page.val.historical = !!page.val.nextUuid;
    				cleardata({ page });
    			});
    		}

    		if (after) {
    			after.then(r => {
    				loadend();
    			}).catch(e => handle(e));
    		} else {
    			loadend();
    		}
    	};

    	let contentscmp;

    	const scrolltop = () => {
    		if (contentscmp) contentscmp.top();
    	};

    	setContext('scrolltop', scrolltop);

    	let scrollinfo = writable({
    		ch: 0,
    		sh: 0,
    		sy: 0,
    		scrollable: false,
    		scrolled: false
    	});

    	validate_store(scrollinfo, 'scrollinfo');
    	component_subscribe($$self, scrollinfo, value => $$invalidate(85, $scrollinfo = value));
    	setContext('scrollinfo', scrollinfo);

    	const updatescroll = (ch, sh, sy, scrollable, scrolled) => {
    		set_store_value(scrollinfo, $scrollinfo = { ch, sh, sy, scrollable, scrolled }, $scrollinfo);
    	};

    	setContext('updatescroll', updatescroll);

    	const reload = () => {
    		launch();
    	};

    	setContext('reload', reload);

    	const launch = p => {
    		console.log('COMMONPLACE BOOK: LAUNCH');
    		print('LOADING', 0, 0);
    		if ($hassess) preload($path); else getsession().then(s => preload($path));
    	};

    	const drophash = () => {
    		if ($hash) $gs.goto($stem);
    	};

    	setContext('drophash', drophash);

    	const parseloc = p => {
    		const loc = {
    			namespace: null,
    			title: null,
    			uuid: null,
    			sub: [],
    			cmd: null,
    			opt: {},
    			load: true
    		};

    		p = p.split('#');
    		if (!$fresh && p[0] == $stem) loc.load = false;
    		set_store_value(stem, $stem = p[0] || null, $stem);
    		set_store_value(hash, $hash = p[1] || null, $hash);
    		loc.cmd = $hash;
    		p = p[0].split('?');

    		if (p[1]) {
    			loc.opt = util.mask(util.rq('?' + p[1]), {
    				pg: undefined,
    				sz: undefined,
    				inf: undefined,
    				inh: undefined,
    				edit: undefined,
    				history: undefined
    			});
    		}

    		p = p[0];
    		if (p[0] == '/') p = p.slice(1);
    		p = p.split('/');
    		const ns = p[0];
    		const t = p[1];
    		const args = p.slice(2);
    		loc.sub = args;
    		let u;

    		if (ns.startsWith($rc.homekey)) {
    			loc.namespace = $rc.syskey;
    			loc.title = 'user';
    			u = ns.slice(1);
    			if (u) loc.sub = [u];
    		} else if (ns == $rc.syskey) {
    			loc.namespace = $rc.syskey;
    			if (t) loc.title = t;
    		} else {
    			if (util.isuu(ns)) {
    				loc.uuid = ns.toLowerCase();
    			} else if (ns == '') {
    				loc.namespace = $rc.defns;
    				loc.title = $rc.deftitle;
    			} else if (!t) {
    				loc.namespace = ns;
    				loc.title = $rc.deftitle;
    			} else {
    				loc.namespace = ns;
    				loc.title = t;
    			}
    		}

    		return loc;
    	};

    	const parsenst = () => {
    		let ns, t;

    		if ($haspage) {
    			ns = $page.val.namespace;
    			t = $page.val.title;
    		} else if ($loc.uuid) {
    			ns = 'ID';
    			t = $loc.uuid;
    		} else if ($loc.namespace || $loc.title) {
    			ns = $loc.namespace || '';
    			t = $loc.title || '';
    		} else {
    			ns = 'SPECIAL';
    			t = $loc.special.toUpperCase();
    		}

    		set_store_value(space, $space = ns, $space);
    		set_store_value(title, $title = t, $title);
    	};

    	const linkupdate = links => {
    		if (!links.length) return;
    		const titles = [...new Set(links)].join('+');
    		grab('missing', titles).then(res => set_store_value(linkmap, $linkmap = res, $linkmap)).catch(e => handle(e));
    	};

    	const mklut = links => {
    		if (lut) clearTimeout(lut);
    		lut = setTimeout(linkupdate, 200, links);
    	};

    	const onpop = e => {
    		set_store_value(path, $path = window.location.pathname, $path);
    	};

    	const modifiers = writable({ Shift: false, Alt: false, Control: false });
    	validate_store(modifiers, 'modifiers');
    	component_subscribe($$self, modifiers, value => $$invalidate(74, $modifiers = value));
    	setContext('modifiers', modifiers);
    	const setmod = n => set_store_value(modifiers, $modifiers[n] = true, $modifiers);
    	const unsetmod = n => set_store_value(modifiers, $modifiers[n] = false, $modifiers);

    	const controls = (m, e) => {
    		if (m.Alt && e.code == 'KeyD') {
    			setconf('debug', !getconf('debug'));
    		} else if (m.Alt && e.code == 'KeyN') {
    			setconf('darkmode', !getconf('darkmode'));
    		} else if (m.Alt && e.code == 'KeyM') {
    			setconf('autodark', !getconf('autodark'));
    		} else if (m.Alt && e.code == 'KeyR') {
    			reload();
    		}
    	};

    	let controlset = controls;
    	const setcontrols = c => controlset = c ? c : controls;

    	const keydown = e => {
    		if ($modifiers.hasOwnProperty(e.key)) setmod(e.key); else controlset($modifiers, e);
    	};

    	const keyup = e => {
    		if ($modifiers.hasOwnProperty(e.key)) unsetmod(e.key);
    	};

    	setContext('setcontrols', setcontrols);

    	let gs = writable({
    		full: p => `${burl()}/${p}`,
    		goto: p => {
    			set_store_value(path, $path = p, $path);
    			window.history.pushState({}, $path, $path);
    		},
    		bounce: (d = '/') => {
    			set_store_value(path, $path = trail[1] ? trail[1] : d, $path);
    			window.history.pushState({}, $path, $path);
    		},
    		tag: () => {
    			return `${$loc.namespace}:${$loc.title}`;
    		},
    		bare: () => $path.split('#')[0],
    		cur: () => `${burl()}/${$path}`
    	});

    	validate_store(gs, 'gs');
    	component_subscribe($$self, gs, value => $$invalidate(83, $gs = value));
    	setContext('gs', gs);
    	window.onpopstate = onpop;
    	msg();
    	let doctitle = '';

    	const mktitle = () => {
    		let t = [$rc.title];
    		let p = [];
    		let a = [];

    		if ($loc.title) {
    			p.push($loc.namespace.toUpperCase());
    			p.push($loc.title);

    			if ($loc.cmd) {
    				a.push($loc.cmd.toUpperCase());
    			}
    		} else {
    			p.push('SPECIAL');
    			p.push($loc.special);

    			if ($loc.special == 'search' && $loc.query) {
    				a.push(`"${$loc.query}"`);
    			}
    		}

    		p = p.join(' ▸ ');
    		a = a.length ? `(${a.join(' ')})` : '';
    		$$invalidate(7, doctitle = [...t, p, a].join(' '));
    	};

    	let usedark = writable(false);
    	validate_store(usedark, 'usedark');
    	component_subscribe($$self, usedark, value => $$invalidate(2, $usedark = value));
    	setContext('usedark', usedark);
    	let c = [];

    	const mkc = () => {
    		const nc = ['cpb-ui'];
    		if (!!$loading) nc.push('cpb-loading'); else if (!$finished) nc.push('cpb-rendering'); else nc.push('cpb-finished');
    		nc.push(`${$uiname}-mode`);
    		$$invalidate(0, c = nc);
    	};

    	let ww = writable(0);
    	validate_store(ww, 'ww');
    	component_subscribe($$self, ww, value => $$invalidate(4, $ww = value));
    	let wh = writable(0);
    	validate_store(wh, 'wh');
    	component_subscribe($$self, wh, value => $$invalidate(9, $wh = value));
    	setContext('ww', ww);
    	setContext('wh', wh);
    	let style;
    	let measures = {};

    	const setcss = block => {
    		if (!style) return;
    		const conf = {};
    		block(conf);

    		Object.keys(conf).forEach(k => {
    			style.sheet.rules[0].style.setProperty(`--${k}`, `${conf[k]}px`);
    		});

    		return conf;
    	};

    	let ui = writable(2);
    	validate_store(ui, 'ui');
    	component_subscribe($$self, ui, value => $$invalidate(3, $ui = value));
    	let uiname = writable('base');
    	validate_store(uiname, 'uiname');
    	component_subscribe($$self, uiname, value => $$invalidate(54, $uiname = value));

    	const mkui = w => {
    		if (w >= measures.widex) return 3; else if (w >= measures.medx) return 2; else if (w >= measures.basereal) return 1; else return 0;
    	};

    	const uin = {
    		[-1]: 'mobile',
    		[+0]: 'base-min',
    		[+1]: 'base',
    		[+2]: 'medium',
    		[+3]: 'wide'
    	};

    	const mkuin = n => {
    		return uin[n] || 'base';
    	};

    	setContext('ui', ui);
    	setContext('uiname', uiname);
    	const pageinfo = writable({});
    	validate_store(pageinfo, 'pageinfo');
    	component_subscribe($$self, pageinfo, value => $$invalidate(72, $pageinfo = value));
    	setContext('pageinfo', pageinfo);

    	const setPageinfo = (wc, time, links) => {
    		set_store_value(pageinfo, $pageinfo = { wc, time, links }, $pageinfo);
    	};

    	setContext('setPageinfo', setPageinfo);
    	let ready = false;
    	setTimeout(() => ready = true, 2500);
    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Main> was created with unknown prop '${key}'`);
    	});

    	function onwindowresize() {
    		ww.set($ww = window_1.innerWidth);
    		wh.set($wh = window_1.innerHeight);
    	}

    	function style_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			style = $$value;
    			$$invalidate(1, style);
    		});
    	}

    	function contents_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			contentscmp = $$value;
    			$$invalidate(6, contentscmp);
    		});
    	}

    	$$self.$capture_state = () => ({
    		Link: Link$1,
    		FB,
    		Debugger,
    		Headframe,
    		Titleframe,
    		Bodyframe,
    		Footer,
    		R2,
    		R2Hider,
    		WideUI,
    		Contents,
    		LoadingScreen,
    		Login,
    		User,
    		Search,
    		Test,
    		TestForms,
    		TestLinks,
    		E401,
    		E404,
    		E500,
    		History,
    		Viewer,
    		PageForm,
    		setContext,
    		writable,
    		rco: rc,
    		util,
    		booted,
    		lut,
    		rc: rc$1,
    		aod,
    		links,
    		linkmap,
    		path,
    		stem,
    		hash,
    		loc,
    		fresh,
    		session,
    		message,
    		loading,
    		finished,
    		debug,
    		space,
    		title,
    		page,
    		tokens,
    		user,
    		history,
    		draft,
    		trail,
    		creating,
    		editing,
    		haspage,
    		hashistory,
    		hasuser,
    		hassess,
    		haslogin,
    		uc,
    		handle,
    		burl,
    		surl,
    		aurl,
    		cmdu,
    		grab,
    		post,
    		setTokens,
    		postdraft,
    		postuser,
    		login,
    		register,
    		logout,
    		fortune,
    		heldmsg,
    		unhold,
    		unmsg,
    		msgt,
    		mkmsg,
    		hold,
    		msg,
    		print,
    		fullsearch,
    		getconf,
    		setconf,
    		saveconf,
    		savels,
    		loadls,
    		setsession,
    		getsession,
    		cleardata,
    		checkresp,
    		checkdata,
    		errors,
    		geterr,
    		blankstate,
    		sidestate,
    		state,
    		Route,
    		Router,
    		Resolution,
    		cpbspace,
    		loadstate,
    		component,
    		buildstate,
    		finishstate,
    		finalstate,
    		loadend,
    		endboot,
    		finishinner,
    		finishload,
    		preload,
    		loadstart,
    		renderstart,
    		loadtime,
    		rendertime,
    		load,
    		contentscmp,
    		scrolltop,
    		scrollinfo,
    		updatescroll,
    		reload,
    		launch,
    		drophash,
    		parseloc,
    		parsenst,
    		linkupdate,
    		mklut,
    		onpop,
    		modifiers,
    		setmod,
    		unsetmod,
    		controls,
    		controlset,
    		setcontrols,
    		keydown,
    		keyup,
    		gs,
    		doctitle,
    		mktitle,
    		usedark,
    		c,
    		mkc,
    		ww,
    		wh,
    		style,
    		measures,
    		setcss,
    		ui,
    		uiname,
    		mkui,
    		uin,
    		mkuin,
    		pageinfo,
    		setPageinfo,
    		ready,
    		$pageinfo,
    		$uiname,
    		$finished,
    		$loading,
    		$usedark,
    		$ui,
    		$ww,
    		$uc,
    		$loc,
    		$rc,
    		$path,
    		$trail,
    		$links,
    		$modifiers,
    		$linkmap,
    		$title,
    		$space,
    		$page,
    		$haspage,
    		$hash,
    		$stem,
    		$fresh,
    		$gs,
    		$hassess,
    		$scrollinfo,
    		$session,
    		$haslogin,
    		$editing,
    		$creating,
    		$state,
    		$booted,
    		$component,
    		$hashistory,
    		$history,
    		$user,
    		$hasuser,
    		$tokens,
    		$message,
    		$aod,
    		$draft,
    		$wh
    	});

    	$$self.$inject_state = $$props => {
    		if ('booted' in $$props) $$invalidate(10, booted = $$props.booted);
    		if ('lut' in $$props) lut = $$props.lut;
    		if ('rc' in $$props) $$invalidate(11, rc$1 = $$props.rc);
    		if ('aod' in $$props) $$invalidate(12, aod = $$props.aod);
    		if ('links' in $$props) $$invalidate(13, links = $$props.links);
    		if ('linkmap' in $$props) $$invalidate(14, linkmap = $$props.linkmap);
    		if ('path' in $$props) $$invalidate(15, path = $$props.path);
    		if ('stem' in $$props) $$invalidate(16, stem = $$props.stem);
    		if ('hash' in $$props) $$invalidate(17, hash = $$props.hash);
    		if ('loc' in $$props) $$invalidate(18, loc = $$props.loc);
    		if ('fresh' in $$props) $$invalidate(19, fresh = $$props.fresh);
    		if ('session' in $$props) $$invalidate(20, session = $$props.session);
    		if ('message' in $$props) $$invalidate(21, message = $$props.message);
    		if ('loading' in $$props) $$invalidate(22, loading = $$props.loading);
    		if ('finished' in $$props) $$invalidate(23, finished = $$props.finished);
    		if ('debug' in $$props) debug = $$props.debug;
    		if ('space' in $$props) $$invalidate(24, space = $$props.space);
    		if ('title' in $$props) $$invalidate(25, title = $$props.title);
    		if ('page' in $$props) $$invalidate(26, page = $$props.page);
    		if ('tokens' in $$props) $$invalidate(27, tokens = $$props.tokens);
    		if ('user' in $$props) $$invalidate(28, user = $$props.user);
    		if ('history' in $$props) $$invalidate(29, history = $$props.history);
    		if ('draft' in $$props) $$invalidate(30, draft = $$props.draft);
    		if ('trail' in $$props) $$invalidate(31, trail = $$props.trail);
    		if ('creating' in $$props) $$invalidate(32, creating = $$props.creating);
    		if ('editing' in $$props) $$invalidate(33, editing = $$props.editing);
    		if ('haspage' in $$props) $$invalidate(34, haspage = $$props.haspage);
    		if ('hashistory' in $$props) $$invalidate(35, hashistory = $$props.hashistory);
    		if ('hasuser' in $$props) $$invalidate(36, hasuser = $$props.hasuser);
    		if ('hassess' in $$props) $$invalidate(37, hassess = $$props.hassess);
    		if ('haslogin' in $$props) $$invalidate(38, haslogin = $$props.haslogin);
    		if ('uc' in $$props) $$invalidate(39, uc = $$props.uc);
    		if ('heldmsg' in $$props) heldmsg = $$props.heldmsg;
    		if ('msgt' in $$props) msgt = $$props.msgt;
    		if ('state' in $$props) $$invalidate(40, state = $$props.state);
    		if ('component' in $$props) $$invalidate(41, component = $$props.component);
    		if ('loadstart' in $$props) loadstart = $$props.loadstart;
    		if ('renderstart' in $$props) renderstart = $$props.renderstart;
    		if ('loadtime' in $$props) loadtime = $$props.loadtime;
    		if ('rendertime' in $$props) rendertime = $$props.rendertime;
    		if ('contentscmp' in $$props) $$invalidate(6, contentscmp = $$props.contentscmp);
    		if ('scrollinfo' in $$props) $$invalidate(42, scrollinfo = $$props.scrollinfo);
    		if ('controlset' in $$props) controlset = $$props.controlset;
    		if ('gs' in $$props) $$invalidate(46, gs = $$props.gs);
    		if ('doctitle' in $$props) $$invalidate(7, doctitle = $$props.doctitle);
    		if ('usedark' in $$props) $$invalidate(47, usedark = $$props.usedark);
    		if ('c' in $$props) $$invalidate(0, c = $$props.c);
    		if ('ww' in $$props) $$invalidate(48, ww = $$props.ww);
    		if ('wh' in $$props) $$invalidate(49, wh = $$props.wh);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('measures' in $$props) $$invalidate(53, measures = $$props.measures);
    		if ('ui' in $$props) $$invalidate(50, ui = $$props.ui);
    		if ('uiname' in $$props) $$invalidate(51, uiname = $$props.uiname);
    		if ('ready' in $$props) ready = $$props.ready;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[1] & /*$links*/ 536870912) {
    			mklut($links);
    		}

    		if ($$self.$$.dirty[1] & /*$path, $trail*/ 402653184) {
    			if ($path != $trail[0]) {
    				$trail.unshift($path);
    				trail.set($trail);
    			}
    		}

    		if ($$self.$$.dirty[1] & /*$path*/ 134217728) {
    			launch();
    		}

    		if ($$self.$$.dirty[1] & /*$loc*/ 67108864) {
    			mktitle();
    		}

    		if ($$self.$$.dirty[0] & /*$uc*/ 32) {
    			if ($uc.autodark) {
    				set_store_value(usedark, $usedark = window.matchMedia('(prefers-color-scheme: dark)').matches, $usedark);
    			} else set_store_value(usedark, $usedark = $uc.darkmode, $usedark);
    		}

    		if ($$self.$$.dirty[0] & /*style*/ 2) {
    			if (style) {
    				$$invalidate(53, measures = setcss(c => {
    					c.basex = 1024;
    					c.wuicolx = 200;
    					c.pxgap = 5;
    					c.basemin = c.basex - 2 * c.pxgap;
    					c.basereal = c.basex + 2 * c.pxgap;
    					c.medx = c.basereal + c.wuicolx + c.pxgap;
    					c.widex = c.medx + c.wuicolx;
    					c.mainmax = 1200;
    					c.medw = c.wuicolx;
    					c.widew = c.wuicolx * 2 + c.pxgap;
    				}));
    			}
    		}

    		if ($$self.$$.dirty[0] & /*$ww*/ 16 | $$self.$$.dirty[1] & /*measures*/ 4194304) {
    			set_store_value(ui, $ui = mkui($ww), $ui);
    		}

    		if ($$self.$$.dirty[0] & /*$ui*/ 8) {
    			set_store_value(uiname, $uiname = mkuin($ui), $uiname);
    		}

    		if ($$self.$$.dirty[0] & /*$usedark*/ 4 | $$self.$$.dirty[1] & /*$loading, $finished, $uiname*/ 58720256) {
    			mkc();
    		}
    	};

    	return [
    		c,
    		style,
    		$usedark,
    		$ui,
    		$ww,
    		$uc,
    		contentscmp,
    		doctitle,
    		$booted,
    		$wh,
    		booted,
    		rc$1,
    		aod,
    		links,
    		linkmap,
    		path,
    		stem,
    		hash,
    		loc,
    		fresh,
    		session,
    		message,
    		loading,
    		finished,
    		space,
    		title,
    		page,
    		tokens,
    		user,
    		history,
    		draft,
    		trail,
    		creating,
    		editing,
    		haspage,
    		hashistory,
    		hasuser,
    		hassess,
    		haslogin,
    		uc,
    		state,
    		component,
    		scrollinfo,
    		modifiers,
    		keydown,
    		keyup,
    		gs,
    		usedark,
    		ww,
    		wh,
    		ui,
    		uiname,
    		pageinfo,
    		measures,
    		$uiname,
    		$finished,
    		$loading,
    		$loc,
    		$path,
    		$trail,
    		$links,
    		onwindowresize,
    		style_1_binding,
    		contents_binding
    	];
    }

    class Main extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {}, null, [-1, -1, -1, -1, -1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Main",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new Main({
    	target: document.body,
    });

    return app;

})();
//# sourceMappingURL=cpb.js.map
